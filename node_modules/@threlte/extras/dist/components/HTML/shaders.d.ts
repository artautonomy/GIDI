/**
 * These shaders add support for the logarithmicDepthBuffer.
 */
export declare const logVertex = "\n#include <common>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    #include <logdepthbuf_vertex>\n}";
export declare const logFragment = "\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4(0.0,0.0,0.0,0.0);\n}";
export declare const spriteVertex = "\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n  vec2 center = vec2(0., 1.);\n  float rotation = 0.0;\n  \n  // This is somewhat arbitrary, but it seems to work well\n  // Need to figure out how to derive this dynamically if it even matters\n  float size = 0.03;\n\n  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n  vec2 scale = vec2(\n    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),\n    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )\n  );\n\n  bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n  if ( isPerspective ) scale *= - mvPosition.z;\n\n  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n  vec2 rotatedPosition;\n  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n  mvPosition.xy += rotatedPosition;\n\n  gl_Position = projectionMatrix * mvPosition;\n  #include <logdepthbuf_vertex>\n}";
