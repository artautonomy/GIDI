var ye = Object.defineProperty;
var we = (t, n, e) => n in t ? ye(t, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[n] = e;
var _ = (t, n, e) => (we(t, typeof n != "symbol" ? n + "" : n, e), e);
import { ShaderLib as _e, UniformsUtils as Me, MeshDepthMaterial as Te, RGBADepthPacking as De, MeshDistanceMaterial as Ae, ShaderChunk as be, InstancedMesh as Ue, MeshBasicMaterial as Se, InstancedBufferAttribute as Pe, DataTexture as Q, RGBAFormat as L, FloatType as C, NearestFilter as U, ClampToEdgeWrapping as k, RepeatWrapping as q, Vector2 as $, Vector4 as fe, BufferGeometry as me, BufferAttribute as R, Scene as Fe, Camera as Re, Mesh as Ve, PlaneGeometry as he, ShaderMaterial as Ce, WebGLRenderTarget as Ie, REVISION as te, ImageLoader as Oe, Texture as Ee, CanvasTexture as ne, SRGBColorSpace as ie } from "three";
const pe = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function j(t) {
  const n = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function e(i, r) {
    let s = be[r];
    return s ? j(s) : i;
  }
  return t.replace(n, e);
}
const T = [];
for (let t = 0; t < 256; t++)
  T[t] = (t < 16 ? "0" : "") + t.toString(16);
function $e() {
  const t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (T[t & 255] + T[t >> 8 & 255] + T[t >> 16 & 255] + T[t >> 24 & 255] + "-" + T[n & 255] + T[n >> 8 & 255] + "-" + T[n >> 16 & 15 | 64] + T[n >> 24 & 255] + "-" + T[e & 63 | 128] + T[e >> 8 & 255] + "-" + T[e >> 16 & 255] + T[e >> 24 & 255] + T[i & 255] + T[i >> 8 & 255] + T[i >> 16 & 255] + T[i >> 24 & 255]).toUpperCase();
}
const P = Object.assign || function() {
  let t = arguments[0];
  for (let n = 1, e = arguments.length; n < e; n++) {
    let i = arguments[n];
    if (i)
      for (let r in i)
        Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]);
  }
  return t;
}, ze = Date.now(), re = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new Map();
let He = 1e10;
function N(t, n) {
  const e = Ge(n);
  let i = re.get(t);
  if (i || re.set(t, i = /* @__PURE__ */ Object.create(null)), i[e])
    return new i[e]();
  const r = `_onBeforeCompile${e}`, s = function(o, m) {
    t.onBeforeCompile.call(this, o, m);
    const g = this.customProgramCacheKey() + "|" + o.vertexShader + "|" + o.fragmentShader;
    let h = se[g];
    if (!h) {
      const x = Le(this, o, n, e);
      h = se[g] = x;
    }
    o.vertexShader = h.vertexShader, o.fragmentShader = h.fragmentShader, P(o.uniforms, this.uniforms), n.timeUniform && (o.uniforms[n.timeUniform] = {
      get value() {
        return Date.now() - ze;
      }
    }), this[r] && this[r](o);
  }, a = function() {
    return l(n.chained ? t : t.clone());
  }, l = function(o) {
    const m = Object.create(o, u);
    return Object.defineProperty(m, "baseMaterial", { value: t }), Object.defineProperty(m, "id", { value: He++ }), m.uuid = $e(), m.uniforms = P({}, o.uniforms, n.uniforms), m.defines = P({}, o.defines, n.defines), m.defines[`TROIKA_DERIVED_MATERIAL_${e}`] = "", m.extensions = P({}, o.extensions, n.extensions), m._listeners = void 0, m;
  }, u = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return t.customProgramCacheKey() + "|" + e;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(o) {
        this[r] = o;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(o) {
        return t.copy.call(this, o), !t.isShaderMaterial && !t.isDerivedMaterial && (P(this.extensions, o.extensions), P(this.defines, o.defines), P(this.uniforms, Me.clone(o.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const o = new t.constructor();
        return l(o).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let o = this._depthMaterial;
        return o || (o = this._depthMaterial = N(
          t.isDerivedMaterial ? t.getDepthMaterial() : new Te({ depthPacking: De }),
          n
        ), o.defines.IS_DEPTH_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let o = this._distanceMaterial;
        return o || (o = this._distanceMaterial = N(
          t.isDerivedMaterial ? t.getDistanceMaterial() : new Ae(),
          n
        ), o.defines.IS_DISTANCE_MATERIAL = "", o.uniforms = this.uniforms), o;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: o, _distanceMaterial: m } = this;
        o && o.dispose(), m && m.dispose(), t.dispose.call(this);
      }
    }
  };
  return i[e] = a, new a();
}
function Le(t, { vertexShader: n, fragmentShader: e }, i, r) {
  let {
    vertexDefs: s,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: u,
    fragmentDefs: o,
    fragmentMainIntro: m,
    fragmentMainOutro: g,
    fragmentColorTransform: h,
    customRewriter: x,
    timeUniform: f
  } = i;
  if (s = s || "", a = a || "", l = l || "", o = o || "", m = m || "", g = g || "", (u || x) && (n = j(n)), (h || x) && (e = e.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), e = j(e)), x) {
    let c = x({ vertexShader: n, fragmentShader: e });
    n = c.vertexShader, e = c.fragmentShader;
  }
  if (h) {
    let c = [];
    e = e.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (p) => (c.push(p), "")
    ), g = `${h}
${c.join(`
`)}
${g}`;
  }
  if (f) {
    const c = `
uniform float ${f};
`;
    s = c + s, o = c + o;
  }
  return u && (n = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${n}
`, s = `${s}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, n = n.replace(/\b(position|normal|uv)\b/g, (c, p, w, y) => /\battribute\s+vec[23]\s+$/.test(y.substr(0, w)) ? p : `troika_${p}_${r}`), t.map && t.map.channel > 0 || (n = n.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), n = ae(n, r, s, a, l), e = ae(e, r, o, m, g), {
    vertexShader: n,
    fragmentShader: e
  };
}
function ae(t, n, e, i, r) {
  return (i || r || e) && (t = t.replace(
    pe,
    `
${e}
void troikaOrigMain${n}() {`
  ), t += `
void main() {
  ${i}
  troikaOrigMain${n}();
  ${r}
}`), t;
}
function ke(t, n) {
  return t === "uniforms" ? void 0 : typeof n == "function" ? n.toString() : n;
}
let Ne = 0;
const oe = /* @__PURE__ */ new Map();
function Ge(t) {
  const n = JSON.stringify(t, ke);
  let e = oe.get(n);
  return e == null && oe.set(n, e = ++Ne), e;
}
const Ze = {
  MeshDepthMaterial: "depth",
  MeshDistanceMaterial: "distanceRGBA",
  MeshNormalMaterial: "normal",
  MeshBasicMaterial: "basic",
  MeshLambertMaterial: "lambert",
  MeshPhongMaterial: "phong",
  MeshToonMaterial: "toon",
  MeshStandardMaterial: "physical",
  MeshPhysicalMaterial: "physical",
  MeshMatcapMaterial: "matcap",
  LineBasicMaterial: "basic",
  LineDashedMaterial: "dashed",
  PointsMaterial: "points",
  ShadowMaterial: "shadow",
  SpriteMaterial: "sprite"
};
function Be(t) {
  let n = Ze[t.type];
  return n ? _e[n] : t;
}
function le(t) {
  let n = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g, e = /* @__PURE__ */ Object.create(null), i;
  for (; (i = n.exec(t)) !== null; )
    e[i[2]] = i[1];
  return e;
}
function Ke(t) {
  let n = [], e = "";
  const i = N(t, {
    chained: !0,
    customRewriter({ vertexShader: s, fragmentShader: a }) {
      let l = [], u = [], o = [], m = le(s), g = le(a);
      return n.forEach((h) => {
        let x = m[h], f = g[h];
        const c = x || f;
        if (c) {
          const p = new RegExp(`\\buniform\\s+${c}\\s+${h}\\s*;`, "g"), w = new RegExp(`\\b${h}\\b`, "g"), y = `troika_attr_${h}`, d = `troika_vary_${h}`;
          if (l.push(`attribute ${c} ${y};`), x && (s = s.replace(p, ""), s = s.replace(w, y)), f) {
            a = a.replace(p, ""), a = a.replace(w, d);
            let v = `varying ${f} ${d};`;
            l.push(v), o.push(v), u.push(`${d} = ${y};`);
          }
        }
      }), s = `${l.join(`
`)}
${s.replace(pe, `
$&
${u.join(`
`)}`)}`, o.length && (a = `${o.join(`
`)}
${a}`), { vertexShader: s, fragmentShader: a };
    }
  });
  i.setUniformNames = function(s) {
    n = s || [];
    const a = n.sort().join("|");
    a !== e && (e = a, this.needsUpdate = !0);
  };
  const r = i.customProgramCacheKey();
  return i.customProgramCacheKey = function() {
    return r + "|" + e;
  }, i.isInstancedUniformsMaterial = !0, i;
}
class je extends Ue {
  constructor(n, e, i) {
    super(n, e, i), this._maxCount = i, this._instancedUniformNames = [];
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied geometry with one that will
   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather
   * than write to avoid unnecessary wrapping on transient values.
   */
  get geometry() {
    let n = this._derivedGeometry;
    const e = this._baseGeometry;
    return (!n || n.baseGeometry !== e) && (n = this._derivedGeometry = Object.create(e), n.baseGeometry = e, n.attributes = Object.create(e.attributes), e.addEventListener("dispose", function() {
      n.dispose();
    })), n;
  }
  set geometry(n) {
    this._baseGeometry = n;
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the
   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
   */
  get material() {
    let n = this._derivedMaterial;
    const e = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new Se());
    return (!n || n.baseMaterial !== e) && (n = this._derivedMaterial = Ke(e), e.addEventListener("dispose", function i() {
      e.removeEventListener("dispose", i), n.dispose();
    })), n.setUniformNames(this._instancedUniformNames), n;
  }
  set material(n) {
    if (Array.isArray(n))
      throw new Error("InstancedUniformsMesh does not support multiple materials");
    for (; n && n.isInstancedUniformsMaterial; )
      n = n.baseMaterial;
    this._baseMaterial = n;
  }
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  /**
   * Set the value of a shader uniform for a single instance.
   * @param {string} name - the name of the shader uniform
   * @param {number} index - the index of the instance to set the value for
   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance
   */
  setUniformAt(n, e, i) {
    const r = this.geometry.attributes, s = `troika_attr_${n}`;
    let a = r[s];
    if (!a) {
      const l = We(this._baseMaterial, n), u = Ye(l);
      if (a = r[s] = new Pe(new Float32Array(u * this._maxCount), u), l !== null)
        for (let o = 0; o < this._maxCount; o++)
          ue(a, o, l);
      this._instancedUniformNames = [...this._instancedUniformNames, n];
    }
    ue(a, e, i), a.needsUpdate = !0;
  }
  /**
   * Unset all instance-specific values for a given uniform, reverting back to the original
   * uniform value for all.
   * @param {string} name
   */
  unsetUniform(n) {
    this.geometry.deleteAttribute(`troika_attr_${n}`), this._instancedUniformNames = this._instancedUniformNames.filter((e) => e !== n);
  }
}
function ue(t, n, e) {
  let i = t.itemSize;
  i === 1 ? t.setX(n, e) : i === 2 ? t.setXY(n, e.x, e.y) : i === 3 ? e.isColor ? t.setXYZ(n, e.r, e.g, e.b) : t.setXYZ(n, e.x, e.y, e.z) : i === 4 ? t.setXYZW(n, e.x, e.y, e.z, e.w) : e.toArray ? e.toArray(t.array, n * i) : t.set(e, n * i);
}
function We(t, n) {
  let e = t.uniforms;
  return e && e[n] || (e = Be(t).uniforms, e && e[n]) ? e[n].value : null;
}
function Ye(t) {
  return t == null ? 0 : typeof t == "number" ? 1 : t.isVector2 ? 2 : t.isVector3 || t.isColor ? 3 : t.isVector4 || t.isQuaternion ? 4 : t.elements ? t.elements.length : Array.isArray(t) ? t.length : 0;
}
const Xe = (t, n) => {
  const e = t.split(`
`), i = /vMapUv|vAlphaMapUv|vNormalMapUv/g;
  return e.map((s) => !s.includes("varying") && !s.includes("uniform") ? s.replace(i, n) : s).join(`
`);
}, Je = (t, n) => {
  const e = {
    USE_UV: ""
  };
  return n && (e.TRI_GEOMETRY = ""), N(t, {
    defines: e,
    uniforms: {
      /** GPGPU animation driven data */
      animationData: { value: null },
      animationDataSize: { value: 0 },
      /* Repeat animation in a loop */
      billboarding: { value: 0 },
      /** flip uvs on x */
      flipX: { value: 0 },
      /** flip uvs on y */
      flipY: { value: 0 },
      /**
       * DataArrayTexture - data stored in columns. Rows are:
       * 0 - Frames declaration - RGBA[x,y,w,h]
       * 1 - Animation lengths RGBA[length,0,0,0]
       * 2 - Animation0 - RGBA [id,duration, 0,0]
       * 3 - Animation1 - RGBA [id,duration, 0,0]
       * ....etc
       */
      spritesheetData: { value: null },
      /**util for reading data texture in spritesheetData */
      dataSize: { value: new $(0, 0) },
      /**
       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))
       */
      tint: { value: new fe(0, 0, 0, 0) }
    },
    /**
     *
     * VERTEX
     * - billboarding
     *
     * */
    vertexDefs: (
      /*glsl*/
      `
    uniform float billboarding;
    flat varying int vId;
    `
    ),
    vertexMainOutro: (
      /*glsl*/
      `
    vId = gl_InstanceID;
    if(billboarding == 1.){
      vec3 instancePosition = vec3(instanceMatrix[3]);
      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));

      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

      vec3 vertexPosition_worldspace = instancePosition
        + cameraRight_worldspace * position.x * instanceScale.x
        + cameraUp_worldspace * position.y * instanceScale.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);
    }
    `
    ),
    /**
     *
     * FRAGMENT REWRITER
     *
     * */
    customRewriter: ({ vertexShader: r, fragmentShader: s }) => {
      const a = (
        /*glsl*/
        `
			uniform sampler2D animationData;
      uniform int animationDataSize;
			uniform sampler2D spritesheetData;
      uniform float startTime;
			uniform float time;
			uniform float flipX;
			uniform float flipY;
			uniform vec2 dataSize;
      uniform vec4 tint;

      flat varying int vId;
			`
      ), l = (
        /*glsl*/
        `
			vec4 readData(float col, float row) {
				float wStep = 1.f / dataSize.x;
				float wHalfStep = wStep * 0.5f;
				float hStep = 1.f / dataSize.y;
				float hHalfStep = 1.f / dataSize.y * 0.5f;
				return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
			}

      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {
        // Shift UVs so that the zoom center is the origin
        vec2 shiftedUV = uv - zoomCenter;

        // Scale (zoom) the UV coordinates
        shiftedUV *= zoomFactor;

        // Shift back
        shiftedUV += zoomCenter;

        return shiftedUV;
    }
			`
      ), u = (
        /*glsl*/
        `
      float y = float(vId / animationDataSize) / float(animationDataSize);
      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);

      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;

			// x,y,w,h
			vec4 frameMeta = readData(spritesheetFrameId, 0.f);

			vec2 fSize = frameMeta.zw;
			vec2 fOffset = vec2(frameMeta.xy);

      vec2 transformedPlaneUv = vUv + vec2(0.,0.);

      // todo  == 1. caused a flickering bug. look into Precision/interpolation?
      if(flipX > 0.){
        transformedPlaneUv.x = 1. - transformedPlaneUv.x;
      }
      if(flipY > 0.){
        transformedPlaneUv.y = 1. - transformedPlaneUv.y;
      }

			vec2 spriteUv = fSize * transformedPlaneUv + fOffset ;

      #ifdef TRI_GEOMETRY
        // Shift UVs if mesh uses triangle geometry
        // TODO optimize ugly math
        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){
          discard;
        }

        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;
        float zoomFactor = 2.;
        vec2 shiftedUV = spriteUv - zoomCenter;
        shiftedUV *= zoomFactor;
        shiftedUV += zoomCenter;
        spriteUv = shiftedUV;
      #endif



			`
      );
      return s = s.replace(
        "void main() {",
        `void main() {${u}`
      ), s = `
			${a}
			${l}
			${s}
			`, s = s.replace(
        "vec4 sampledDiffuseColor = texture2D( map, vMapUv );",
        /*glsl*/
        `
        vec4 sampledDiffuseColor = texture2D( map, vMapUv );
        if(tint.w == 1.){
          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);
          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));
          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));
          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);
          res = res * tint.z;

          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);
        }

        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);
      `
      ), s = Xe(s, "spriteUv"), { vertexShader: r, fragmentShader: s };
    }
  });
}, Bt = (t) => {
  const n = [], e = [], i = {}, r = [], s = t.meta.size.w, a = t.meta.size.h, l = [
    t.meta.size.w,
    t.meta.size.h
  ];
  for (const u in t.frames) {
    const o = t.frames[u];
    n.push([o.frame.x / s, o.frame.y / a, o.frame.w / s, o.frame.h / a]), e.push(o.duration);
  }
  for (const u of t.meta.frameTags) {
    i[u.name] = [];
    for (let o = u.from; o <= u.to; o++)
      i[u.name].push([o, e[o]]);
    r.push(i[u.name].length);
  }
  return { frames: n, animations: i, sheetSize: l, animationLengths: r };
}, Qe = (t) => {
  const { frames: n, animationLengths: e, animations: i } = t, r = Math.max(
    n.length,
    e.length,
    ...Object.values(i).map((x) => x.length)
  ), s = 2 + Object.values(i).length, a = n.flat().concat(new Array((r - n.length) * 4).fill(0)), l = e.map((x) => [x, 0, 0, 0]).flat().concat(new Array((r - e.length) * 4).fill(0)), u = [], o = /* @__PURE__ */ new Map();
  for (let x = 0; x < Object.keys(i).length; x++) {
    const f = Object.keys(i)[x];
    o.set(f, x);
    const c = i[f].map((p) => [...p, 0, 0]).flat().concat(new Array((r - i[f].length) * 4).fill(0));
    u.push(...c);
  }
  const m = [
    ...a,
    ...l,
    ...u
  ], g = new Float32Array(m);
  g.set(m);
  const h = new Q(
    g,
    r,
    s,
    L,
    C
  );
  return h.type = C, h.minFilter = U, h.magFilter = U, h.wrapS = k, h.wrapT = q, h.needsUpdate = !0, { dataTexture: h, dataWidth: r, dataHeight: s, animMap: o };
}, qe = () => {
  const t = new me(), n = new Float32Array([
    // top
    0,
    1,
    0,
    // bot-left
    -1,
    -1,
    0,
    // bot-right
    1,
    -1,
    0
  ]);
  t.setAttribute("position", new R(n, 3));
  const e = new Float32Array([
    // top
    0.5,
    1,
    // bot-left
    0,
    0,
    // bot-right
    1,
    0
  ]);
  return t.setAttribute("uv", new R(e, 2)), t.computeVertexNormals(), t;
};
class et {
  constructor(n, e, i) {
    this.variables = [], this.currentTextureIndex = 0;
    let r = C;
    const s = new Fe(), a = new Re();
    a.position.z = 1;
    const l = {
      passThruTexture: { value: null }
    }, u = g(x(), l), o = new Ve(new he(2, 2), u);
    s.add(o), this.setDataType = function(f) {
      return r = f, this;
    }, this.addVariable = function(f, c, p) {
      const w = this.createShaderMaterial(c), y = {
        name: f,
        initialValueTexture: p,
        material: w,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: U,
        magFilter: U
      };
      return this.variables.push(y), y;
    }, this.setVariableDependencies = function(f, c) {
      f.dependencies = c;
    }, this.init = function() {
      if (i.capabilities.isWebGL2 === !1 && i.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (i.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let f = 0; f < this.variables.length; f++) {
        const c = this.variables[f];
        c.renderTargets[0] = this.createRenderTarget(n, e, c.wrapS, c.wrapT, c.minFilter, c.magFilter), c.renderTargets[1] = this.createRenderTarget(n, e, c.wrapS, c.wrapT, c.minFilter, c.magFilter), this.renderTexture(c.initialValueTexture, c.renderTargets[0]), this.renderTexture(c.initialValueTexture, c.renderTargets[1]);
        const p = c.material, w = p.uniforms;
        if (c.dependencies !== null)
          for (let y = 0; y < c.dependencies.length; y++) {
            const d = c.dependencies[y];
            if (d.name !== c.name) {
              let v = !1;
              for (let D = 0; D < this.variables.length; D++)
                if (d.name === this.variables[D].name) {
                  v = !0;
                  break;
                }
              if (!v)
                return "Variable dependency not found. Variable=" + c.name + ", dependency=" + d.name;
            }
            w[d.name] = { value: null }, p.fragmentShader = `
uniform sampler2D ` + d.name + `;
` + p.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const f = this.currentTextureIndex, c = this.currentTextureIndex === 0 ? 1 : 0;
      for (let p = 0, w = this.variables.length; p < w; p++) {
        const y = this.variables[p];
        if (y.dependencies !== null) {
          const d = y.material.uniforms;
          for (let v = 0, D = y.dependencies.length; v < D; v++) {
            const S = y.dependencies[v];
            d[S.name].value = S.renderTargets[f].texture;
          }
        }
        this.doRenderTarget(y.material, y.renderTargets[c]);
      }
      this.currentTextureIndex = c;
    }, this.getCurrentRenderTarget = function(f) {
      return f.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(f) {
      return f.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      o.geometry.dispose(), o.material.dispose();
      const f = this.variables;
      for (let c = 0; c < f.length; c++) {
        const p = f[c];
        p.initialValueTexture && p.initialValueTexture.dispose();
        const w = p.renderTargets;
        for (let y = 0; y < w.length; y++)
          w[y].dispose();
      }
    };
    function m(f) {
      f.defines.resolution = "vec2( " + n.toFixed(1) + ", " + e.toFixed(1) + " )";
    }
    this.addResolutionDefine = m;
    function g(f, c) {
      c = c || {};
      const p = new Ce({
        name: "GPUComputationShader",
        uniforms: c,
        vertexShader: h(),
        fragmentShader: f
      });
      return m(p), p;
    }
    this.createShaderMaterial = g, this.createRenderTarget = function(f, c, p, w, y, d) {
      return f = f || n, c = c || e, p = p || k, w = w || k, y = y || U, d = d || U, new Ie(f, c, {
        wrapS: p,
        wrapT: w,
        minFilter: y,
        magFilter: d,
        format: L,
        type: r,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const f = new Float32Array(n * e * 4), c = new Q(f, n, e, L, C);
      return c.needsUpdate = !0, c;
    }, this.renderTexture = function(f, c) {
      l.passThruTexture.value = f, this.doRenderTarget(u, c), l.passThruTexture.value = null;
    }, this.doRenderTarget = function(f, c) {
      const p = i.getRenderTarget(), w = i.xr.enabled, y = i.shadowMap.autoUpdate;
      i.xr.enabled = !1, i.shadowMap.autoUpdate = !1, o.material = f, i.setRenderTarget(c), i.render(s, a), o.material = u, i.xr.enabled = w, i.shadowMap.autoUpdate = y, i.setRenderTarget(p);
    };
    function h() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function x() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const tt = (
  /*glsl*/
  `
  #include <common>
  uniform sampler2D instructionsTexture;

  uniform sampler2D spritesheetData;
  uniform vec2 dataSize;
  uniform float fps;
  uniform float deltaTime;

  // read spritesheet metadata
  vec4 readData(float col, float row, sampler2D tex) {
    float wStep = 1.f / dataSize.x;
    float wHalfStep = wStep * 0.5f;
    float hStep = 1.f / dataSize.y;
    float hHalfStep = 1.f / dataSize.y * 0.5f;
    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
  }



  void main()	{

    // OUTPUT FROM THIS SHADER
    // progressValue.r - picked animation frame
    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)
    // progressValue.b - not used yet
    // progressValue.a - previous animationID

    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;


    vec4 progressValue = texture2D( progress, uv );

    vec4 instructions = texture2D( instructionsTexture, uv);

    // FREEZE FRAME - return to save calculations?
    if(instructions.a >=10.){
      progressValue.r = instructions.a - 10.;
      progressValue.a = instructions.x;
      progressValue.g = progressValue.g;
      gl_FragColor = progressValue;
      return;
    }


    progressValue.b = 0.;

    // todo shouldn't be rounding here, pick
    float animationId = round(instructions.x);

    float offset = instructions.g;

    float animLength = readData(animationId, 1.f, spritesheetData).r;
    float totalTime = animLength / fps;

    // new delta is % of animation
    float newProgress = deltaTime / totalTime;
    // add new delta to saved progress
    float frameTimedId = mod(progressValue.g + newProgress, 1.);
    // frameTimedId = 0.;
    // float frameTimedId = progressValue.g;
    // save for use in next frame



    float playMode = mod(instructions.b, 10.);

    // forward
    if(playMode == 0.){
      frameTimedId = progressValue.g + newProgress;
    }
    // reverse
    if(playMode == 1.){
      frameTimedId = progressValue.g - newProgress;
    }
    // 2 - pause - do nothing
    if(playMode == 2.){
      frameTimedId = progressValue.g;
    }

    // //todo pingpong
    // if(playMode == 3.){
    // }

    // loop (play once over 10.)
    if(instructions.b < 10.){
      frameTimedId = mod(frameTimedId, 1.);
    }

    // todo This could be optional and user would reset manually,
    // todo allowing for consistent movement across multiple animations
    // todo for example - running steps being syncec
    // start anim from beginning if animationID changes
    if(progressValue.a != instructions.x){
      frameTimedId = 0.;
    }

    float frameId = floor(animLength * frameTimedId);
    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;



    // Picked sprite frame that goes to material
    progressValue.r = spritesheetFrameId;

    progressValue.a = instructions.x;
    progressValue.g = frameTimedId;

    gl_FragColor = progressValue;
  }
`
), nt = (t = 512) => {
  const n = new Float32Array(t ** 2 * 4);
  for (let i = 0; i < t ** 2 * 4; i++)
    n[i] = 0;
  const e = new Q(
    n,
    t,
    t,
    L,
    C
  );
  return e.minFilter = U, e.magFilter = U, e.wrapS = k, e.wrapT = q, e.needsUpdate = !0, e;
}, it = (t) => {
  if (t <= 0)
    return 1;
  let n = 1;
  for (; n < t; )
    n <<= 1;
  return n;
}, rt = (t, n) => {
  const e = it(Math.sqrt(n)), i = new et(
    e,
    e,
    t
  ), r = i.createTexture(), s = i.addVariable(
    "progress",
    tt,
    r
  ), a = nt(e);
  s.material.uniforms.instructionsTexture = {
    value: a
  }, s.material.uniforms.spritesheetData = { value: null }, s.material.uniforms.fps = { value: 0 }, s.material.uniforms.deltaTime = { value: 0 }, s.material.uniforms.dataSize = { value: new $() }, i.setVariableDependencies(s, [s]);
  const l = i.init();
  l !== null && console.error(l);
  let u = !1;
  return {
    gpuCompute: i,
    animationRunner: s,
    progressDataTexture: a,
    utils: {
      updateAnimationAt: (f, c) => {
        const p = f * 4;
        a.image.data[p] = c, u = !0;
      },
      updateOffsetAt: (f, c) => {
        const p = f * 4;
        a.image.data[p + 1] = c, u = !0;
      },
      updatePlaymodeAt: (f, c) => {
        const p = f * 4;
        a.image.data[p + 2] = c, u = !0;
      },
      updateFrameAt: (f, c) => {
        const p = f * 4;
        a.image.data[p + 3] = c + 10, u = !0;
      }
    },
    update: () => {
      u && (a.needsUpdate = !0, u = !1), i.compute();
    }
  };
};
class st {
  constructor() {
    _(this, "_previousTime");
    _(this, "_currentTime");
    _(this, "_startTime");
    _(this, "_delta");
    _(this, "_elapsed");
    _(this, "_timescale");
    _(this, "_useFixedDelta");
    _(this, "_fixedDelta");
    _(this, "_usePageVisibilityAPI");
    _(this, "_pageVisibilityHandler");
    this._previousTime = 0, this._currentTime = 0, this._startTime = B(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = at.bind(this), document.addEventListener(
      "visibilitychange",
      this._pageVisibilityHandler,
      !1
    ));
  }
  disableFixedDelta() {
    return this._useFixedDelta = !1, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === !0 && document.removeEventListener(
      "visibilitychange",
      this._pageVisibilityHandler
    ), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = !0, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = B() - this._startTime, this;
  }
  setFixedDelta(n) {
    return this._fixedDelta = n * 1e3, this;
  }
  setTimescale(n) {
    return this._timescale = n, this;
  }
  update() {
    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = B() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
}
function B() {
  return (typeof performance > "u" ? Date : performance).now();
}
function at() {
  document.hidden === !1 && this.reset();
}
const K = {
  FORWARD: 0,
  REVERSE: 1,
  PAUSE: 2,
  PINGPONG: 3
};
class Kt extends je {
  constructor(e, i, r, s = {
    geometry: "quad"
  }) {
    let a;
    s.geometry || (s.geometry = "quad"), s.geometry === "tri" && (a = qe()), s.geometry === "quad" && (a = new he(1, 1)), s.geometry && typeof s.geometry != "string" && (a = s.geometry);
    const l = Je(
      e,
      (s == null ? void 0 : s.geometry) === "tri"
    );
    super(a, l, i);
    _(this, "_spriteMaterial");
    _(this, "_spritesheet");
    _(this, "_animationMap");
    _(this, "_fps", 15);
    _(this, "_timer");
    _(this, "compute");
    te >= 159 ? (this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, i * 16)) : this.instanceMatrix.updateRange.count = i * 16, this.instanceColor && (te >= 159 ? (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, i * 3)) : this.instanceColor.updateRange.count = i * 3), this.compute = rt(r, i), this._spriteMaterial = l, s.spritesheet && this.updateSpritesheet(s.spritesheet), this._timer = new st(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(
      this.compute.animationRunner
    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;
  }
  updateSpritesheet(e) {
    const { dataTexture: i, dataWidth: r, dataHeight: s, animMap: a } = Qe(e);
    this._spriteMaterial.uniforms.spritesheetData.value = i, this._spriteMaterial.uniforms.dataSize.value.x = r, this._spriteMaterial.uniforms.dataSize.value.y = s, this.compute.animationRunner.material.uniforms.dataSize.value = new $(r, s), this.compute.animationRunner.material.uniforms.spritesheetData.value = i, this._animationMap = a;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(e) {
    this.updateSpritesheet(e), this._spritesheet = e;
  }
  get animationMap() {
    return this._animationMap;
  }
  get animation() {
    return {
      setAt: (e, i) => {
        this.compute.utils.updateAnimationAt(
          e,
          this._animationMap.get(i) || 0
        );
      }
    };
  }
  get frame() {
    return {
      setAt: (e, i, r) => {
        var a;
        let s = i;
        r && (s = (a = this.spritesheet) == null ? void 0 : a.animations[r][i][0]), this.compute.utils.updateFrameAt(e, s);
      },
      unsetAt: (e) => {
        this.compute.utils.updateFrameAt(e, -10);
      },
      unsetAll: () => {
        for (let e = 0; e < this.count; e++)
          this.compute.utils.updateFrameAt(e, -10);
      }
    };
  }
  get playmode() {
    return {
      setAt: (e, i) => {
        this.compute.utils.updatePlaymodeAt(e, K[i]);
      },
      setAll: (e) => {
        for (let i = 0; i < this.count; i++) {
          const r = this.compute.progressDataTexture.image.data[i * 4 + 2] >= 10 ? 10 : 0;
          this.compute.utils.updatePlaymodeAt(i, r + K[e]);
        }
      }
    };
  }
  get billboarding() {
    return {
      setAt: (e, i) => {
        this.setUniformAt("billboarding", e, i ? 1 : 0);
      },
      setAll: (e) => {
        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("billboarding");
      }
    };
  }
  get offset() {
    return {
      setAt: (e, i) => {
        this.compute.utils.updateOffsetAt(e, i);
      },
      randomizeAll: (e = 1) => {
        for (let i = 0; i < this.count; i++)
          this.compute.utils.updateOffsetAt(i, Math.random() * e);
      }
    };
  }
  get loop() {
    return {
      setAt: (e, i) => {
        const r = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;
        this.compute.utils.updatePlaymodeAt(
          e,
          r + (i ? 0 : 10)
        );
      },
      setAll: (e) => {
        for (let i = 0; i < this.count; i++) {
          const r = this.compute.progressDataTexture.image.data[i * 4 + 2] % 10;
          this.compute.utils.updatePlaymodeAt(i, r + (e ? 0 : 10));
        }
      }
    };
  }
  get flipX() {
    return {
      setAt: (e, i) => {
        this.setUniformAt("flipX", e, i ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipX");
      }
    };
  }
  get flipY() {
    return {
      setAt: (e, i) => {
        this.setUniformAt("flipY", e, i ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipY");
      }
    };
  }
  play(e, i = !0, r = "FORWARD") {
    return {
      at: (s) => {
        this.compute.utils.updateAnimationAt(
          s,
          this._animationMap.get(e) || 0
        ), this.compute.utils.updatePlaymodeAt(
          s,
          K[r] + (i ? 0 : 10)
        );
      }
    };
  }
  /** HSV shift tinting */
  get hueShift() {
    const e = new fe();
    return {
      // TODO - per instance tinting doesnt work - artifacts
      // setAt: (
      //   instanceId: number,
      //   tint?: { h: number; s: number; v: number }
      // ) => {
      //   if (tint) {
      //     tVector.set(tint.h, tint.s, tint.v, 1);
      //   } else {
      //     tVector.setW(0);
      //   }
      //   this.setUniformAt("tint", instanceId, tVector);
      // },
      setGlobal: (i) => {
        i ? e.set(i.h, i.s, i.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;
      }
      // unsetAll: () => {
      //   this.unsetUniform("tint");
      // },
    };
  }
  get fps() {
    return this._fps;
  }
  set fps(e) {
    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;
  }
  update() {
    this._timer.update();
    const e = this._timer.getDelta();
    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();
  }
}
function ot(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ee = { exports: {} };
ee.exports = G;
ee.exports.default = G;
function G(t, n, e) {
  e = e || 2;
  var i = n && n.length, r = i ? n[0] * e : t.length, s = de(t, 0, r, e, !0), a = [];
  if (!s || s.next === s.prev)
    return a;
  var l, u, o, m, g, h, x;
  if (i && (s = mt(t, n, s, e)), t.length > 80 * e) {
    l = o = t[0], u = m = t[1];
    for (var f = e; f < r; f += e)
      g = t[f], h = t[f + 1], g < l && (l = g), h < u && (u = h), g > o && (o = g), h > m && (m = h);
    x = Math.max(o - l, m - u), x = x !== 0 ? 32767 / x : 0;
  }
  return I(s, a, e, l, u, x, 0), a;
}
function de(t, n, e, i, r) {
  var s, a;
  if (r === X(t, n, e, i) > 0)
    for (s = n; s < e; s += i)
      a = ce(s, t[s], t[s + 1], a);
  else
    for (s = e - i; s >= n; s -= i)
      a = ce(s, t[s], t[s + 1], a);
  return a && Z(a, a.next) && (E(a), a = a.next), a;
}
function F(t, n) {
  if (!t)
    return t;
  n || (n = t);
  var e = t, i;
  do
    if (i = !1, !e.steiner && (Z(e, e.next) || M(e.prev, e, e.next) === 0)) {
      if (E(e), e = n = e.prev, e === e.next)
        break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== n);
  return n;
}
function I(t, n, e, i, r, s, a) {
  if (t) {
    !a && s && xt(t, i, r, s);
    for (var l = t, u, o; t.prev !== t.next; ) {
      if (u = t.prev, o = t.next, s ? ut(t, i, r, s) : lt(t)) {
        n.push(u.i / e | 0), n.push(t.i / e | 0), n.push(o.i / e | 0), E(t), t = o.next, l = o.next;
        continue;
      }
      if (t = o, t === l) {
        a ? a === 1 ? (t = ct(F(t), n, e), I(t, n, e, i, r, s, 2)) : a === 2 && ft(t, n, e, i, r, s) : I(F(t), n, e, i, r, s, 1);
        break;
      }
    }
  }
}
function lt(t) {
  var n = t.prev, e = t, i = t.next;
  if (M(n, e, i) >= 0)
    return !1;
  for (var r = n.x, s = e.x, a = i.x, l = n.y, u = e.y, o = i.y, m = r < s ? r < a ? r : a : s < a ? s : a, g = l < u ? l < o ? l : o : u < o ? u : o, h = r > s ? r > a ? r : a : s > a ? s : a, x = l > u ? l > o ? l : o : u > o ? u : o, f = i.next; f !== n; ) {
    if (f.x >= m && f.x <= h && f.y >= g && f.y <= x && V(r, l, s, u, a, o, f.x, f.y) && M(f.prev, f, f.next) >= 0)
      return !1;
    f = f.next;
  }
  return !0;
}
function ut(t, n, e, i) {
  var r = t.prev, s = t, a = t.next;
  if (M(r, s, a) >= 0)
    return !1;
  for (var l = r.x, u = s.x, o = a.x, m = r.y, g = s.y, h = a.y, x = l < u ? l < o ? l : o : u < o ? u : o, f = m < g ? m < h ? m : h : g < h ? g : h, c = l > u ? l > o ? l : o : u > o ? u : o, p = m > g ? m > h ? m : h : g > h ? g : h, w = W(x, f, n, e, i), y = W(c, p, n, e, i), d = t.prevZ, v = t.nextZ; d && d.z >= w && v && v.z <= y; ) {
    if (d.x >= x && d.x <= c && d.y >= f && d.y <= p && d !== r && d !== a && V(l, m, u, g, o, h, d.x, d.y) && M(d.prev, d, d.next) >= 0 || (d = d.prevZ, v.x >= x && v.x <= c && v.y >= f && v.y <= p && v !== r && v !== a && V(l, m, u, g, o, h, v.x, v.y) && M(v.prev, v, v.next) >= 0))
      return !1;
    v = v.nextZ;
  }
  for (; d && d.z >= w; ) {
    if (d.x >= x && d.x <= c && d.y >= f && d.y <= p && d !== r && d !== a && V(l, m, u, g, o, h, d.x, d.y) && M(d.prev, d, d.next) >= 0)
      return !1;
    d = d.prevZ;
  }
  for (; v && v.z <= y; ) {
    if (v.x >= x && v.x <= c && v.y >= f && v.y <= p && v !== r && v !== a && V(l, m, u, g, o, h, v.x, v.y) && M(v.prev, v, v.next) >= 0)
      return !1;
    v = v.nextZ;
  }
  return !0;
}
function ct(t, n, e) {
  var i = t;
  do {
    var r = i.prev, s = i.next.next;
    !Z(r, s) && ge(r, i, i.next, s) && O(r, s) && O(s, r) && (n.push(r.i / e | 0), n.push(i.i / e | 0), n.push(s.i / e | 0), E(i), E(i.next), i = t = s), i = i.next;
  } while (i !== t);
  return F(i);
}
function ft(t, n, e, i, r, s) {
  var a = t;
  do {
    for (var l = a.next.next; l !== a.prev; ) {
      if (a.i !== l.i && wt(a, l)) {
        var u = xe(a, l);
        a = F(a, a.next), u = F(u, u.next), I(a, n, e, i, r, s, 0), I(u, n, e, i, r, s, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== t);
}
function mt(t, n, e, i) {
  var r = [], s, a, l, u, o;
  for (s = 0, a = n.length; s < a; s++)
    l = n[s] * i, u = s < a - 1 ? n[s + 1] * i : t.length, o = de(t, l, u, i, !1), o === o.next && (o.steiner = !0), r.push(yt(o));
  for (r.sort(ht), s = 0; s < r.length; s++)
    e = pt(r[s], e);
  return e;
}
function ht(t, n) {
  return t.x - n.x;
}
function pt(t, n) {
  var e = dt(t, n);
  if (!e)
    return n;
  var i = xe(e, t);
  return F(i, i.next), F(e, e.next);
}
function dt(t, n) {
  var e = n, i = t.x, r = t.y, s = -1 / 0, a;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var l = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (l <= i && l > s && (s = l, a = e.x < e.next.x ? e : e.next, l === i))
        return a;
    }
    e = e.next;
  } while (e !== n);
  if (!a)
    return null;
  var u = a, o = a.x, m = a.y, g = 1 / 0, h;
  e = a;
  do
    i >= e.x && e.x >= o && i !== e.x && V(r < m ? i : s, r, o, m, r < m ? s : i, r, e.x, e.y) && (h = Math.abs(r - e.y) / (i - e.x), O(e, t) && (h < g || h === g && (e.x > a.x || e.x === a.x && gt(a, e))) && (a = e, g = h)), e = e.next;
  while (e !== u);
  return a;
}
function gt(t, n) {
  return M(t.prev, t, n.prev) < 0 && M(n.next, t, t.next) < 0;
}
function xt(t, n, e, i) {
  var r = t;
  do
    r.z === 0 && (r.z = W(r.x, r.y, n, e, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== t);
  r.prevZ.nextZ = null, r.prevZ = null, vt(r);
}
function vt(t) {
  var n, e, i, r, s, a, l, u, o = 1;
  do {
    for (e = t, t = null, s = null, a = 0; e; ) {
      for (a++, i = e, l = 0, n = 0; n < o && (l++, i = i.nextZ, !!i); n++)
        ;
      for (u = o; l > 0 || u > 0 && i; )
        l !== 0 && (u === 0 || !i || e.z <= i.z) ? (r = e, e = e.nextZ, l--) : (r = i, i = i.nextZ, u--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
      e = i;
    }
    s.nextZ = null, o *= 2;
  } while (a > 1);
  return t;
}
function W(t, n, e, i, r) {
  return t = (t - e) * r | 0, n = (n - i) * r | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t | n << 1;
}
function yt(t) {
  var n = t, e = t;
  do
    (n.x < e.x || n.x === e.x && n.y < e.y) && (e = n), n = n.next;
  while (n !== t);
  return e;
}
function V(t, n, e, i, r, s, a, l) {
  return (r - a) * (n - l) >= (t - a) * (s - l) && (t - a) * (i - l) >= (e - a) * (n - l) && (e - a) * (s - l) >= (r - a) * (i - l);
}
function wt(t, n) {
  return t.next.i !== n.i && t.prev.i !== n.i && !_t(t, n) && // dones't intersect other edges
  (O(t, n) && O(n, t) && Mt(t, n) && // locally visible
  (M(t.prev, t, n.prev) || M(t, n.prev, n)) || // does not create opposite-facing sectors
  Z(t, n) && M(t.prev, t, t.next) > 0 && M(n.prev, n, n.next) > 0);
}
function M(t, n, e) {
  return (n.y - t.y) * (e.x - n.x) - (n.x - t.x) * (e.y - n.y);
}
function Z(t, n) {
  return t.x === n.x && t.y === n.y;
}
function ge(t, n, e, i) {
  var r = H(M(t, n, e)), s = H(M(t, n, i)), a = H(M(e, i, t)), l = H(M(e, i, n));
  return !!(r !== s && a !== l || r === 0 && z(t, e, n) || s === 0 && z(t, i, n) || a === 0 && z(e, t, i) || l === 0 && z(e, n, i));
}
function z(t, n, e) {
  return n.x <= Math.max(t.x, e.x) && n.x >= Math.min(t.x, e.x) && n.y <= Math.max(t.y, e.y) && n.y >= Math.min(t.y, e.y);
}
function H(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function _t(t, n) {
  var e = t;
  do {
    if (e.i !== t.i && e.next.i !== t.i && e.i !== n.i && e.next.i !== n.i && ge(e, e.next, t, n))
      return !0;
    e = e.next;
  } while (e !== t);
  return !1;
}
function O(t, n) {
  return M(t.prev, t, t.next) < 0 ? M(t, n, t.next) >= 0 && M(t, t.prev, n) >= 0 : M(t, n, t.prev) < 0 || M(t, t.next, n) < 0;
}
function Mt(t, n) {
  var e = t, i = !1, r = (t.x + n.x) / 2, s = (t.y + n.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== t);
  return i;
}
function xe(t, n) {
  var e = new Y(t.i, t.x, t.y), i = new Y(n.i, n.x, n.y), r = t.next, s = n.prev;
  return t.next = n, n.prev = t, e.next = r, r.prev = e, i.next = e, e.prev = i, s.next = i, i.prev = s, i;
}
function ce(t, n, e, i) {
  var r = new Y(t, n, e);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function E(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Y(t, n, e) {
  this.i = t, this.x = n, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
G.deviation = function(t, n, e, i) {
  var r = n && n.length, s = r ? n[0] * e : t.length, a = Math.abs(X(t, 0, s, e));
  if (r)
    for (var l = 0, u = n.length; l < u; l++) {
      var o = n[l] * e, m = l < u - 1 ? n[l + 1] * e : t.length;
      a -= Math.abs(X(t, o, m, e));
    }
  var g = 0;
  for (l = 0; l < i.length; l += 3) {
    var h = i[l] * e, x = i[l + 1] * e, f = i[l + 2] * e;
    g += Math.abs(
      (t[h] - t[f]) * (t[x + 1] - t[h + 1]) - (t[h] - t[x]) * (t[f + 1] - t[h + 1])
    );
  }
  return a === 0 && g === 0 ? 0 : Math.abs((g - a) / a);
};
function X(t, n, e, i) {
  for (var r = 0, s = n, a = e - i; s < e; s += i)
    r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
  return r;
}
G.flatten = function(t) {
  for (var n = t[0][0].length, e = { vertices: [], holes: [], dimensions: n }, i = 0, r = 0; r < t.length; r++) {
    for (var s = 0; s < t[r].length; s++)
      for (var a = 0; a < n; a++)
        e.vertices.push(t[r][s][a]);
    r > 0 && (i += t[r - 1].length, e.holes.push(i));
  }
  return e;
};
var Tt = ee.exports;
const Dt = /* @__PURE__ */ ot(Tt);
new $();
new $();
function At(t, n) {
  var e = t % n, i = Math.floor(t / n);
  return [e, i];
}
function bt(t, n, e) {
  for (var i = 0, r = 0; i < t.length; i += n, r++)
    if (n === 3) {
      var s = e([t[i], t[i + 1], t[i + 2]], r);
      t.set(s, i);
    } else
      t.set(e([t[i], t[i + 1]], r), i);
  return t;
}
function Ut(t, n, e, i) {
  var r = e.x - i.x, s = t.x - n.x, a = e.y - i.y, l = t.y - n.y, u = s * a - l * r;
  if (u == 0)
    throw new Error("Number of intersection points is zero or infinity.");
  var o = t.x * n.y - t.y * n.x, m = e.x * i.y - e.y * i.x, g = (o * r - s * m) / u, h = (o * a - l * m) / u, x = { x: g, y: h };
  return x;
}
function St(t) {
  for (var n = 0, e = 0, i = t.length; e < i; e++) {
    var r = t[e].x, s = t[e == t.length - 1 ? 0 : e + 1].y, a = t[e == t.length - 1 ? 0 : e + 1].x, l = t[e].y;
    n += r * s * 0.5, n -= a * l * 0.5;
  }
  return Math.abs(n);
}
function Pt([t, n, e]) {
  return Math.abs(
    (t.x * (n.y - e.y) + n.x * (e.y - t.y) + e.x * (t.y - n.y)) / 2
  );
}
function Ft(t, n = 8) {
  const e = t.slice();
  let i = 0;
  for (; e.length > n && i < 1e3; ) {
    i++;
    let r = 1 / 0, s = null;
    for (let a = 0; a <= e.length - 1; a++) {
      const l = e.length, u = [a, (a + 1) % l, (a + 2) % l, (a + 3) % l], o = e[u[0]], m = e[u[1]], g = e[u[2]], h = e[u[3]];
      try {
        const x = Ut(o, m, g, h), f = Pt([x, m, g]);
        f < r && (r = f, s = {
          point: x,
          area: f,
          indicesToRemove: [u[1], u[2]]
        });
      } catch (x) {
        console.log(x);
      }
    }
    if (s) {
      const a = s.indicesToRemove[0], l = s.indicesToRemove[1];
      l > a ? (e.splice(l, 1), e.splice(a, 1)) : (e.splice(a, 1), e.splice(l, 1)), e.splice(Math.min(a, l), 0, s.point);
    }
  }
  return e;
}
var J;
((t) => {
  function n(r) {
    let s = r.slice();
    return s.sort(t.POINT_COMPARATOR), t.makeHullPresorted(s);
  }
  t.makeHull = n;
  function e(r) {
    if (r.length <= 1)
      return r.slice();
    let s = [];
    for (let l = 0; l < r.length; l++) {
      const u = r[l];
      for (; s.length >= 2; ) {
        const o = s[s.length - 1], m = s[s.length - 2];
        if ((o.x - m.x) * (u.y - m.y) >= (o.y - m.y) * (u.x - m.x))
          s.pop();
        else
          break;
      }
      s.push(u);
    }
    s.pop();
    let a = [];
    for (let l = r.length - 1; l >= 0; l--) {
      const u = r[l];
      for (; a.length >= 2; ) {
        const o = a[a.length - 1], m = a[a.length - 2];
        if ((o.x - m.x) * (u.y - m.y) >= (o.y - m.y) * (u.x - m.x))
          a.pop();
        else
          break;
      }
      a.push(u);
    }
    return a.pop(), s.length == 1 && a.length == 1 && s[0].x == a[0].x && s[0].y == a[0].y ? s : s.concat(a);
  }
  t.makeHullPresorted = e;
  function i(r, s) {
    return r.x < s.x ? -1 : r.x > s.x ? 1 : r.y < s.y ? -1 : r.y > s.y ? 1 : 0;
  }
  t.POINT_COMPARATOR = i;
})(J || (J = {}));
function Rt(t, n) {
  const e = new Float32Array(t);
  for (let i = 0; i < t; i++)
    e[i * 3] = n[0], e[i * 3 + 1] = n[1], e[i * 3 + 2] = n[2];
  return e;
}
function Vt(t, n, e = () => Math.random()) {
  const i = n + 1, r = new Float32Array(t.length / n * i);
  for (let s = 0; s < t.length; s += n) {
    let a = s / n * i;
    r[a] = t[s], r[a + 1] = t[s + 1], n === 2 && (r[a + 2] = e(a)), n === 3 && (r[a + 2] = t[s + 2], r[a + 3] = e(a));
  }
  return r;
}
function Ct(t) {
  const n = new Float32Array(t.length * 2);
  for (let e = 0; e < t.length; e++)
    n[e * 2] = t[e].x, n[e * 2 + 1] = t[e].y;
  return n;
}
function It(t, n, e) {
  const i = [], r = t % (n * 4) / 4, s = Math.floor(t / (n * 4)), a = s - 1, l = s + 1, u = r - 1, o = r + 1;
  return a >= 0 ? i.push(a * n + r) : i.push(null), l < e ? i.push(l * n + r) : i.push(null), u >= 0 ? i.push(s * n + u) : i.push(null), o < n ? i.push(s * n + o) : i.push(null), i;
}
const Ot = (t) => (...n) => n[3] / 255 > 0, Et = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [0, 0],
  scale: 1,
  filter: Ot
};
class $t {
  constructor(n, e, i) {
    _(this, "points", []);
    _(this, "data", {
      areaReduction: 0
    });
    _(this, "debug", !0);
    _(this, "index");
    _(this, "positions");
    _(this, "uv");
    _(this, "defaultSettings", Et);
    _(this, "settings");
    this.vertices = i, this.settings = { ...this.defaultSettings, ...e };
    const { slices: r } = this.settings, s = zt("bvc-image", n.width, n.height);
    this.points = this.getPoints(n, s);
    let a = J.makeHull(this.points);
    const l = Ft(a, i), u = l.map((h) => {
      let x = Ht(h, [n.width, n.height], r);
      return x.y = -1 * x.y, x;
    }), { scale: o } = this.settings;
    this.data.areaReduction = 1 - St(l) / (n.width / r[0] * (n.height / r[1])) * o;
    const m = Ct(u), g = Dt(m, null, 2);
    this.positions = Vt(m, 2, () => 0), this.index = Uint32Array.from(g), this.uv = bt(m.slice(0), 2, (h) => {
      let x = h[0] + 0.5;
      x = x / this.settings.slices[0] + 1 / this.settings.slices[0] * this.settings.indices[0];
      let f = h[1] + 0.5;
      return f = f / this.settings.slices[1] + 1 - 1 / this.settings.slices[1] * (this.settings.indices[1] + 1), [x, f];
    });
  }
  getImageData(n, e) {
    const i = e.getContext("2d");
    i.drawImage(n, 0, 0);
    const [r, s] = this.settings.indices, [a, l] = this.settings.slices, u = e.width / a, o = e.height / l;
    return i.getImageData(u * r, o * s, u, o);
  }
  /**
   * Iterates over the image and returns an array of points that are over the alpha threshold.
   * It reduces the number of returned points by excluding points that are surrounded by solid pixels.
   *
   * @param img An image element with the image already loaded
   * @param canvas A canvas element to draw the image on in order to get the color values
   * @returns
   */
  getPoints(n, e) {
    const i = this.getImageData(n, e), r = i.data, s = [], a = this.settings.filter(this.settings.threshold), l = (u) => u !== null && a(
      r[u * 4],
      r[u * 4 + 1],
      r[u * 4 + 2],
      r[u * 4 + 3]
    );
    for (let u = 0; u < r.length; u += 4)
      if (a(
        r[u + 0],
        r[u + 1],
        r[u + 2],
        r[u + 3]
      )) {
        if (It(u, e.width, e.height).every(l))
          continue;
        const [g, h] = At(u / 4, i.width);
        s.push({ x: g, y: h });
      }
    return s;
  }
}
const zt = (t = "debug-canvas", n, e) => {
  const i = document.querySelector(`#${t}`) || document.createElement("canvas");
  return i.id = t, i.width = n, i.height = e, i.id = t, i;
}, Ht = (t, n, e) => ({
  x: (t.x - n[0] / (2 * e[0])) / (n[0] / e[0]),
  y: (t.y - n[1] / (2 * e[1])) / (n[1] / e[1])
}), Lt = {
  threshold: 0.01,
  slices: [1, 1],
  indices: [1, 1]
};
class kt extends me {
  constructor(e, i = 8, r = 0.01, s = [1, 1], a = [0, 0]) {
    super();
    _(this, "image");
    _(this, "vertices", 8);
    _(this, "settings", Lt);
    this.vertices = i, this.settings = {
      ...this.settings,
      threshold: r,
      slices: s,
      indices: a
    }, this.image = "image" in e ? e.image : e, this.build();
  }
  build() {
    const e = new $t(
      this.image,
      this.settings,
      this.vertices
    ), i = e.positions.length, r = new R(e.index, 1), s = new R(e.positions, 3), a = new R(Rt(i, [0, 0, 1]), 3), l = new R(e.uv, 2);
    this.userData.reduction = e.data.areaReduction, this.setIndex(r), this.setAttribute("position", s), this.setAttribute("normal", a), this.setAttribute("uv", l);
  }
}
const jt = () => new Nt();
class Nt {
  constructor() {
    _(this, "animations");
    this.animations = [];
  }
  add(n, e, i) {
    const r = {
      name: "",
      imageUrl: n
    };
    return Array.isArray(i) ? r.multiAnimations = i : r.name = i, e.type == "rowColumn" && (r.auto = {
      type: "rowColumn",
      width: e.width,
      height: e.height
    }), e.type == "frameSize" && (r.auto = {
      type: "frameSize",
      width: e.width,
      height: e.height
    }), this.animations.push(r), this;
  }
  async build(n = {}) {
    const e = new Oe(), i = {
      frames: [],
      animations: {},
      sheetSize: [0, 0],
      animationLengths: []
    };
    let r = new Ee();
    const s = [];
    let a = 0, l = 0;
    for (const c of this.animations) {
      const p = await e.loadAsync(c.imageUrl), w = p.width, y = p.height;
      a = Math.max(a, w), l += y, s.push({
        img: p,
        w,
        h: y
      });
    }
    const u = document.createElement("canvas");
    u.width = a, u.height = l;
    const o = u.getContext("2d");
    let m = 0;
    for (const { img: c, h: p } of s)
      o == null || o.drawImage(c, 0, m, c.width, c.height), m += p;
    r = new ne(u), r.needsUpdate = !0;
    let g = 0, h = 0, x = 0, f = 64;
    for (const c of this.animations) {
      const p = s[g];
      let w = 0;
      if (c.auto) {
        let y = 0, d = 0;
        c.auto.type == "frameSize" && (d = p.w / c.auto.width, y = p.h / c.auto.height), c.auto.type == "rowColumn" && (d = c.auto.width, y = c.auto.height);
        const v = p.w / d, D = p.h / y;
        w = y * d, c.multiAnimations || (i.animations[c.name] = []);
        const S = /* @__PURE__ */ new Map();
        for (let A = 0; A < y; A++) {
          x += D;
          for (let b = 0; b < d; b++) {
            if (i.frames.push([
              p.w / d * b / a,
              1 - x / l,
              v / a,
              D / l
            ]), c.multiAnimations) {
              const ve = A * d + b;
              S.set(ve, h);
            } else
              i.animations[c.name].push([h, 1]);
            h++;
          }
        }
        if (c.multiAnimations)
          for (const A of c.multiAnimations) {
            i.animations[A.name] = [], i.animationLengths.push(
              A.frameRange[1] - A.frameRange[0] + 1
            );
            for (let b = A.frameRange[0]; b <= A.frameRange[1]; b++)
              i.animations[A.name].push([S.get(b), 1]);
          }
        else
          i.animationLengths.push(w);
      }
      g++;
    }
    if (r.matrixAutoUpdate = !1, r.generateMipmaps = !1, r.premultiplyAlpha = !1, r.wrapS = r.wrapT = q, r.magFilter = r.minFilter = U, r.colorSpace = ie, i.sheetSize = [a, l], n.makeSlimGeometry) {
      const c = document.createElement("canvas");
      c.width = f, c.height = f;
      const p = c.getContext("2d"), w = a / f, y = l / f;
      for (let D = 0; D < w; D++)
        for (let S = 0; S < y; S++) {
          const A = D * f, b = S * f;
          p == null || p.drawImage(u, A, b, f, f, 0, 0, f, f);
        }
      const d = new ne(c);
      d.magFilter = r.minFilter = U, d.colorSpace = ie;
      const v = new kt(
        d,
        // an already loaded HTMLImageElement or a ThreeJS texture
        n.slimOptions ? n.slimOptions.vertices : 8,
        n.slimOptions ? n.slimOptions.alphaThreshold : 0
        // alphaThreshold, 0 means only fully transparent pixels will be discarded
      );
      return { spritesheet: i, texture: r, geometry: v };
    }
    return { spritesheet: i, texture: r };
  }
}
export {
  Kt as InstancedSpriteMesh,
  K as PLAY_MODE,
  jt as createSpritesheet,
  Qe as makeDataTexture,
  Bt as parseAseprite
};
