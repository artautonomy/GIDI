{
  "version": 3,
  "sources": ["../../@threlte/core/dist/context/fragments/cache.js", "../../@threlte/core/dist/utilities/observe.svelte.js", "../../@threlte/core/dist/utilities/isInstanceOf.js", "../../@threlte/core/dist/utilities/asyncWritable.js", "../../@threlte/core/dist/utilities/browser.js", "../../@threlte/core/dist/utilities/revision.js", "../../@threlte/core/dist/utilities/watch.js", "../../@threlte/core/dist/utilities/currentWritable.js", "../../@threlte/core/dist/utilities/resolvePropertyPath.js", "../../@threlte/core/dist/context/fragments/canvas.js", "../../@threlte/core/dist/frame-scheduling/DAG.js", "../../@threlte/core/dist/frame-scheduling/Task.js", "../../@threlte/core/dist/frame-scheduling/Stage.js", "../../@threlte/core/dist/frame-scheduling/Scheduler.js", "../../@threlte/core/dist/context/fragments/scheduler.svelte.js", "../../@threlte/core/dist/context/fragments/camera.js", "../../@threlte/core/dist/context/fragments/disposal.js", "../../@threlte/core/dist/context/fragments/parent.js", "../../@threlte/core/dist/context/fragments/parentObject3D.js", "../../@threlte/core/dist/hooks/useTask.js", "../../@threlte/core/dist/context/fragments/scene.js", "../../@threlte/core/dist/context/fragments/renderer.svelte.js", "../../@threlte/core/dist/context/fragments/user.js", "../../@threlte/core/dist/context/createThrelteContext.svelte.js", "../../@threlte/core/dist/components/Context/Context.svelte", "../../@threlte/core/dist/Canvas.svelte", "../../@threlte/core/dist/context/compounds/useThrelte.js", "../../@threlte/core/dist/components/T/utils/useAttach.js", "../../@threlte/core/dist/components/T/utils/useCamera.js", "../../@threlte/core/dist/components/T/utils/useCreateEvent.js", "../../@threlte/core/dist/components/T/utils/useDispose.js", "../../@threlte/core/dist/components/T/utils/useEvents.js", "../../@threlte/core/dist/components/T/utils/useIs.js", "../../@threlte/core/dist/components/T/utils/usePlugins.js", "../../@threlte/core/dist/components/T/utils/useProps.js", "../../@threlte/core/dist/components/T/utils/utils.js", "../../@threlte/core/dist/components/T/T.svelte", "../../@threlte/core/dist/components/T/T.js", "../../@threlte/core/dist/plugins/injectPlugin.js", "../../@threlte/core/dist/hooks/useStage.js", "../../@threlte/core/dist/hooks/useThrelteUserContext.js", "../../@threlte/core/dist/hooks/useLoader.js", "../../@threlte/core/dist/index.js"],
  "sourcesContent": ["import { getContext, setContext } from 'svelte';\r\nexport const shallowEqualArrays = (arrA, arrB) => {\r\n    if (arrA === arrB)\r\n        return true;\r\n    if (!arrA || !arrB)\r\n        return false;\r\n    const len = arrA.length;\r\n    if (arrB.length !== len)\r\n        return false;\r\n    for (let i = 0; i < len; i++)\r\n        if (arrA[i] !== arrB[i])\r\n            return false;\r\n    return true;\r\n};\r\n/**\r\n * ### `createCacheContext`\r\n *\r\n * Every Threlte application has its own cache. This prevents models from being\r\n * shared between applications because e.g. THREE.Mesh objects cannot be mounted\r\n * in multiple scenes.\r\n */\r\nexport const createCacheContext = () => {\r\n    const items = [];\r\n    const remember = (callback, keys) => {\r\n        for (let i = 0; i < items.length; i++) {\r\n            const entry = items[i];\r\n            if (shallowEqualArrays(keys, entry.keys)) {\r\n                if (entry.promise)\r\n                    return entry.promise;\r\n            }\r\n        }\r\n        // If no match was found, create a new entry\r\n        const entry = {\r\n            promise: callback(),\r\n            keys\r\n        };\r\n        // Add the entry to the cache\r\n        items.push(entry);\r\n        // Return the promise\r\n        return entry.promise;\r\n    };\r\n    const clear = (keys) => {\r\n        for (let i = 0; i < items.length; i++) {\r\n            const entry = items[i];\r\n            if (shallowEqualArrays(keys, entry.keys)) {\r\n                items.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    const context = { items, remember, clear };\r\n    setContext('threlte-cache', context);\r\n    return context;\r\n};\r\n/**\r\n * ### `useCache`\r\n *\r\n * This hook is used to access the cache. It returns a `remember` function that\r\n * can be used to cache a promise based on the provided keys. The `remember`\r\n * function will return the cached value if the promise has already been\r\n * resolved and the keys match.\r\n *\r\n * @example\r\n * ```ts\r\n * const { remember } = useCache()\r\n *\r\n * const asnycWritable = remember(async () => {\r\n *  const loader = new GLTFLoader()\r\n *  const { scene } = await loader.loadAsync('/path/to/model.glb')\r\n *  return scene\r\n * })\r\n * ```\r\n *\r\n * The model will only be loaded once, even if `remember` is invoked multiple\r\n * times with the same keys.\r\n *\r\n * The `clear` function can be used to clear the cache for a specific set of keys.\r\n */\r\nexport const useCache = () => {\r\n    const cache = getContext('threlte-cache');\r\n    if (!cache) {\r\n        throw new Error('No cache found. The cache can only be used in a child component to <Canvas>.');\r\n    }\r\n    return cache;\r\n};\r\n", "import { untrack } from 'svelte';\r\nimport { fromStore } from 'svelte/store';\r\nconst signal = Symbol();\r\nconst isStore = (dep) => {\r\n    return typeof dep?.subscribe === 'function';\r\n};\r\nconst runObserve = (dependencies, callback, pre) => {\r\n    const stores = dependencies().map((d) => {\r\n        if (isStore(d)) {\r\n            return fromStore(d);\r\n        }\r\n        return signal;\r\n    });\r\n    const deps = $derived(dependencies().map((d, i) => {\r\n        if (stores[i] === signal)\r\n            return d;\r\n        return stores[i].current;\r\n    }));\r\n    const effect = () => {\r\n        deps;\r\n        let cleanup = undefined;\r\n        untrack(() => {\r\n            cleanup = callback(deps);\r\n        });\r\n        return cleanup;\r\n    };\r\n    if (pre) {\r\n        $effect.pre(effect);\r\n    }\r\n    else {\r\n        $effect(effect);\r\n    }\r\n};\r\n/**\r\n * ### `observe`\r\n *\r\n * Observe multiple stores and reactive values and call a callback when they\r\n * change to trigger side effects. The callback can return a cleanup function\r\n * that will be called when the dependencies change again or when the effect\r\n * root (most likely a component) is destroyed. Under the hood, `observe` uses\r\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\r\n * version that uses `$effect.pre`, use `observe.pre`.\r\n *\r\n * ```ts\r\n * const count = writable(0)\r\n * let name = $state('John')\r\n *\r\n * observe(() => [count, name], ([count, name]) => {\r\n *  console.log(count, name) // 0 John\r\n * })\r\n * ```\r\n *\r\n * The callback can return a cleanup function that will be called when the\r\n * dependencies change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const count = writable(0)\r\n *\r\n * observe(() => [count], ([count]) => {\r\n *  console.log(count) // 0\r\n *  return () => {\r\n *    console.log('cleanup')\r\n *  }\r\n * })\r\n * ```\r\n *\r\n * @param dependencies - A function that returns an array of dependencies.\r\n * @param callback - A function that will be called with the current values of\r\n * the dependencies. The callback can return a cleanup function that will be\r\n * called when the dependencies change again or when the component is destroyed.\r\n */\r\nconst observePost = (dependencies, callback) => {\r\n    return runObserve(dependencies, callback, false);\r\n};\r\n/**\r\n * ### `observe.pre`\r\n *\r\n * Observe multiple stores and reactive values and call a callback when they\r\n * change to trigger side effects. The callback can return a cleanup function\r\n * that will be called when the dependencies change again or when the effect\r\n * root (most likely a component) is destroyed. Under the hood, `observe.pre` uses\r\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\r\n * version that uses `$effect`, use `observe`.\r\n *\r\n * ```ts\r\n * const count = writable(0)\r\n * let name = $state('John')\r\n *\r\n * observe.pre(() => [count, name], ([count, name]) => {\r\n *  console.log(count, name) // 0 John\r\n * })\r\n * ```\r\n *\r\n * The callback can return a cleanup function that will be called when the\r\n * dependencies change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const count = writable(0)\r\n *\r\n * observe.pre(() => [count], ([count]) => {\r\n *  console.log(count) // 0\r\n *  return () => {\r\n *    console.log('cleanup')\r\n *  }\r\n * })\r\n * ```\r\n *\r\n * @param dependencies - A function that returns an array of dependencies.\r\n * @param callback - A function that will be called with the current values of\r\n * the dependencies. The callback can return a cleanup function that will be\r\n * called when the dependencies change again or when the component is destroyed.\r\n */\r\nconst observePre = (dependencies, callback) => {\r\n    return runObserve(dependencies, callback, true);\r\n};\r\nexport const observe = Object.assign(observePost, { pre: observePre });\r\n", "/**\r\n * Check if an object is an instance of a given THREE class. Can be used as a\r\n * type guard and as an alternative to `instanceof` which is prone to error and\r\n * slower. It uses the `isFoo` property that THREE classes have to determine if\r\n * an object is of a particular class.\r\n *\r\n * @example\r\n * ```ts\r\n * const obj = new THREE.Object3D()\r\n * isInstanceOf(obj, 'Object3D') // true\r\n * ```\r\n *\r\n * @param obj - The object to check.\r\n * @param type - The class name to check against.\r\n * @returns `true` if the object is an instance of the class, `false` otherwise.\r\n */\r\nexport const isInstanceOf = (obj, type) => {\r\n    return obj?.[`is${type}`] === true;\r\n};\r\n", "import { writable } from 'svelte/store';\r\n/**\r\n * ### `asyncWritable`\r\n *\r\n * Creates a writable store that is initialized with a promise. The store also\r\n * implements the `then` and `catch` methods of the promise so that it can be\r\n * used in `await` expressions and `{#await}` blocks of Svelte.\r\n *\r\n * ```svelte\r\n * <script>\r\n *  import { asyncWritable } from '@threlte/core'\r\n *\r\n *  const asyncOp = async () => {\r\n *    // Do something async\r\n *  }\r\n *\r\n *  const store = asyncWritable(asyncOp())\r\n *  $: console.log($store) // asyncOp result\r\n * </script>\r\n *\r\n * <h1>\r\n *  {#await store then data}\r\n *    // Do something with the data\r\n *  {/await}\r\n * </h1>\r\n * ```\r\n *\r\n * If an error occurs in the promise, the error will be logged to the console\r\n * and the error can be accessed via the `error` property of the store with in\r\n * turn is a store.\r\n *\r\n * ```svelte\r\n * <script>\r\n *  import { asyncWritable } from '@threlte/core'\r\n *\r\n *  const asyncOp = async () => {\r\n *    throw new Error('Something went wrong')\r\n *  }\r\n *\r\n *  const store = asyncWritable(asyncOp())\r\n *  const error = store.error\r\n *\r\n *  $: console.log($store) // undefined\r\n *  $: console.log($error) // Error: Something went wrong\r\n * </script>\r\n * ```\r\n */\r\nexport const asyncWritable = (promise) => {\r\n    const store = writable(undefined);\r\n    const error = writable(undefined);\r\n    promise\r\n        .then((result) => {\r\n        store.set(result);\r\n    })\r\n        .catch((e) => {\r\n        console.error('Error in asyncWritable:', e.message);\r\n        error.set(e);\r\n    });\r\n    return Object.assign(Object.assign(promise, store), { error, promise });\r\n};\r\n", "export const browser = typeof window !== 'undefined';\r\n", "import { REVISION } from 'three';\r\n// REVISION can be '{number}' or '{number}dev'\r\nconst normalizedRevision = REVISION.replace('dev', '');\r\n/**\r\n * The current Three.js revision.\r\n */\r\nexport const revision = Number.parseInt(normalizedRevision);\r\n", "import { onDestroy } from 'svelte';\r\nimport { derived } from 'svelte/store';\r\n/**\r\n * ### `watch`\r\n *\r\n * Watch a single store or multiple stores and call a callback when they change to trigger side effects.\r\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const store = writable(0)\r\n *\r\n * watch(store, (value) => {\r\n * \tconsole.log(value) // 0\r\n * })\r\n * ```\r\n *\r\n * You can also watch multiple stores:\r\n *\r\n * ```ts\r\n * const store1 = writable(0)\r\n * const store2 = writable(1)\r\n *\r\n * watch([store1, store2], ([value1, value2]) => {\r\n * \tconsole.log(value1, value2) // 0 1\r\n * })\r\n * ```\r\n *\r\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const store = writable(0)\r\n *\r\n * watch(store, (value) => {\r\n * \tconsole.log(value) // 0\r\n * \treturn () => {\r\n * \t\tconsole.log('cleanup')\r\n * \t}\r\n * })\r\n * ```\r\n *\r\n * @param stores\r\n * @param callback\r\n */\r\nexport const watch = (stores, callback) => {\r\n    const d = derived(stores, (values) => {\r\n        return values;\r\n    });\r\n    let cleanupFn;\r\n    const unsubscribe = d.subscribe(async (values) => {\r\n        if (cleanupFn)\r\n            cleanupFn();\r\n        const fn = await callback(values);\r\n        if (fn)\r\n            cleanupFn = fn;\r\n    });\r\n    onDestroy(() => {\r\n        unsubscribe();\r\n        if (cleanupFn)\r\n            cleanupFn();\r\n    });\r\n};\r\n", "import { writable } from 'svelte/store';\r\n/**\r\n * ### `currentWritable`\r\n *\r\n * A writable store that also has a `current` property that is updated synchronously.\r\n * For use in non-reactive contexts e.g. loops where unwrapping a store every frame is expensive.\r\n *\r\n * ```ts\r\n * const store = currentWritable(0)\r\n *\r\n * useTask(() => {\r\n * \tconsole.log(store.current) // 0\r\n * })\r\n *\r\n * @param value\r\n * @returns\r\n */\r\nexport const currentWritable = (value) => {\r\n    const store = writable(value);\r\n    const extendedWritable = {\r\n        set: (value) => {\r\n            extendedWritable.current = value;\r\n            store.set(value);\r\n        },\r\n        subscribe: store.subscribe,\r\n        update: (fn) => {\r\n            const newValue = fn(extendedWritable.current);\r\n            extendedWritable.current = newValue;\r\n            store.set(newValue);\r\n        },\r\n        current: value\r\n    };\r\n    return extendedWritable;\r\n};\r\nexport const toCurrentReadable = (store) => {\r\n    return {\r\n        subscribe: store.subscribe,\r\n        get current() {\r\n            return store.current;\r\n        }\r\n    };\r\n};\r\n", "/**\r\n * ### `resolvePropertyPath`\r\n *\r\n * This function resolves a property path to a target object and the property\r\n * key. The property path can include dots to indicate nested objects.\r\n *\r\n *  ```ts\r\n * const object = { position: { x: 0 } }\r\n * const { target, key } = resolvePropertyPath(object, 'position.x')\r\n *\r\n * // target is { x: 0 }\r\n * // key is 'x'\r\n * ```\r\n */\r\nexport const resolvePropertyPath = (target, propertyPath) => {\r\n    if (propertyPath.includes('.')) {\r\n        const path = propertyPath.split('.');\r\n        const key = path.pop();\r\n        for (let i = 0; i < path.length; i += 1) {\r\n            target = target[path[i]];\r\n        }\r\n        return {\r\n            target,\r\n            key\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            target,\r\n            key: propertyPath\r\n        };\r\n    }\r\n};\r\n", "import { getContext, onMount, setContext } from 'svelte';\r\nimport { currentWritable, toCurrentReadable } from '../../utilities';\r\nexport const createCanvasContext = (options) => {\r\n    const wrapperRect = options.wrapper.getBoundingClientRect();\r\n    let lastWidth = wrapperRect.width;\r\n    let lastHeight = wrapperRect.height;\r\n    const size = currentWritable({ width: wrapperRect.width, height: wrapperRect.height });\r\n    onMount(() => {\r\n        const resizeObserver = new ResizeObserver((entries) => {\r\n            for (const entry of entries) {\r\n                const { width, height } = entry.contentRect;\r\n                if (width === lastWidth && height === lastHeight)\r\n                    return;\r\n                lastWidth = width;\r\n                lastHeight = height;\r\n                size.set({ width, height });\r\n            }\r\n        });\r\n        resizeObserver.observe(options.wrapper);\r\n        return () => {\r\n            resizeObserver.disconnect();\r\n        };\r\n    });\r\n    const context = {\r\n        wrapper: options.wrapper,\r\n        canvas: options.canvas,\r\n        size: toCurrentReadable(size)\r\n    };\r\n    setContext('threlte-canvas-context', context);\r\n    return context;\r\n};\r\nexport const useCanvas = () => {\r\n    const context = getContext('threlte-canvas-context');\r\n    if (!context) {\r\n        throw new Error('useCanvas can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import mitt from 'mitt';\r\nexport class DAG {\r\n    allVertices = {};\r\n    /** Nodes that are fully unlinked */\r\n    isolatedVertices = {};\r\n    connectedVertices = {};\r\n    sortedConnectedValues = [];\r\n    needsSort = false;\r\n    emitter = mitt();\r\n    emit = this.emitter.emit.bind(this.emitter);\r\n    on = this.emitter.on.bind(this.emitter);\r\n    off = this.emitter.off.bind(this.emitter);\r\n    get sortedVertices() {\r\n        return this.mapNodes((value) => value);\r\n    }\r\n    moveToIsolated(key) {\r\n        const vertex = this.connectedVertices[key];\r\n        if (!vertex)\r\n            return;\r\n        this.isolatedVertices[key] = vertex;\r\n        delete this.connectedVertices[key];\r\n    }\r\n    moveToConnected(key) {\r\n        const vertex = this.isolatedVertices[key];\r\n        if (!vertex)\r\n            return;\r\n        this.connectedVertices[key] = vertex;\r\n        delete this.isolatedVertices[key];\r\n    }\r\n    getKey = (v) => {\r\n        if (typeof v === 'object') {\r\n            return v.key;\r\n        }\r\n        return v;\r\n    };\r\n    add(key, value, options) {\r\n        if (this.allVertices[key] && this.allVertices[key].value !== undefined) {\r\n            throw new Error(`A node with the key ${key.toString()} already exists`);\r\n        }\r\n        let vertex = this.allVertices[key];\r\n        if (!vertex) {\r\n            vertex = {\r\n                value: value,\r\n                previous: new Set(),\r\n                next: new Set()\r\n            };\r\n            // add the vertex to the list of all vertices\r\n            this.allVertices[key] = vertex;\r\n        }\r\n        else if (vertex.value === undefined) {\r\n            vertex.value = value;\r\n        }\r\n        // if another node referenced this node before, we have inverse links\r\n        const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\r\n        if (!options?.after && !options?.before && !hasEdges) {\r\n            // the node we're about to add is fully unlinked\r\n            this.isolatedVertices[key] = vertex;\r\n            this.emit('node:added', {\r\n                key,\r\n                type: 'isolated',\r\n                value\r\n            });\r\n            return;\r\n        }\r\n        else {\r\n            this.connectedVertices[key] = vertex;\r\n        }\r\n        if (options?.after) {\r\n            const afterArr = Array.isArray(options.after) ? options.after : [options.after];\r\n            // we need to update the vertex to include the new \"after\" nodes\r\n            afterArr.forEach((after) => {\r\n                vertex.previous.add(this.getKey(after));\r\n            });\r\n            afterArr.forEach((after) => {\r\n                const afterKey = this.getKey(after);\r\n                // we get the vertex from the list of all vertices\r\n                const linkedAfter = this.allVertices[afterKey];\r\n                if (!linkedAfter) {\r\n                    // if it doesn't exist, we create it\r\n                    this.allVertices[afterKey] = {\r\n                        value: undefined,\r\n                        previous: new Set(),\r\n                        next: new Set([key])\r\n                    };\r\n                    this.connectedVertices[afterKey] = this.allVertices[afterKey];\r\n                }\r\n                else {\r\n                    // if it does exist, we update it\r\n                    linkedAfter.next.add(key);\r\n                    // we might need to move the vertex from isolated to connected\r\n                    this.moveToConnected(afterKey);\r\n                }\r\n            });\r\n        }\r\n        if (options?.before) {\r\n            const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\r\n            // we need to update the vertex to include the new \"before\" nodes\r\n            beforeArr.forEach((before) => {\r\n                vertex.next.add(this.getKey(before));\r\n            });\r\n            beforeArr.forEach((before) => {\r\n                const beforeKey = this.getKey(before);\r\n                // we get the vertex from the list of all vertices\r\n                const linkedBefore = this.allVertices[beforeKey];\r\n                if (!linkedBefore) {\r\n                    // if it doesn't exist, we create it\r\n                    this.allVertices[beforeKey] = {\r\n                        value: undefined,\r\n                        previous: new Set([key]),\r\n                        next: new Set()\r\n                    };\r\n                    this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\r\n                }\r\n                else {\r\n                    // if it does exist, we update it\r\n                    linkedBefore.previous.add(key);\r\n                    // we might need to move the vertex from isolated to connected\r\n                    this.moveToConnected(beforeKey);\r\n                }\r\n            });\r\n        }\r\n        this.emit('node:added', {\r\n            key,\r\n            type: 'connected',\r\n            value\r\n        });\r\n        // Mark the graph as needing a re-sort\r\n        this.needsSort = true;\r\n    }\r\n    remove(key) {\r\n        const removeKey = this.getKey(key);\r\n        // check if it's an unlinked vertex\r\n        const unlinkedVertex = this.isolatedVertices[removeKey];\r\n        if (unlinkedVertex) {\r\n            delete this.isolatedVertices[removeKey];\r\n            delete this.allVertices[removeKey];\r\n            this.emit('node:removed', {\r\n                key: removeKey,\r\n                type: 'isolated'\r\n            });\r\n            return;\r\n        }\r\n        // if it's not, it's a bit more complicated\r\n        const linkedVertex = this.connectedVertices[removeKey];\r\n        if (!linkedVertex) {\r\n            // The node does not exist in the graph.\r\n            return;\r\n        }\r\n        // Update the 'next' nodes that this node points to\r\n        linkedVertex.next.forEach((nextKey) => {\r\n            const nextVertex = this.connectedVertices[nextKey];\r\n            if (nextVertex) {\r\n                nextVertex.previous.delete(removeKey);\r\n                if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\r\n                    this.moveToIsolated(nextKey);\r\n                }\r\n            }\r\n        });\r\n        // Update the 'previous' nodes that point to this node\r\n        linkedVertex.previous.forEach((prevKey) => {\r\n            const prevVertex = this.connectedVertices[prevKey];\r\n            if (prevVertex) {\r\n                prevVertex.next.delete(removeKey);\r\n                if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\r\n                    this.moveToIsolated(prevKey);\r\n                }\r\n            }\r\n        });\r\n        // Finally, remove the node from the graph\r\n        delete this.connectedVertices[removeKey];\r\n        delete this.allVertices[removeKey];\r\n        this.emit('node:removed', {\r\n            key: removeKey,\r\n            type: 'connected'\r\n        });\r\n        // Mark the graph as needing a re-sort\r\n        this.needsSort = true;\r\n    }\r\n    mapNodes(callback) {\r\n        if (this.needsSort) {\r\n            this.sort();\r\n        }\r\n        const result = [];\r\n        this.forEachNode((value, index) => {\r\n            result.push(callback(value, index));\r\n        });\r\n        return result;\r\n    }\r\n    forEachNode(callback) {\r\n        if (this.needsSort) {\r\n            this.sort();\r\n        }\r\n        let index = 0;\r\n        for (; index < this.sortedConnectedValues.length; index++) {\r\n            callback(this.sortedConnectedValues[index], index);\r\n        }\r\n        Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\r\n            const vertex = this.isolatedVertices[key];\r\n            if (vertex.value !== undefined)\r\n                callback(vertex.value, index++);\r\n        });\r\n    }\r\n    getValueByKey(key) {\r\n        return this.allVertices[key]?.value;\r\n    }\r\n    getKeyByValue(value) {\r\n        return (Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ??\r\n            Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value));\r\n    }\r\n    sort() {\r\n        const inDegree = new Map();\r\n        const zeroInDegreeQueue = [];\r\n        const result = [];\r\n        // we're only interested in vertices that have a value\r\n        const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\r\n            const vertex = this.connectedVertices[key];\r\n            return vertex.value !== undefined;\r\n        });\r\n        // Initialize inDegree (count of incoming edges) for each vertex\r\n        connectedVertexKeysWithValues.forEach((vertex) => {\r\n            inDegree.set(vertex, 0);\r\n        });\r\n        // Calculate inDegree for each vertex\r\n        connectedVertexKeysWithValues.forEach((vertexKey) => {\r\n            const vertex = this.connectedVertices[vertexKey];\r\n            vertex.next.forEach((next) => {\r\n                // check if \"next\" vertex has a value\r\n                const nextVertex = this.connectedVertices[next];\r\n                if (!nextVertex)\r\n                    return;\r\n                inDegree.set(next, (inDegree.get(next) || 0) + 1);\r\n            });\r\n        });\r\n        // Enqueue vertices with inDegree 0\r\n        inDegree.forEach((degree, value) => {\r\n            if (degree === 0) {\r\n                zeroInDegreeQueue.push(value);\r\n            }\r\n        });\r\n        // Process vertices with inDegree 0 and decrease inDegree of adjacent vertices\r\n        while (zeroInDegreeQueue.length > 0) {\r\n            const vertexKey = zeroInDegreeQueue.shift();\r\n            result.push(vertexKey);\r\n            const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\r\n            if (v) {\r\n                this.connectedVertices[v]?.next.forEach((adjVertex) => {\r\n                    const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\r\n                    inDegree.set(adjVertex, adjVertexInDegree);\r\n                    if (adjVertexInDegree === 0) {\r\n                        zeroInDegreeQueue.push(adjVertex);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // Check for cycles in the graph\r\n        if (result.length !== connectedVertexKeysWithValues.length) {\r\n            throw new Error('The graph contains a cycle, and thus can not be sorted topologically.');\r\n        }\r\n        const filterUndefined = (value) => value !== undefined;\r\n        this.sortedConnectedValues = result\r\n            .map((key) => this.connectedVertices[key].value)\r\n            .filter(filterUndefined);\r\n        this.needsSort = false;\r\n    }\r\n    clear() {\r\n        this.allVertices = {};\r\n        this.isolatedVertices = {};\r\n        this.connectedVertices = {};\r\n        this.sortedConnectedValues = [];\r\n        this.needsSort = false;\r\n    }\r\n    static isKey(value) {\r\n        return typeof value === 'string' || typeof value === 'symbol';\r\n    }\r\n    static isValue(value) {\r\n        return typeof value === 'object' && 'key' in value;\r\n    }\r\n}\r\n", "export class Task {\r\n    key;\r\n    stage;\r\n    callback;\r\n    runTask = true;\r\n    stop() {\r\n        this.runTask = false;\r\n    }\r\n    start() {\r\n        this.runTask = true;\r\n    }\r\n    constructor(stage, key, callback) {\r\n        this.stage = stage;\r\n        this.key = key;\r\n        this.callback = callback;\r\n    }\r\n    run(delta) {\r\n        if (!this.runTask)\r\n            return;\r\n        this.callback(delta);\r\n    }\r\n}\r\n", "import { DAG } from './DAG';\r\nimport { Task } from './Task';\r\n/**\r\n * A Stage is a collection of steps. The steps are run in a topological sort\r\n * order.\r\n */\r\nexport class Stage extends DAG {\r\n    key;\r\n    scheduler;\r\n    runTask = true;\r\n    stop() {\r\n        this.runTask = false;\r\n    }\r\n    start() {\r\n        this.runTask = true;\r\n    }\r\n    get tasks() {\r\n        return this.sortedVertices;\r\n    }\r\n    callback = (_, r) => r();\r\n    constructor(scheduler, key, callback) {\r\n        super();\r\n        this.scheduler = scheduler;\r\n        this.key = key;\r\n        this.start = this.start.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        if (callback)\r\n            this.callback = callback.bind(this);\r\n    }\r\n    createTask(key, callback, options) {\r\n        const task = new Task(this, key, callback);\r\n        this.add(key, task, options);\r\n        return task;\r\n    }\r\n    getTask(key) {\r\n        return this.getValueByKey(key);\r\n    }\r\n    removeTask = this.remove.bind(this);\r\n    run(delta) {\r\n        if (!this.runTask)\r\n            return;\r\n        this.callback(delta, (deltaOverride) => {\r\n            this.forEachNode((task) => {\r\n                task.run(deltaOverride ?? delta);\r\n            });\r\n        });\r\n    }\r\n    runWithTiming(delta) {\r\n        if (!this.runTask)\r\n            return {};\r\n        const taskTimings = {};\r\n        this.callback(delta, (deltaOverride) => {\r\n            this.forEachNode((task) => {\r\n                const start = performance.now();\r\n                task.run(deltaOverride ?? delta);\r\n                const duration = performance.now() - start;\r\n                taskTimings[task.key] = duration;\r\n            });\r\n        });\r\n        return taskTimings;\r\n    }\r\n    getSchedule() {\r\n        return this.mapNodes((l) => l.key.toString());\r\n    }\r\n}\r\n", "import { DAG } from './DAG';\r\nimport { Stage } from './Stage';\r\n/**\r\n * A Scheduler is responsible for running stages. It runs the stages in a\r\n * requestAnimationFrame stage.\r\n */\r\nexport class Scheduler extends DAG {\r\n    lastTime = performance.now();\r\n    clampDeltaTo = 0.1;\r\n    get stages() {\r\n        return this.sortedVertices;\r\n    }\r\n    constructor(options) {\r\n        super();\r\n        if (options?.clampDeltaTo)\r\n            this.clampDeltaTo = options.clampDeltaTo;\r\n        this.run = this.run.bind(this);\r\n    }\r\n    createStage(key, options) {\r\n        const stage = new Stage(this, key, options?.callback);\r\n        this.add(key, stage, {\r\n            after: options?.after,\r\n            before: options?.before\r\n        });\r\n        return stage;\r\n    }\r\n    getStage(key) {\r\n        return this.getValueByKey(key);\r\n    }\r\n    removeStage = this.remove.bind(this);\r\n    /**\r\n     * Runs all the stages in the scheduler.\r\n     *\r\n     * @param time The time in milliseconds since the start of the program.\r\n     */\r\n    run(time) {\r\n        const delta = time - this.lastTime;\r\n        this.forEachNode((stage) => {\r\n            // we pass the delta as seconds, not milliseconds,\r\n            // this is in line with how Three.js, Unity and\r\n            // other game engines do it. On top of that, it\r\n            // needs to be clamped to prevent large delta\r\n            // values from causing large jumps in the game\r\n            // state.\r\n            stage.run(Math.min(delta / 1000, this.clampDeltaTo));\r\n        });\r\n        this.lastTime = time;\r\n    }\r\n    runWithTiming(time) {\r\n        const delta = time - this.lastTime;\r\n        const stageTimings = {};\r\n        const start = performance.now();\r\n        this.forEachNode((stage) => {\r\n            const start = performance.now();\r\n            const taskTimings = stage.runWithTiming(Math.min(delta / 1000, this.clampDeltaTo));\r\n            const duration = performance.now() - start;\r\n            stageTimings[stage.key.toString()] = {\r\n                duration,\r\n                tasks: taskTimings\r\n            };\r\n        });\r\n        return {\r\n            total: performance.now() - start,\r\n            stages: stageTimings\r\n        };\r\n    }\r\n    getSchedule(include = {\r\n        tasks: true\r\n    }) {\r\n        return {\r\n            stages: this.mapNodes((stage) => {\r\n                if (stage === undefined)\r\n                    throw new Error('Stage not found');\r\n                return {\r\n                    key: stage.key.toString(),\r\n                    ...{ tasks: include.tasks ? stage.getSchedule() : undefined }\r\n                };\r\n            })\r\n        };\r\n    }\r\n    dispose() {\r\n        this.clear();\r\n    }\r\n}\r\n", "import { getContext, onDestroy, setContext } from 'svelte';\r\nimport { currentWritable } from '../../utilities';\r\nimport { Scheduler } from '../../frame-scheduling';\r\nexport const createSchedulerContext = (options) => {\r\n    const scheduler = new Scheduler();\r\n    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));\r\n    const context = {\r\n        scheduler,\r\n        frameInvalidated: true,\r\n        autoInvalidations: new Set(),\r\n        shouldAdvance: false,\r\n        advance: () => {\r\n            context.shouldAdvance = true;\r\n        },\r\n        autoRender: currentWritable(options.autoRender ?? true),\r\n        renderMode: currentWritable(options.renderMode ?? 'on-demand'),\r\n        invalidate() {\r\n            context.frameInvalidated = true;\r\n        },\r\n        mainStage,\r\n        shouldRender: () => {\r\n            return (context.renderMode.current === 'always' ||\r\n                (context.renderMode.current === 'on-demand' &&\r\n                    (context.frameInvalidated || context.autoInvalidations.size > 0)) ||\r\n                (context.renderMode.current === 'manual' && context.shouldAdvance));\r\n        },\r\n        renderStage: scheduler.createStage(Symbol('threlte-render-stage'), {\r\n            after: mainStage,\r\n            callback(_, runTasks) {\r\n                if (context.shouldRender())\r\n                    runTasks();\r\n            }\r\n        }),\r\n        resetFrameInvalidation() {\r\n            context.frameInvalidated = false;\r\n            context.shouldAdvance = false;\r\n        }\r\n    };\r\n    $effect(() => {\r\n        context.autoRender.set(options.autoRender ?? true);\r\n    });\r\n    $effect(() => {\r\n        context.renderMode.set(options.renderMode ?? 'on-demand');\r\n    });\r\n    onDestroy(() => {\r\n        context.scheduler.dispose();\r\n    });\r\n    setContext('threlte-scheduler-context', context);\r\n    return context;\r\n};\r\nexport const useScheduler = () => {\r\n    const context = getContext('threlte-scheduler-context');\r\n    if (!context) {\r\n        throw new Error('useScheduler can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import { getContext, setContext } from 'svelte';\r\nimport { PerspectiveCamera } from 'three';\r\nimport { currentWritable, watch } from '../../utilities';\r\nimport { useCanvas } from './canvas';\r\nimport { useScheduler } from './scheduler.svelte';\r\nexport const createCameraContext = () => {\r\n    const { size } = useCanvas();\r\n    const { invalidate } = useScheduler();\r\n    // Create a default camera to use when no camera is defined by the user\r\n    const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1000);\r\n    defaultCamera.position.z = 5;\r\n    defaultCamera.lookAt(0, 0, 0);\r\n    const camera = currentWritable(defaultCamera);\r\n    watch(size, (size) => {\r\n        if (camera.current === defaultCamera) {\r\n            const cam = camera.current;\r\n            cam.aspect = size.width / size.height;\r\n            cam.updateProjectionMatrix();\r\n            invalidate();\r\n        }\r\n    });\r\n    const context = { camera };\r\n    setContext('threlte-camera-context', context);\r\n    return context;\r\n};\r\nexport const useCamera = () => {\r\n    const context = getContext('threlte-camera-context');\r\n    if (!context) {\r\n        throw new Error('useCamera can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import { getContext, onDestroy, setContext, tick } from 'svelte';\r\nexport const createDisposalContext = () => {\r\n    const context = {\r\n        removeObjectFromDisposal: (object) => {\r\n            context.disposableObjects.delete(object);\r\n        },\r\n        disposableObjectMounted: (object) => {\r\n            const currentValue = context.disposableObjects.get(object);\r\n            if (currentValue) {\r\n                context.disposableObjects.set(object, currentValue + 1);\r\n            }\r\n            else {\r\n                context.disposableObjects.set(object, 1);\r\n            }\r\n        },\r\n        disposableObjectUnmounted: (object) => {\r\n            const currentValue = context.disposableObjects.get(object);\r\n            if (currentValue && currentValue > 0) {\r\n                context.disposableObjects.set(object, currentValue - 1);\r\n                if (currentValue - 1 <= 0) {\r\n                    context.shouldDispose = true;\r\n                }\r\n            }\r\n        },\r\n        disposableObjects: new Map(),\r\n        shouldDispose: false,\r\n        dispose: async (force = false) => {\r\n            await tick();\r\n            if (!context.shouldDispose && !force)\r\n                return;\r\n            context.disposableObjects.forEach((mounted, object) => {\r\n                if (mounted === 0 || force) {\r\n                    object?.dispose?.();\r\n                    context.disposableObjects.delete(object);\r\n                }\r\n            });\r\n            context.shouldDispose = false;\r\n        }\r\n    };\r\n    onDestroy(() => {\r\n        context.dispose(true);\r\n    });\r\n    setContext('threlte-disposal-context', context);\r\n    return context;\r\n};\r\nexport const useDisposal = () => {\r\n    const context = getContext('threlte-disposal-context');\r\n    if (!context) {\r\n        throw new Error('useDisposal can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import { getContext, setContext } from 'svelte';\r\nimport { currentWritable } from '../../utilities';\r\nconst parentContextKey = Symbol('threlte-parent-context');\r\n/**\r\n * The parent context is used to access the parent object created by a `<T>`\r\n * component.\r\n */\r\nexport const createParentContext = (parent) => {\r\n    const ctx = currentWritable(parent);\r\n    setContext(parentContextKey, ctx);\r\n    return ctx;\r\n};\r\n/**\r\n * The parent context is used to access the parent object created by a `<T>`\r\n * component.\r\n *\r\n * @example\r\n * ```svelte\r\n * <T.Mesh>\r\n *   <CustomComponent />\r\n * </T.Mesh>\r\n * ```\r\n *\r\n * The parent as retrieved inside the component `<CustomComponent>`\r\n * will be the mesh created by the `<T.Mesh>` component.\r\n */\r\nexport const useParent = () => {\r\n    const parent = getContext(parentContextKey);\r\n    return parent;\r\n};\r\n", "import { getContext, setContext } from 'svelte';\r\nimport { derived, readable, writable } from 'svelte/store';\r\nconst parentObject3DContextKey = Symbol('threlte-parent-object3d-context');\r\nexport const createRootParentObject3DContext = (object) => {\r\n    const ctx = readable(object);\r\n    setContext(parentObject3DContextKey, ctx);\r\n    return ctx;\r\n};\r\n/**\r\n * The parentObject3D context is used to access the parent `THREE.Object3D`\r\n * created by a `<T>` component. The context is automatically merged with the\r\n * parentObject3D context of the parent component when the local context store\r\n * is `undefined`.\r\n */\r\nexport const createParentObject3DContext = (object) => {\r\n    const parentObject3D = getContext(parentObject3DContextKey);\r\n    const object3D = writable(object);\r\n    const ctx = derived([object3D, parentObject3D], ([object3D, parentObject3D]) => {\r\n        return object3D ?? parentObject3D;\r\n    });\r\n    setContext(parentObject3DContextKey, ctx);\r\n    return object3D;\r\n};\r\n/**\r\n * The parentObject3D context is used to access the parent `THREE.Object3D`\r\n * created by a `<T>` component.\r\n *\r\n * @example\r\n * ```svelte\r\n * <T.Mesh>\r\n *   <T.MeshStandardMaterial>\r\n *     <CustomComponent />\r\n *   </T.MeshStandardMaterial>\r\n * </T.Mesh>\r\n * ```\r\n *\r\n * The parentObject3D as retrieved inside the component `<CustomComponent>`\r\n * will be the mesh created by the `<T.Mesh>` component.\r\n */\r\nexport const useParentObject3D = () => {\r\n    return getContext(parentObject3DContextKey);\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { readable, writable } from 'svelte/store';\r\nimport { useScheduler } from '../context/fragments/scheduler.svelte';\r\nimport { DAG } from '../frame-scheduling';\r\nimport { browser } from '../utilities';\r\nexport function useTask(keyOrFn, fnOrOptions, options) {\r\n    if (!browser) {\r\n        return {\r\n            task: undefined,\r\n            start: () => undefined,\r\n            stop: () => undefined,\r\n            started: readable(false)\r\n        };\r\n    }\r\n    let key;\r\n    let fn;\r\n    let opts;\r\n    if (DAG.isKey(keyOrFn)) {\r\n        key = keyOrFn;\r\n        fn = fnOrOptions;\r\n        opts = options;\r\n    }\r\n    else {\r\n        key = Symbol('useTask');\r\n        fn = keyOrFn;\r\n        opts = fnOrOptions;\r\n    }\r\n    const schedulerCtx = useScheduler();\r\n    let stage = schedulerCtx.mainStage;\r\n    if (opts) {\r\n        if (opts.stage) {\r\n            if (DAG.isValue(opts.stage)) {\r\n                stage = opts.stage;\r\n            }\r\n            else {\r\n                const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);\r\n                if (!maybeStage) {\r\n                    throw new Error(`No stage found with key ${opts.stage.toString()}`);\r\n                }\r\n                stage = maybeStage;\r\n            }\r\n        }\r\n        else if (opts.after) {\r\n            if (Array.isArray(opts.after)) {\r\n                for (let index = 0; index < opts.after.length; index++) {\r\n                    const element = opts.after[index];\r\n                    if (DAG.isValue(element)) {\r\n                        stage = element.stage;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if (DAG.isValue(opts.after)) {\r\n                stage = opts.after.stage;\r\n            }\r\n        }\r\n        else if (opts.before) {\r\n            if (Array.isArray(opts.before)) {\r\n                for (let index = 0; index < opts.before.length; index++) {\r\n                    const element = opts.before[index];\r\n                    if (DAG.isValue(element)) {\r\n                        stage = element.stage;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if (DAG.isValue(opts.before)) {\r\n                stage = opts.before.stage;\r\n            }\r\n        }\r\n    }\r\n    const started = writable(false);\r\n    const task = stage.createTask(key, fn, opts);\r\n    const start = () => {\r\n        started.set(true);\r\n        if (opts?.autoInvalidate ?? true) {\r\n            schedulerCtx.autoInvalidations.add(fn);\r\n        }\r\n        task.start();\r\n    };\r\n    const stop = () => {\r\n        started.set(false);\r\n        if (opts?.autoInvalidate ?? true) {\r\n            schedulerCtx.autoInvalidations.delete(fn);\r\n        }\r\n        task.stop();\r\n    };\r\n    if (opts?.autoStart ?? true) {\r\n        start();\r\n    }\r\n    else {\r\n        stop();\r\n    }\r\n    onDestroy(() => {\r\n        if (!stage)\r\n            return;\r\n        stage.removeTask(key);\r\n    });\r\n    return {\r\n        task,\r\n        start,\r\n        stop,\r\n        started: {\r\n            subscribe: started.subscribe\r\n        }\r\n    };\r\n}\r\n", "import { getContext, setContext } from 'svelte';\r\nimport { Scene } from 'three';\r\nexport const createSceneContext = (scene) => {\r\n    const context = { scene: scene || new Scene() };\r\n    setContext('threlte-scene-context', context);\r\n    return context;\r\n};\r\nexport const useScene = () => {\r\n    const context = getContext('threlte-scene-context');\r\n    if (!context) {\r\n        throw new Error('useScene can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import { getContext, onDestroy, setContext } from 'svelte';\r\nimport { AgXToneMapping, ColorManagement, PCFSoftShadowMap, WebGLRenderer } from 'three';\r\nimport { useTask } from '../../hooks/useTask';\r\nimport { currentWritable, watch } from '../../utilities';\r\nimport { useCamera } from './camera';\r\nimport { useCanvas } from './canvas';\r\nimport { useDisposal } from './disposal';\r\nimport { useScene } from './scene';\r\nimport { useScheduler } from './scheduler.svelte';\r\nexport const createRendererContext = (options) => {\r\n    const { dispose } = useDisposal();\r\n    const { camera } = useCamera();\r\n    const { scene } = useScene();\r\n    const { invalidate, renderStage, autoRender, scheduler, resetFrameInvalidation } = useScheduler();\r\n    const { canvas, size } = useCanvas();\r\n    const renderer = options.createRenderer\r\n        ? options.createRenderer(canvas)\r\n        : new WebGLRenderer({\r\n            canvas,\r\n            powerPreference: 'high-performance',\r\n            antialias: true,\r\n            alpha: true\r\n        });\r\n    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), () => {\r\n        renderer.render(scene, camera.current);\r\n    });\r\n    const context = {\r\n        renderer: renderer,\r\n        colorManagementEnabled: currentWritable(options.colorManagementEnabled ?? true),\r\n        colorSpace: currentWritable(options.colorSpace ?? 'srgb'),\r\n        dpr: currentWritable(options.dpr ?? window.devicePixelRatio),\r\n        shadows: currentWritable(options.shadows ?? PCFSoftShadowMap),\r\n        toneMapping: currentWritable(options.toneMapping ?? AgXToneMapping),\r\n        autoRenderTask\r\n    };\r\n    setContext('threlte-renderer-context', context);\r\n    watch([context.colorManagementEnabled], ([colorManagementEnabled]) => {\r\n        ColorManagement.enabled = colorManagementEnabled;\r\n    });\r\n    watch([context.colorSpace], ([colorSpace]) => {\r\n        if ('outputColorSpace' in renderer) {\r\n            renderer.outputColorSpace = colorSpace;\r\n        }\r\n    });\r\n    watch([context.dpr], ([dpr]) => {\r\n        if ('setPixelRatio' in renderer) {\r\n            renderer.setPixelRatio(dpr);\r\n        }\r\n    });\r\n    // Resize the renderer when the size changes\r\n    const { start, stop } = useTask(() => {\r\n        if (!('xr' in renderer) || renderer.xr?.isPresenting)\r\n            return;\r\n        renderer.setSize(size.current.width, size.current.height);\r\n        invalidate();\r\n        stop();\r\n    }, {\r\n        before: autoRenderTask,\r\n        autoStart: false,\r\n        autoInvalidate: false\r\n    });\r\n    watch([size], () => {\r\n        start();\r\n    });\r\n    watch([context.shadows], ([shadows]) => {\r\n        if (!('shadowMap' in renderer))\r\n            return;\r\n        renderer.shadowMap.enabled = !!shadows;\r\n        if (shadows && shadows !== true) {\r\n            renderer.shadowMap.type = shadows;\r\n        }\r\n        else if (shadows === true) {\r\n            renderer.shadowMap.type = PCFSoftShadowMap;\r\n        }\r\n    });\r\n    watch([context.toneMapping], ([toneMapping]) => {\r\n        if (!('toneMapping' in renderer))\r\n            return;\r\n        renderer.toneMapping = toneMapping;\r\n    });\r\n    watch([autoRender], ([autoRender]) => {\r\n        if (autoRender) {\r\n            context.autoRenderTask.start();\r\n        }\r\n        else {\r\n            context.autoRenderTask.stop();\r\n        }\r\n        return () => {\r\n            context.autoRenderTask.stop();\r\n        };\r\n    });\r\n    if ('setAnimationLoop' in context.renderer) {\r\n        const renderer = context.renderer;\r\n        renderer.setAnimationLoop((time) => {\r\n            dispose();\r\n            scheduler.run(time);\r\n            resetFrameInvalidation();\r\n        });\r\n    }\r\n    onDestroy(() => {\r\n        if ('dispose' in context.renderer) {\r\n            const dispose = context.renderer.dispose;\r\n            dispose();\r\n        }\r\n    });\r\n    $effect(() => {\r\n        context.colorManagementEnabled.set(options.colorManagementEnabled ?? true);\r\n    });\r\n    $effect(() => {\r\n        context.colorSpace.set(options.colorSpace ?? 'srgb');\r\n    });\r\n    $effect(() => {\r\n        context.toneMapping.set(options.toneMapping ?? AgXToneMapping);\r\n    });\r\n    $effect(() => {\r\n        context.shadows.set(options.shadows ?? PCFSoftShadowMap);\r\n    });\r\n    $effect(() => {\r\n        context.dpr.set(options.dpr ?? window.devicePixelRatio);\r\n    });\r\n    return context;\r\n};\r\nexport const useRenderer = () => {\r\n    const context = getContext('threlte-renderer-context');\r\n    if (!context) {\r\n        throw new Error('useRenderer can only be used in a child component to <Canvas>.');\r\n    }\r\n    return context;\r\n};\r\n", "import { setContext } from 'svelte';\r\nimport { currentWritable } from '../../utilities';\r\nexport const createUserContext = () => {\r\n    const userCtx = currentWritable({});\r\n    setContext('threlte-user-context', userCtx);\r\n};\r\n", "import { createCacheContext } from './fragments/cache';\r\nimport { createCameraContext } from './fragments/camera';\r\nimport { createCanvasContext } from './fragments/canvas';\r\nimport { createDisposalContext } from './fragments/disposal';\r\nimport { createParentContext } from './fragments/parent';\r\nimport { createRootParentObject3DContext } from './fragments/parentObject3D';\r\nimport { createRendererContext } from './fragments/renderer.svelte';\r\nimport { createSceneContext } from './fragments/scene';\r\nimport { createSchedulerContext } from './fragments/scheduler.svelte';\r\nimport { createUserContext } from './fragments/user';\r\nexport const createThrelteContext = (options) => {\r\n    createCanvasContext(options);\r\n    createCacheContext();\r\n    const { scene } = createSceneContext();\r\n    createParentContext(scene);\r\n    createRootParentObject3DContext(scene);\r\n    createDisposalContext();\r\n    createSchedulerContext(options);\r\n    createCameraContext();\r\n    createRendererContext(options);\r\n    createUserContext();\r\n};\r\n", null, null, "import { useCamera } from '../fragments/camera';\r\nimport { useCanvas } from '../fragments/canvas';\r\nimport { useRenderer } from '../fragments/renderer.svelte';\r\nimport { useScene } from '../fragments/scene';\r\nimport { useScheduler } from '../fragments/scheduler.svelte';\r\n/**\r\n * ### `useThrelte`\r\n *\r\n * This hook provides access to the main context of a Threlte application.\r\n *\r\n * ```svelte\r\n * <script>\r\n *   import { useThrelte } from 'threlte'\r\n *   const { camera } = useThrelte()\r\n *\r\n *   // Access the camera\r\n *   console.log(camera.current) // => PerspectiveCamera { … }\r\n * </script>\r\n * ```\r\n */\r\nexport const useThrelte = () => {\r\n    const schedulerCtx = useScheduler();\r\n    const rendererCtx = useRenderer();\r\n    const cameraCtx = useCamera();\r\n    const sceneCtx = useScene();\r\n    const canvasCtx = useCanvas();\r\n    const context = {\r\n        advance: schedulerCtx.advance,\r\n        autoRender: schedulerCtx.autoRender,\r\n        autoRenderTask: rendererCtx.autoRenderTask,\r\n        camera: cameraCtx.camera,\r\n        colorManagementEnabled: rendererCtx.colorManagementEnabled,\r\n        colorSpace: rendererCtx.colorSpace,\r\n        dpr: rendererCtx.dpr,\r\n        invalidate: schedulerCtx.invalidate,\r\n        mainStage: schedulerCtx.mainStage,\r\n        renderer: rendererCtx.renderer,\r\n        renderMode: schedulerCtx.renderMode,\r\n        renderStage: schedulerCtx.renderStage,\r\n        scheduler: schedulerCtx.scheduler,\r\n        shadows: rendererCtx.shadows,\r\n        shouldRender: schedulerCtx.shouldRender,\r\n        size: canvasCtx.size,\r\n        toneMapping: rendererCtx.toneMapping,\r\n        get scene() {\r\n            return sceneCtx.scene;\r\n        },\r\n        set scene(scene) {\r\n            sceneCtx.scene = scene;\r\n        }\r\n    };\r\n    return context;\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { writable } from 'svelte/store';\r\nimport { useThrelte } from '../../../context/compounds/useThrelte';\r\nimport { createParentContext, useParent } from '../../../context/fragments/parent';\r\nimport { createParentObject3DContext, useParentObject3D } from '../../../context/fragments/parentObject3D';\r\nimport { isInstanceOf, resolvePropertyPath, watch } from '../../../utilities';\r\nconst isObject = (ref) => {\r\n    return typeof ref === 'object' && ref !== null;\r\n};\r\nexport const useAttach = () => {\r\n    const { invalidate } = useThrelte();\r\n    let detachFn;\r\n    const attach = writable();\r\n    const parent = useParent();\r\n    const parentObject3D = useParentObject3D();\r\n    const currentRef = createParentContext();\r\n    const object3D = createParentObject3DContext();\r\n    watch([attach, currentRef, parent, parentObject3D], ([attach, ref, parent, parentObject3D]) => {\r\n        // Always detach first\r\n        detachFn?.();\r\n        detachFn = undefined;\r\n        if (!ref) {\r\n            invalidate();\r\n            return;\r\n        }\r\n        if (attach !== undefined) {\r\n            // Manual attach\r\n            if (attach) {\r\n                if (typeof attach === 'function') {\r\n                    detachFn = attach({ ref: ref, parent, parentObject3D });\r\n                }\r\n                else if (isInstanceOf(attach, 'Object3D') && isInstanceOf(ref, 'Object3D')) {\r\n                    detachFn = () => attach?.remove(ref);\r\n                    // Add to parent Object3D\r\n                    attach?.add(ref);\r\n                }\r\n                else if (typeof attach === 'string') {\r\n                    const { target, key } = resolvePropertyPath(parent, attach);\r\n                    const valueBeforeAttach = target[key];\r\n                    detachFn = () => (target[key] = valueBeforeAttach);\r\n                    target[key] = ref;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Auto attach\r\n            if (isInstanceOf(ref, 'Object3D')) {\r\n                // Build detach function\r\n                detachFn = () => parentObject3D?.remove(ref);\r\n                // Add to parent Object3D\r\n                parentObject3D?.add(ref);\r\n            }\r\n            else if (isObject(parent)) {\r\n                // Auto-attach to parent material or geometry\r\n                if (isInstanceOf(ref, 'Material')) {\r\n                    parent['material'] = ref;\r\n                }\r\n                else if (isInstanceOf(ref, 'BufferGeometry')) {\r\n                    parent['geometry'] = ref;\r\n                }\r\n            }\r\n        }\r\n        invalidate();\r\n    });\r\n    const updateAttach = (a) => {\r\n        attach.set(a);\r\n    };\r\n    const updateRef = (value) => {\r\n        currentRef.set(value);\r\n        if (isInstanceOf(value, 'Object3D')) {\r\n            object3D.set(value);\r\n        }\r\n    };\r\n    onDestroy(() => {\r\n        detachFn?.();\r\n        invalidate();\r\n    });\r\n    return {\r\n        updateRef,\r\n        updateAttach\r\n    };\r\n};\r\n", "import { writable } from 'svelte/store';\r\nimport { useThrelte } from '../../../context/compounds/useThrelte';\r\nimport { isInstanceOf, watch } from '../../../utilities';\r\nconst isPerspectiveOrOrthographicCamera = (value) => {\r\n    return isInstanceOf(value, 'PerspectiveCamera') || isInstanceOf(value, 'OrthographicCamera');\r\n};\r\nexport const useCamera = () => {\r\n    const { invalidate, size, camera } = useThrelte();\r\n    const currentRef = writable();\r\n    const manual = writable(true);\r\n    const makeDefault = writable(false);\r\n    watch([currentRef, makeDefault], ([ref, makeDefault]) => {\r\n        if (!ref || !makeDefault)\r\n            return;\r\n        camera.set(ref);\r\n        invalidate();\r\n    });\r\n    watch([currentRef, manual, size], ([ref, manual, size]) => {\r\n        if (!ref || manual)\r\n            return;\r\n        if (isInstanceOf(ref, 'OrthographicCamera')) {\r\n            ref.left = size.width / -2;\r\n            ref.right = size.width / 2;\r\n            ref.top = size.height / 2;\r\n            ref.bottom = size.height / -2;\r\n            ref.updateProjectionMatrix();\r\n            ref.updateMatrixWorld();\r\n            invalidate();\r\n        }\r\n        else if (isInstanceOf(ref, 'PerspectiveCamera')) {\r\n            ref.aspect = size.width / size.height;\r\n            ref.updateProjectionMatrix();\r\n            ref.updateMatrixWorld();\r\n            invalidate();\r\n        }\r\n    });\r\n    const updateRef = (ref) => {\r\n        if (!isPerspectiveOrOrthographicCamera(ref))\r\n            return;\r\n        currentRef.set(ref);\r\n    };\r\n    const updateManual = (m) => {\r\n        manual.set(m);\r\n    };\r\n    const updateMakeDefault = (d) => {\r\n        makeDefault.set(d);\r\n    };\r\n    return {\r\n        updateRef,\r\n        updateManual,\r\n        updateMakeDefault\r\n    };\r\n};\r\n", "import { onDestroy, onMount } from 'svelte';\r\nexport const useCreateEvent = (oncreate) => {\r\n    let cleanupFunction;\r\n    let ref = undefined;\r\n    let mounted = false;\r\n    const dispatchCreateEvent = () => {\r\n        cleanupFunction?.();\r\n        cleanupFunction = oncreate?.(ref);\r\n    };\r\n    const updateRef = (newRef) => {\r\n        ref = newRef;\r\n        if (!mounted)\r\n            return;\r\n        dispatchCreateEvent();\r\n    };\r\n    onMount(() => {\r\n        dispatchCreateEvent();\r\n        mounted = true;\r\n    });\r\n    onDestroy(() => cleanupFunction?.());\r\n    return {\r\n        updateRef\r\n    };\r\n};\r\n", "import { getContext, onDestroy, setContext } from 'svelte';\r\nimport { derived, get, writable } from 'svelte/store';\r\nimport { useDisposal } from '../../../context/fragments/disposal';\r\nimport { isInstanceOf, watch } from '../../../utilities';\r\nconst contextName = Symbol('threlte-disposable-object-context');\r\n/**\r\n * Checks if the given object is a disposable object. Scenes are not disposable.\r\n * @param object - The object to check.\r\n * @returns True if the object is a disposable object, false otherwise.\r\n */\r\nconst isDisposableObject = (object) => {\r\n    return typeof object?.dispose === 'function' && !isInstanceOf(object, 'Scene');\r\n};\r\nexport const useDispose = (dispose) => {\r\n    let previousRef = undefined;\r\n    const currentRef = writable(undefined);\r\n    const localDispose = writable(dispose);\r\n    const { disposableObjectMounted, disposableObjectUnmounted, removeObjectFromDisposal } = useDisposal();\r\n    const parentDispose = getContext(contextName);\r\n    // We merge the local dispose with the parent dispose. If the parent dispose\r\n    // is not set, we use true as default.\r\n    const mergedDispose = derived([localDispose, parentDispose ?? writable(true)], ([localDispose, parentDispose]) => localDispose ?? parentDispose ?? true);\r\n    setContext(contextName, mergedDispose);\r\n    watch([currentRef, mergedDispose], ([ref, mergedDispose]) => {\r\n        if (ref === previousRef) {\r\n            // dispose changed\r\n            if (!mergedDispose) {\r\n                // disposal is no longer enabled, so we need to deregister the previous ref\r\n                if (previousRef)\r\n                    removeObjectFromDisposal(previousRef);\r\n            }\r\n            else {\r\n                // disposal is enabled, so we need to register the previous ref\r\n                if (previousRef)\r\n                    disposableObjectMounted(previousRef);\r\n            }\r\n        }\r\n        else {\r\n            // ref changed\r\n            if (mergedDispose) {\r\n                // we're disposing the old ref\r\n                if (previousRef)\r\n                    disposableObjectUnmounted(previousRef);\r\n                // and registering the new ref\r\n                if (ref)\r\n                    disposableObjectMounted(ref);\r\n            }\r\n        }\r\n        previousRef = ref;\r\n    });\r\n    onDestroy(() => {\r\n        if (!get(mergedDispose))\r\n            return;\r\n        const ref = get(currentRef);\r\n        if (ref)\r\n            disposableObjectUnmounted(ref);\r\n    });\r\n    const updateRef = (ref) => {\r\n        if (!isDisposableObject(ref))\r\n            return;\r\n        currentRef.set(ref);\r\n    };\r\n    const updateDispose = (dispose) => {\r\n        localDispose.set(dispose);\r\n    };\r\n    return {\r\n        updateRef,\r\n        updateDispose\r\n    };\r\n};\r\n", "/**\r\n * Typeguard to check if a value is extending THREE.EventDispatcher\r\n * @param value\r\n * @returns\r\n */\r\nconst isEventDispatcher = (value) => {\r\n    return (value !== null &&\r\n        typeof value === 'object' &&\r\n        'addEventListener' in value &&\r\n        'removeEventListener' in value);\r\n};\r\nexport const useEvents = (props = {}) => {\r\n    const eventHandlerProxy = (event) => {\r\n        if (event?.type) {\r\n            props[`on${event.type}`]?.(event);\r\n        }\r\n    };\r\n    const addEventListeners = (ref, props) => {\r\n        const eventNames = [];\r\n        for (const eventName of Object.keys(props)) {\r\n            if (eventName.startsWith('on')) {\r\n                ref.addEventListener(eventName.slice(2), eventHandlerProxy);\r\n                eventNames.push(eventName);\r\n            }\r\n        }\r\n        return () => {\r\n            for (let i = 0; i < eventNames.length; i++) {\r\n                ref.removeEventListener(eventNames[i], eventHandlerProxy);\r\n            }\r\n        };\r\n    };\r\n    const updateRef = (ref) => {\r\n        if (!isEventDispatcher(ref))\r\n            return;\r\n        return addEventListeners(ref, props);\r\n    };\r\n    return {\r\n        updateRef\r\n    };\r\n};\r\n", "let currentIs;\r\nexport const setIs = (is) => {\r\n    currentIs = is;\r\n};\r\nexport const useIs = () => {\r\n    const is = currentIs;\r\n    currentIs = undefined;\r\n    return is;\r\n};\r\n", "import { getContext } from 'svelte';\r\nexport const usePlugins = (args) => {\r\n    const pluginContextName = 'threlte-plugin-context';\r\n    const plugins = getContext(pluginContextName);\r\n    if (!plugins)\r\n        return;\r\n    const pluginsProps = [];\r\n    const pluginsArray = Object.values(plugins);\r\n    if (pluginsArray.length) {\r\n        const pluginArgs = args();\r\n        // initalize plugins\r\n        for (let i = 0; i < pluginsArray.length; i++) {\r\n            const plugin = pluginsArray[i];\r\n            // initialize plugin\r\n            const p = plugin(pluginArgs);\r\n            if (p && p.pluginProps) {\r\n                pluginsProps.push(...p.pluginProps);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        pluginsProps\r\n    };\r\n};\r\n", "import { useThrelte } from '../../../context/compounds/useThrelte';\r\nimport { resolvePropertyPath } from '../../../utilities';\r\nconst ignoredProps = new Set(['$$scope', '$$slots', 'type', 'args', 'attach', 'instance']);\r\nconst updateProjectionMatrixKeys = new Set([\r\n    'fov',\r\n    'aspect',\r\n    'near',\r\n    'far',\r\n    'left',\r\n    'right',\r\n    'top',\r\n    'bottom',\r\n    'zoom'\r\n]);\r\n/**\r\n * Only scalar values are memoized, objects and arrays are considered\r\n * non-equa by default, to ensure reactivity works as you would\r\n * expect in svelte.\r\n * @param value\r\n * @returns\r\n */\r\nexport const memoizeProp = (value) => {\r\n    // scalar values are memoized\r\n    if (typeof value === 'string')\r\n        return true;\r\n    if (typeof value === 'number')\r\n        return true;\r\n    if (typeof value === 'boolean')\r\n        return true;\r\n    if (typeof value === 'undefined')\r\n        return true;\r\n    if (value === null)\r\n        return true;\r\n    // objects and arrays cannot be reliably memoized\r\n    return false;\r\n};\r\nconst createSetter = (target, key, value) => {\r\n    if (!Array.isArray(value) &&\r\n        typeof value === 'number' &&\r\n        typeof target[key]?.setScalar === 'function' &&\r\n        // colors do have a setScalar function, but we don't want to use it, because\r\n        // the hex notation (i.e. 0xff0000) is very popular and matches the number\r\n        // type. So we exclude colors here.\r\n        !target[key]?.isColor) {\r\n        // edge case of setScalar setters\r\n        return (target, key, value) => {\r\n            target[key].setScalar(value);\r\n        };\r\n    }\r\n    else {\r\n        if (typeof target[key]?.set === 'function') {\r\n            // if the property has a \"set\" function, we can use it\r\n            if (Array.isArray(value)) {\r\n                return (target, key, value) => {\r\n                    target[key].set(...value);\r\n                };\r\n            }\r\n            else {\r\n                return (target, key, value) => {\r\n                    target[key].set(value);\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            // otherwise, we just set the value\r\n            return (target, key, value) => {\r\n                target[key] = value;\r\n            };\r\n        }\r\n    }\r\n};\r\nexport const useProps = () => {\r\n    const { invalidate } = useThrelte();\r\n    const memoizedProps = new Map();\r\n    const memoizedSetters = new Map();\r\n    const setProp = (instance, propertyPath, value, options) => {\r\n        if (memoizeProp(value)) {\r\n            const memoizedProp = memoizedProps.get(propertyPath);\r\n            if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\r\n                return;\r\n            }\r\n            memoizedProps.set(propertyPath, {\r\n                instance,\r\n                value\r\n            });\r\n        }\r\n        const { key, target } = resolvePropertyPath(instance, propertyPath);\r\n        if (value !== undefined && value !== null) {\r\n            const memoizedSetter = memoizedSetters.get(propertyPath);\r\n            if (memoizedSetter) {\r\n                memoizedSetter(target, key, value);\r\n            }\r\n            else {\r\n                const setter = createSetter(target, key, value);\r\n                memoizedSetters.set(propertyPath, setter);\r\n                setter(target, key, value);\r\n            }\r\n        }\r\n        else {\r\n            createSetter(target, key, value)(target, key, value);\r\n        }\r\n        if (options.manualCamera)\r\n            return;\r\n        if (updateProjectionMatrixKeys.has(key) &&\r\n            (target.isPerspectiveCamera || target.isOrthographicCamera)) {\r\n            target.updateProjectionMatrix();\r\n        }\r\n    };\r\n    const updateProp = (instance, key, value, options) => {\r\n        if (!ignoredProps.has(key) && !options.pluginsProps?.includes(key)) {\r\n            setProp(instance, key, value, options);\r\n        }\r\n        invalidate();\r\n    };\r\n    return {\r\n        updateProp\r\n    };\r\n};\r\n", "const classRegex = /^\\s*class\\s+/;\r\n// Type Guards\r\nconst isClass = (input) => {\r\n    if (typeof input !== 'function') {\r\n        return false;\r\n    }\r\n    return classRegex.test(input.toString());\r\n};\r\nconst argsIsConstructorParameters = (args) => {\r\n    return Array.isArray(args);\r\n};\r\nexport const determineRef = (is, args) => {\r\n    if (isClass(is)) {\r\n        if (argsIsConstructorParameters(args)) {\r\n            return new is(...args);\r\n        }\r\n        else {\r\n            return new is();\r\n        }\r\n    }\r\n    return is;\r\n};\r\n", null, "import * as THREE from 'three';\r\nimport TComp from './T.svelte';\r\nimport { setIs } from './utils/useIs';\r\nconst catalogue = {};\r\n/**\r\n * Extends the default THREE namespace and allows using custom Three.js objects with `<T>`.\r\n *\r\n * @example\r\n * ```svelte\r\n * <script>\r\n * \timport { extend, T } from 'threlte'\r\n * \timport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\n *\r\n * \textend({ OrbitControls })\r\n * </script>\r\n *\r\n * <T.OrbitControls />\r\n * ```\r\n */\r\nexport const extend = (extensions) => {\r\n    Object.assign(catalogue, extensions);\r\n};\r\n/**\r\n * ## `<T>`\r\n *\r\n * Threlte's `<T>` component is a wrapper around Three.js objects. It is a generic component that can be used to create any Three.js object.\r\n *\r\n * @example\r\n *\r\n * ```svelte\r\n * <script>\r\n * \timport { T } from 'threlte'\r\n * </script>\r\n *\r\n * <T.PerspectiveCamera makeDefault />\r\n *\r\n * <T.Mesh>\r\n * \t<T.BoxGeometry />\r\n * \t<T.MeshBasicMaterial color=\"red\" />\r\n * </T.Mesh>\r\n * ```\r\n */\r\nexport const T = new Proxy(function () { }, {\r\n    apply(_target, _thisArg, argArray) {\r\n        return TComp(...argArray);\r\n    },\r\n    get(_target, is) {\r\n        // Handle snippets\r\n        if (typeof is !== 'string') {\r\n            return TComp;\r\n        }\r\n        const module = catalogue[is] || THREE[is];\r\n        if (module === undefined) {\r\n            throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\r\n        }\r\n        setIs(module);\r\n        return TComp;\r\n    }\r\n});\r\n", "import { getContext, setContext } from 'svelte';\r\nexport function injectPlugin(name, plugin) {\r\n    const contextName = 'threlte-plugin-context';\r\n    if (!plugin)\r\n        return;\r\n    setContext(contextName, {\r\n        ...getContext(contextName),\r\n        [name]: plugin\r\n    });\r\n}\r\n", "import { useThrelte } from '../context/compounds/useThrelte';\r\n/**\r\n * Creates a stage and returns it. If the stage already exists, it is returned.\r\n *\r\n * @param key The key of the stage.\r\n * @param options Options for creating the stage.\r\n */\r\nexport function useStage(key, options) {\r\n    const { scheduler } = useThrelte();\r\n    return scheduler.getStage(key) ?? scheduler.createStage(key, options);\r\n}\r\n", "import { getContext } from 'svelte';\r\nimport { derived } from 'svelte/store';\r\nexport function useThrelteUserContext(namespace, value, options) {\r\n    const userCtxStore = getContext('threlte-user-context');\r\n    if (!userCtxStore) {\r\n        throw new Error('No user context store found, did you invoke this function outside of your main <Canvas> component?');\r\n    }\r\n    // return the plain user context store\r\n    if (!namespace) {\r\n        return {\r\n            subscribe: userCtxStore.subscribe\r\n        };\r\n    }\r\n    // return a specific user context entry\r\n    if (namespace && !value) {\r\n        return derived(userCtxStore, (ctx) => ctx[namespace]);\r\n    }\r\n    // we are possibly setting a new user context entry here\r\n    userCtxStore.update((ctx) => {\r\n        if (namespace in ctx) {\r\n            // skip is the default value\r\n            if (!options || options.existing === 'skip')\r\n                return ctx;\r\n            if (options.existing === 'merge') {\r\n                const v = typeof value === 'function' ? value() : value;\r\n                Object.assign(ctx[namespace], v);\r\n                return ctx;\r\n            }\r\n        }\r\n        // also handles options.existing === 'replace'\r\n        const v = typeof value === 'function' ? value() : value;\r\n        ctx[namespace] = v;\r\n        return ctx;\r\n    });\r\n    return userCtxStore.current[namespace];\r\n}\r\n", "import { useCache } from '../context/fragments/cache';\r\nimport { asyncWritable } from '../utilities';\r\nexport function useLoader(Proto, options) {\r\n    const { remember, clear: clearCacheItem } = useCache();\r\n    let loader;\r\n    const initializeLoader = () => {\r\n        // Type-wrestling galore\r\n        const lazyLoader = new Proto(...(options?.args ?? []));\r\n        // extend the loader if necessary\r\n        options?.extend?.(lazyLoader);\r\n        return lazyLoader;\r\n    };\r\n    const load = (input, options) => {\r\n        // Allow Async and Sync loaders\r\n        const loadResource = async (url) => {\r\n            if (!loader) {\r\n                loader = initializeLoader();\r\n            }\r\n            if ('loadAsync' in loader) {\r\n                const result = await loader.loadAsync(url, options?.onProgress);\r\n                return options?.transform?.(result) ?? result;\r\n            }\r\n            else {\r\n                return new Promise((resolve, reject) => {\r\n                    ;\r\n                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);\r\n                });\r\n            }\r\n        };\r\n        if (Array.isArray(input)) {\r\n            // map over the input array and return an array of promises\r\n            const promises = input.map((url) => {\r\n                return remember(() => loadResource(url), [Proto, url]);\r\n            });\r\n            // return an AsyncWritable that resolves to the array of promises\r\n            const store = asyncWritable(Promise.all(promises));\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n        else if (typeof input === 'string') {\r\n            const promise = remember(() => loadResource(input), [Proto, input]);\r\n            // return an AsyncWritable that resolves to the promise\r\n            const store = asyncWritable(promise);\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n        else {\r\n            // map over the input object and return an array of promises\r\n            const promises = Object.values(input).map((url) => {\r\n                return remember(() => loadResource(url), [Proto, url]);\r\n            });\r\n            // return an AsyncWritable that resolves to the object of promises\r\n            const store = asyncWritable(Promise.all(promises).then((results) => {\r\n                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));\r\n            }));\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n    };\r\n    const clear = (input) => {\r\n        if (Array.isArray(input)) {\r\n            input.forEach((url) => {\r\n                clearCacheItem([Proto, url]);\r\n            });\r\n        }\r\n        else if (typeof input === 'string') {\r\n            clearCacheItem([Proto, input]);\r\n        }\r\n        else {\r\n            Object.entries(input).forEach(([key, url]) => {\r\n                clearCacheItem([Proto, key, url]);\r\n            });\r\n        }\r\n    };\r\n    return {\r\n        load,\r\n        clear,\r\n        loader\r\n    };\r\n}\r\n// Type tests\r\n// class WithConstructorParameters {\r\n//   constructor(hello: 'abc' | 'def') {\r\n//     console.log(hello)\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// class WithOptionalConstructorParameters {\r\n//   constructor(hello?: string) {\r\n//     console.log(hello)\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// class WithoutConstructorParameters {\r\n//   constructor() {\r\n//     console.log('without')\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// const shouldFail = () => {\r\n//   useLoader(WithConstructorParameters)\r\n//   useLoader(WithoutConstructorParameters, {\r\n//     args: ['hello']\r\n//   })\r\n// }\r\n// const shouldSucceed = () => {\r\n//   useLoader(WithConstructorParameters, {\r\n//     args: ['abc']\r\n//   })\r\n//   useLoader(WithConstructorParameters, {\r\n//     args: ['abc'],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters)\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: [],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: ['hello'],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: ['hello']\r\n//   })\r\n//   useLoader(WithoutConstructorParameters)\r\n//   useLoader(WithoutConstructorParameters, {\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n// }\r\n", "import './types.d.ts';\r\nexport const VERSION = 8;\r\n// canvas component\r\nexport { default as Canvas } from './Canvas.svelte';\r\n// components (v6)\r\nexport { T, extend } from './components/T/T';\r\n// plugins\r\nexport { injectPlugin } from './plugins/injectPlugin';\r\n// hooks\r\nexport { useThrelte } from './context/compounds/useThrelte';\r\nexport { useStage } from './hooks/useStage';\r\nexport { useTask } from './hooks/useTask';\r\nexport { useThrelteUserContext } from './hooks/useThrelteUserContext';\r\n// useLoader\r\nexport { useLoader } from './hooks/useLoader';\r\nexport { createThrelteContext } from './context/createThrelteContext.svelte';\r\nexport { createCacheContext, useCache } from './context/fragments/cache';\r\nexport { createCameraContext, useCamera } from './context/fragments/camera';\r\nexport { createCanvasContext, useCanvas } from './context/fragments/canvas';\r\nexport { createDisposalContext, useDisposal } from './context/fragments/disposal';\r\nexport { createParentContext, useParent } from './context/fragments/parent';\r\nexport { createParentObject3DContext, useParentObject3D } from './context/fragments/parentObject3D';\r\nexport { createRendererContext, useRenderer } from './context/fragments/renderer.svelte';\r\nexport { createSceneContext, useScene } from './context/fragments/scene';\r\nexport { createSchedulerContext, useScheduler } from './context/fragments/scheduler.svelte';\r\n// utils\r\nexport * from './utilities';\r\n"],
  "mappings": "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",
  "names": ["entry", "derived", "value", "start", "size", "derived", "object3D", "parentObject3D", "autoRender", "renderer", "dispose", "attach", "parent", "parentObject3D", "useCamera", "makeDefault", "manual", "size", "derived", "localDispose", "parentDispose", "mergedDispose", "get", "dispose", "props", "target", "key", "value", "useCamera", "T", "contextName", "derived", "v", "options", "_a"]
}
