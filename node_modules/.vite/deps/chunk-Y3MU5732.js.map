{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/DRACOLoader.js"],
  "sourcesContent": ["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tColor,\r\n\tColorManagement,\r\n\tFileLoader,\r\n\tLoader,\r\n\tLinearSRGBColorSpace,\r\n\tSRGBColorSpace\r\n} from 'three';\r\n\r\nconst _taskCache = new WeakMap();\r\n\r\nclass DRACOLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\tthis.decoderPath = '';\r\n\t\tthis.decoderConfig = {};\r\n\t\tthis.decoderBinary = null;\r\n\t\tthis.decoderPending = null;\r\n\r\n\t\tthis.workerLimit = 4;\r\n\t\tthis.workerPool = [];\r\n\t\tthis.workerNextTaskID = 1;\r\n\t\tthis.workerSourceURL = '';\r\n\r\n\t\tthis.defaultAttributeIDs = {\r\n\t\t\tposition: 'POSITION',\r\n\t\t\tnormal: 'NORMAL',\r\n\t\t\tcolor: 'COLOR',\r\n\t\t\tuv: 'TEX_COORD'\r\n\t\t};\r\n\t\tthis.defaultAttributeTypes = {\r\n\t\t\tposition: 'Float32Array',\r\n\t\t\tnormal: 'Float32Array',\r\n\t\t\tcolor: 'Float32Array',\r\n\t\t\tuv: 'Float32Array'\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tsetDecoderPath( path ) {\r\n\r\n\t\tthis.decoderPath = path;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetDecoderConfig( config ) {\r\n\r\n\t\tthis.decoderConfig = config;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetWorkerLimit( workerLimit ) {\r\n\r\n\t\tthis.workerLimit = workerLimit;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tloader.load( url, ( buffer ) => {\r\n\r\n\t\t\tthis.parse( buffer, onLoad, onError );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\r\n\tparse( buffer, onLoad, onError = ()=>{} ) {\r\n\r\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace, onError ).catch( onError );\r\n\r\n\t}\r\n\r\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {} ) {\r\n\r\n\t\tconst taskConfig = {\r\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\r\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\r\n\t\t\tuseUniqueIDs: !! attributeIDs,\r\n\t\t\tvertexColorSpace: vertexColorSpace,\r\n\t\t};\r\n\r\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback ).catch( onError );\r\n\r\n\t}\r\n\r\n\tdecodeGeometry( buffer, taskConfig ) {\r\n\r\n\t\tconst taskKey = JSON.stringify( taskConfig );\r\n\r\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\r\n\t\t// again from this thread.\r\n\t\tif ( _taskCache.has( buffer ) ) {\r\n\r\n\t\t\tconst cachedTask = _taskCache.get( buffer );\r\n\r\n\t\t\tif ( cachedTask.key === taskKey ) {\r\n\r\n\t\t\t\treturn cachedTask.promise;\r\n\r\n\t\t\t} else if ( buffer.byteLength === 0 ) {\r\n\r\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\r\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\r\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\r\n\t\t\t\t// different ways, so this is left unimplemented.\r\n\t\t\t\tthrow new Error(\r\n\r\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\r\n\t\t\t\t\t'settings. Buffer has already been transferred.'\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tlet worker;\r\n\t\tconst taskID = this.workerNextTaskID ++;\r\n\t\tconst taskCost = buffer.byteLength;\r\n\r\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\r\n\t\t// when the task completes.\r\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\r\n\t\t\t.then( ( _worker ) => {\r\n\r\n\t\t\t\tworker = _worker;\r\n\r\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\r\n\r\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\r\n\r\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\r\n\r\n\t\t\t\t\t// this.debug();\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} )\r\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\r\n\r\n\t\t// Remove task from the task list.\r\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\r\n\t\tgeometryPending\r\n\t\t\t.catch( () => true )\r\n\t\t\t.then( () => {\r\n\r\n\t\t\t\tif ( worker && taskID ) {\r\n\r\n\t\t\t\t\tthis._releaseTask( worker, taskID );\r\n\r\n\t\t\t\t\t// this.debug();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t// Cache the task result.\r\n\t\t_taskCache.set( buffer, {\r\n\r\n\t\t\tkey: taskKey,\r\n\t\t\tpromise: geometryPending\r\n\r\n\t\t} );\r\n\r\n\t\treturn geometryPending;\r\n\r\n\t}\r\n\r\n\t_createGeometry( geometryData ) {\r\n\r\n\t\tconst geometry = new BufferGeometry();\r\n\r\n\t\tif ( geometryData.index ) {\r\n\r\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\r\n\r\n\t\t\tconst result = geometryData.attributes[ i ];\r\n\t\t\tconst name = result.name;\r\n\t\t\tconst array = result.array;\r\n\t\t\tconst itemSize = result.itemSize;\r\n\r\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\r\n\r\n\t\t\tif ( name === 'color' ) {\r\n\r\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\r\n\r\n\t\t\t\tattribute.normalized = ( array instanceof Float32Array ) === false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( name, attribute );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\r\n\r\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\r\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\r\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\r\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\r\n\r\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\r\n\r\n\t\tconst _color = new Color();\r\n\r\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\r\n\r\n\t\t\t_color.fromBufferAttribute( attribute, i );\r\n\t\t\tColorManagement.toWorkingColorSpace( _color, SRGBColorSpace );\r\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_loadLibrary( url, responseType ) {\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.decoderPath );\r\n\t\tloader.setResponseType( responseType );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\treturn new Promise( ( resolve, reject ) => {\r\n\r\n\t\t\tloader.load( url, resolve, undefined, reject );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tpreload() {\r\n\r\n\t\tthis._initDecoder();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t_initDecoder() {\r\n\r\n\t\tif ( this.decoderPending ) return this.decoderPending;\r\n\r\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\r\n\t\tconst librariesPending = [];\r\n\r\n\t\tif ( useJS ) {\r\n\r\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\r\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\r\n\r\n\t\t}\r\n\r\n\t\tthis.decoderPending = Promise.all( librariesPending )\r\n\t\t\t.then( ( libraries ) => {\r\n\r\n\t\t\t\tconst jsContent = libraries[ 0 ];\r\n\r\n\t\t\t\tif ( ! useJS ) {\r\n\r\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst fn = DRACOWorker.toString();\r\n\r\n\t\t\t\tconst body = [\r\n\t\t\t\t\t'/* draco decoder */',\r\n\t\t\t\t\tjsContent,\r\n\t\t\t\t\t'',\r\n\t\t\t\t\t'/* worker */',\r\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\treturn this.decoderPending;\r\n\r\n\t}\r\n\r\n\t_getWorker( taskID, taskCost ) {\r\n\r\n\t\treturn this._initDecoder().then( () => {\r\n\r\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\r\n\r\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\r\n\r\n\t\t\t\tworker._callbacks = {};\r\n\t\t\t\tworker._taskCosts = {};\r\n\t\t\t\tworker._taskLoad = 0;\r\n\r\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\r\n\r\n\t\t\t\tworker.onmessage = function ( e ) {\r\n\r\n\t\t\t\t\tconst message = e.data;\r\n\r\n\t\t\t\t\tswitch ( message.type ) {\r\n\r\n\t\t\t\t\t\tcase 'decode':\r\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'error':\r\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tthis.workerPool.push( worker );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\r\n\r\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\r\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\r\n\t\t\tworker._taskLoad += taskCost;\r\n\t\t\treturn worker;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_releaseTask( worker, taskID ) {\r\n\r\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\r\n\t\tdelete worker._callbacks[ taskID ];\r\n\t\tdelete worker._taskCosts[ taskID ];\r\n\r\n\t}\r\n\r\n\tdebug() {\r\n\r\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\r\n\r\n\t\t\tthis.workerPool[ i ].terminate();\r\n\r\n\t\t}\r\n\r\n\t\tthis.workerPool.length = 0;\r\n\r\n\t\tif ( this.workerSourceURL !== '' ) {\r\n\r\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* WEB WORKER */\r\n\r\nfunction DRACOWorker() {\r\n\r\n\tlet decoderConfig;\r\n\tlet decoderPending;\r\n\r\n\tonmessage = function ( e ) {\r\n\r\n\t\tconst message = e.data;\r\n\r\n\t\tswitch ( message.type ) {\r\n\r\n\t\t\tcase 'init':\r\n\t\t\t\tdecoderConfig = message.decoderConfig;\r\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\r\n\r\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\r\n\r\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\r\n\t\t\t\t\t\tresolve( { draco: draco } );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'decode':\r\n\t\t\t\tconst buffer = message.buffer;\r\n\t\t\t\tconst taskConfig = message.taskConfig;\r\n\t\t\t\tdecoderPending.then( ( module ) => {\r\n\r\n\t\t\t\t\tconst draco = module.draco;\r\n\t\t\t\t\tconst decoder = new draco.Decoder();\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\r\n\r\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\r\n\r\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\r\n\r\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\r\n\r\n\t\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\t\tconsole.error( error );\r\n\r\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\r\n\r\n\t\t\t\t\t} finally {\r\n\r\n\t\t\t\t\t\tdraco.destroy( decoder );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\r\n\r\n\t\tconst attributeIDs = taskConfig.attributeIDs;\r\n\t\tconst attributeTypes = taskConfig.attributeTypes;\r\n\r\n\t\tlet dracoGeometry;\r\n\t\tlet decodingStatus;\r\n\r\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\r\n\r\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\r\n\r\n\t\t\tdracoGeometry = new draco.Mesh();\r\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\r\n\r\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\r\n\r\n\t\t\tdracoGeometry = new draco.PointCloud();\r\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = { index: null, attributes: [] };\r\n\r\n\t\t// Gather all vertex attributes.\r\n\t\tfor ( const attributeName in attributeIDs ) {\r\n\r\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\r\n\r\n\t\t\tlet attribute;\r\n\t\t\tlet attributeID;\r\n\r\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\r\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\r\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\r\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\r\n\t\t\tif ( taskConfig.useUniqueIDs ) {\r\n\r\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\r\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\r\n\r\n\t\t\t\tif ( attributeID === - 1 ) continue;\r\n\r\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\r\n\r\n\t\t\tif ( attributeName === 'color' ) {\r\n\r\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.attributes.push( attributeResult );\r\n\r\n\t\t}\r\n\r\n\t\t// Add index.\r\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\r\n\r\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\r\n\r\n\t\t}\r\n\r\n\t\tdraco.destroy( dracoGeometry );\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\r\n\r\n\t\tconst numFaces = dracoGeometry.num_faces();\r\n\t\tconst numIndices = numFaces * 3;\r\n\t\tconst byteLength = numIndices * 4;\r\n\r\n\t\tconst ptr = draco._malloc( byteLength );\r\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\r\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\r\n\t\tdraco._free( ptr );\r\n\r\n\t\treturn { array: index, itemSize: 1 };\r\n\r\n\t}\r\n\r\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\r\n\r\n\t\tconst numComponents = attribute.num_components();\r\n\t\tconst numPoints = dracoGeometry.num_points();\r\n\t\tconst numValues = numPoints * numComponents;\r\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\r\n\t\tconst dataType = getDracoDataType( draco, attributeType );\r\n\r\n\t\tconst ptr = draco._malloc( byteLength );\r\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\r\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\r\n\t\tdraco._free( ptr );\r\n\r\n\t\treturn {\r\n\t\t\tname: attributeName,\r\n\t\t\tarray: array,\r\n\t\t\titemSize: numComponents\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction getDracoDataType( draco, attributeType ) {\r\n\r\n\t\tswitch ( attributeType ) {\r\n\r\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\r\n\t\t\tcase Int8Array: return draco.DT_INT8;\r\n\t\t\tcase Int16Array: return draco.DT_INT16;\r\n\t\t\tcase Int32Array: return draco.DT_INT32;\r\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\r\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\r\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { DRACOLoader };\r\n"],
  "mappings": ";;;;;;;;;;;;AAWA,IAAM,aAAa,oBAAI,QAAQ;AAE/B,IAAM,cAAN,cAA0B,OAAO;AAAA,EAEhC,YAAa,SAAU;AAEtB,UAAO,OAAQ;AAEf,SAAK,cAAc;AACnB,SAAK,gBAAgB,CAAC;AACtB,SAAK,gBAAgB;AACrB,SAAK,iBAAiB;AAEtB,SAAK,cAAc;AACnB,SAAK,aAAa,CAAC;AACnB,SAAK,mBAAmB;AACxB,SAAK,kBAAkB;AAEvB,SAAK,sBAAsB;AAAA,MAC1B,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,IAAI;AAAA,IACL;AACA,SAAK,wBAAwB;AAAA,MAC5B,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,IAAI;AAAA,IACL;AAAA,EAED;AAAA,EAEA,eAAgB,MAAO;AAEtB,SAAK,cAAc;AAEnB,WAAO;AAAA,EAER;AAAA,EAEA,iBAAkB,QAAS;AAE1B,SAAK,gBAAgB;AAErB,WAAO;AAAA,EAER;AAAA,EAEA,eAAgB,aAAc;AAE7B,SAAK,cAAc;AAEnB,WAAO;AAAA,EAER;AAAA,EAEA,KAAM,KAAK,QAAQ,YAAY,SAAU;AAExC,UAAM,SAAS,IAAI,WAAY,KAAK,OAAQ;AAE5C,WAAO,QAAS,KAAK,IAAK;AAC1B,WAAO,gBAAiB,aAAc;AACtC,WAAO,iBAAkB,KAAK,aAAc;AAC5C,WAAO,mBAAoB,KAAK,eAAgB;AAEhD,WAAO,KAAM,KAAK,CAAE,WAAY;AAE/B,WAAK,MAAO,QAAQ,QAAQ,OAAQ;AAAA,IAErC,GAAG,YAAY,OAAQ;AAAA,EAExB;AAAA,EAGA,MAAO,QAAQ,QAAQ,UAAU,MAAI;AAAA,EAAC,GAAI;AAEzC,SAAK,gBAAiB,QAAQ,QAAQ,MAAM,MAAM,gBAAgB,OAAQ,EAAE,MAAO,OAAQ;AAAA,EAE5F;AAAA,EAEA,gBAAiB,QAAQ,UAAU,cAAc,gBAAgB,mBAAmB,sBAAsB,UAAU,MAAM;AAAA,EAAC,GAAI;AAE9H,UAAM,aAAa;AAAA,MAClB,cAAc,gBAAgB,KAAK;AAAA,MACnC,gBAAgB,kBAAkB,KAAK;AAAA,MACvC,cAAc,CAAC,CAAE;AAAA,MACjB;AAAA,IACD;AAEA,WAAO,KAAK,eAAgB,QAAQ,UAAW,EAAE,KAAM,QAAS,EAAE,MAAO,OAAQ;AAAA,EAElF;AAAA,EAEA,eAAgB,QAAQ,YAAa;AAEpC,UAAM,UAAU,KAAK,UAAW,UAAW;AAI3C,QAAK,WAAW,IAAK,MAAO,GAAI;AAE/B,YAAM,aAAa,WAAW,IAAK,MAAO;AAE1C,UAAK,WAAW,QAAQ,SAAU;AAEjC,eAAO,WAAW;AAAA,MAEnB,WAAY,OAAO,eAAe,GAAI;AAMrC,cAAM,IAAI;AAAA,UAET;AAAA,QAGD;AAAA,MAED;AAAA,IAED;AAIA,QAAI;AACJ,UAAM,SAAS,KAAK;AACpB,UAAM,WAAW,OAAO;AAIxB,UAAM,kBAAkB,KAAK,WAAY,QAAQ,QAAS,EACxD,KAAM,CAAE,YAAa;AAErB,eAAS;AAET,aAAO,IAAI,QAAS,CAAE,SAAS,WAAY;AAE1C,eAAO,WAAY,MAAO,IAAI,EAAE,SAAS,OAAO;AAEhD,eAAO,YAAa,EAAE,MAAM,UAAU,IAAI,QAAQ,YAAY,OAAO,GAAG,CAAE,MAAO,CAAE;AAAA,MAIpF,CAAE;AAAA,IAEH,CAAE,EACD,KAAM,CAAE,YAAa,KAAK,gBAAiB,QAAQ,QAAS,CAAE;AAIhE,oBACE,MAAO,MAAM,IAAK,EAClB,KAAM,MAAM;AAEZ,UAAK,UAAU,QAAS;AAEvB,aAAK,aAAc,QAAQ,MAAO;AAAA,MAInC;AAAA,IAED,CAAE;AAGH,eAAW,IAAK,QAAQ;AAAA,MAEvB,KAAK;AAAA,MACL,SAAS;AAAA,IAEV,CAAE;AAEF,WAAO;AAAA,EAER;AAAA,EAEA,gBAAiB,cAAe;AAE/B,UAAM,WAAW,IAAI,eAAe;AAEpC,QAAK,aAAa,OAAQ;AAEzB,eAAS,SAAU,IAAI,gBAAiB,aAAa,MAAM,OAAO,CAAE,CAAE;AAAA,IAEvE;AAEA,aAAU,IAAI,GAAG,IAAI,aAAa,WAAW,QAAQ,KAAO;AAE3D,YAAM,SAAS,aAAa,WAAY,CAAE;AAC1C,YAAM,OAAO,OAAO;AACpB,YAAM,QAAQ,OAAO;AACrB,YAAM,WAAW,OAAO;AAExB,YAAM,YAAY,IAAI,gBAAiB,OAAO,QAAS;AAEvD,UAAK,SAAS,SAAU;AAEvB,aAAK,wBAAyB,WAAW,OAAO,gBAAiB;AAEjE,kBAAU,aAAe,iBAAiB,iBAAmB;AAAA,MAE9D;AAEA,eAAS,aAAc,MAAM,SAAU;AAAA,IAExC;AAEA,WAAO;AAAA,EAER;AAAA,EAEA,wBAAyB,WAAW,iBAAkB;AAOrD,QAAK,oBAAoB,eAAiB;AAE1C,UAAM,SAAS,IAAI,MAAM;AAEzB,aAAU,IAAI,GAAG,KAAK,UAAU,OAAO,IAAI,IAAI,KAAO;AAErD,aAAO,oBAAqB,WAAW,CAAE;AACzC,sBAAgB,oBAAqB,QAAQ,cAAe;AAC5D,gBAAU,OAAQ,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,CAAE;AAAA,IAEnD;AAAA,EAED;AAAA,EAEA,aAAc,KAAK,cAAe;AAEjC,UAAM,SAAS,IAAI,WAAY,KAAK,OAAQ;AAC5C,WAAO,QAAS,KAAK,WAAY;AACjC,WAAO,gBAAiB,YAAa;AACrC,WAAO,mBAAoB,KAAK,eAAgB;AAEhD,WAAO,IAAI,QAAS,CAAE,SAAS,WAAY;AAE1C,aAAO,KAAM,KAAK,SAAS,QAAW,MAAO;AAAA,IAE9C,CAAE;AAAA,EAEH;AAAA,EAEA,UAAU;AAET,SAAK,aAAa;AAElB,WAAO;AAAA,EAER;AAAA,EAEA,eAAe;AAEd,QAAK,KAAK,eAAiB,QAAO,KAAK;AAEvC,UAAM,QAAQ,OAAO,gBAAgB,YAAY,KAAK,cAAc,SAAS;AAC7E,UAAM,mBAAmB,CAAC;AAE1B,QAAK,OAAQ;AAEZ,uBAAiB,KAAM,KAAK,aAAc,oBAAoB,MAAO,CAAE;AAAA,IAExE,OAAO;AAEN,uBAAiB,KAAM,KAAK,aAAc,yBAAyB,MAAO,CAAE;AAC5E,uBAAiB,KAAM,KAAK,aAAc,sBAAsB,aAAc,CAAE;AAAA,IAEjF;AAEA,SAAK,iBAAiB,QAAQ,IAAK,gBAAiB,EAClD,KAAM,CAAE,cAAe;AAEvB,YAAM,YAAY,UAAW,CAAE;AAE/B,UAAK,CAAE,OAAQ;AAEd,aAAK,cAAc,aAAa,UAAW,CAAE;AAAA,MAE9C;AAEA,YAAM,KAAK,YAAY,SAAS;AAEhC,YAAM,OAAO;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG,UAAW,GAAG,QAAS,GAAI,IAAI,GAAG,GAAG,YAAa,GAAI,CAAE;AAAA,MAC5D,EAAE,KAAM,IAAK;AAEb,WAAK,kBAAkB,IAAI,gBAAiB,IAAI,KAAM,CAAE,IAAK,CAAE,CAAE;AAAA,IAElE,CAAE;AAEH,WAAO,KAAK;AAAA,EAEb;AAAA,EAEA,WAAY,QAAQ,UAAW;AAE9B,WAAO,KAAK,aAAa,EAAE,KAAM,MAAM;AAEtC,UAAK,KAAK,WAAW,SAAS,KAAK,aAAc;AAEhD,cAAMA,UAAS,IAAI,OAAQ,KAAK,eAAgB;AAEhD,QAAAA,QAAO,aAAa,CAAC;AACrB,QAAAA,QAAO,aAAa,CAAC;AACrB,QAAAA,QAAO,YAAY;AAEnB,QAAAA,QAAO,YAAa,EAAE,MAAM,QAAQ,eAAe,KAAK,cAAc,CAAE;AAExE,QAAAA,QAAO,YAAY,SAAW,GAAI;AAEjC,gBAAM,UAAU,EAAE;AAElB,kBAAS,QAAQ,MAAO;AAAA,YAEvB,KAAK;AACJ,cAAAA,QAAO,WAAY,QAAQ,EAAG,EAAE,QAAS,OAAQ;AACjD;AAAA,YAED,KAAK;AACJ,cAAAA,QAAO,WAAY,QAAQ,EAAG,EAAE,OAAQ,OAAQ;AAChD;AAAA,YAED;AACC,sBAAQ,MAAO,6CAA6C,QAAQ,OAAO,GAAI;AAAA,UAEjF;AAAA,QAED;AAEA,aAAK,WAAW,KAAMA,OAAO;AAAA,MAE9B,OAAO;AAEN,aAAK,WAAW,KAAM,SAAW,GAAG,GAAI;AAEvC,iBAAO,EAAE,YAAY,EAAE,YAAY,KAAM;AAAA,QAE1C,CAAE;AAAA,MAEH;AAEA,YAAM,SAAS,KAAK,WAAY,KAAK,WAAW,SAAS,CAAE;AAC3D,aAAO,WAAY,MAAO,IAAI;AAC9B,aAAO,aAAa;AACpB,aAAO;AAAA,IAER,CAAE;AAAA,EAEH;AAAA,EAEA,aAAc,QAAQ,QAAS;AAE9B,WAAO,aAAa,OAAO,WAAY,MAAO;AAC9C,WAAO,OAAO,WAAY,MAAO;AACjC,WAAO,OAAO,WAAY,MAAO;AAAA,EAElC;AAAA,EAEA,QAAQ;AAEP,YAAQ,IAAK,eAAe,KAAK,WAAW,IAAK,CAAE,WAAY,OAAO,SAAU,CAAE;AAAA,EAEnF;AAAA,EAEA,UAAU;AAET,aAAU,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,EAAG,GAAI;AAEnD,WAAK,WAAY,CAAE,EAAE,UAAU;AAAA,IAEhC;AAEA,SAAK,WAAW,SAAS;AAEzB,QAAK,KAAK,oBAAoB,IAAK;AAElC,UAAI,gBAAiB,KAAK,eAAgB;AAAA,IAE3C;AAEA,WAAO;AAAA,EAER;AAED;AAIA,SAAS,cAAc;AAEtB,MAAI;AACJ,MAAI;AAEJ,cAAY,SAAW,GAAI;AAE1B,UAAM,UAAU,EAAE;AAElB,YAAS,QAAQ,MAAO;AAAA,MAEvB,KAAK;AACJ,wBAAgB,QAAQ;AACxB,yBAAiB,IAAI,QAAS,SAAW,SAAsB;AAE9D,wBAAc,iBAAiB,SAAW,OAAQ;AAGjD,oBAAS,EAAE,MAAa,CAAE;AAAA,UAE3B;AAEA,6BAAoB,aAAc;AAAA,QAEnC,CAAE;AACF;AAAA,MAED,KAAK;AACJ,cAAM,SAAS,QAAQ;AACvB,cAAM,aAAa,QAAQ;AAC3B,uBAAe,KAAM,CAAE,WAAY;AAElC,gBAAM,QAAQ,OAAO;AACrB,gBAAM,UAAU,IAAI,MAAM,QAAQ;AAElC,cAAI;AAEH,kBAAM,WAAW,eAAgB,OAAO,SAAS,IAAI,UAAW,MAAO,GAAG,UAAW;AAErF,kBAAM,UAAU,SAAS,WAAW,IAAK,CAAE,SAAU,KAAK,MAAM,MAAO;AAEvE,gBAAK,SAAS,MAAQ,SAAQ,KAAM,SAAS,MAAM,MAAM,MAAO;AAEhE,iBAAK,YAAa,EAAE,MAAM,UAAU,IAAI,QAAQ,IAAI,SAAS,GAAG,OAAQ;AAAA,UAEzE,SAAU,OAAQ;AAEjB,oBAAQ,MAAO,KAAM;AAErB,iBAAK,YAAa,EAAE,MAAM,SAAS,IAAI,QAAQ,IAAI,OAAO,MAAM,QAAQ,CAAE;AAAA,UAE3E,UAAE;AAED,kBAAM,QAAS,OAAQ;AAAA,UAExB;AAAA,QAED,CAAE;AACF;AAAA,IAEF;AAAA,EAED;AAEA,WAAS,eAAgB,OAAO,SAAS,OAAO,YAAa;AAE5D,UAAM,eAAe,WAAW;AAChC,UAAM,iBAAiB,WAAW;AAElC,QAAI;AACJ,QAAI;AAEJ,UAAM,eAAe,QAAQ,uBAAwB,KAAM;AAE3D,QAAK,iBAAiB,MAAM,iBAAkB;AAE7C,sBAAgB,IAAI,MAAM,KAAK;AAC/B,uBAAiB,QAAQ,kBAAmB,OAAO,MAAM,YAAY,aAAc;AAAA,IAEpF,WAAY,iBAAiB,MAAM,aAAc;AAEhD,sBAAgB,IAAI,MAAM,WAAW;AACrC,uBAAiB,QAAQ,wBAAyB,OAAO,MAAM,YAAY,aAAc;AAAA,IAE1F,OAAO;AAEN,YAAM,IAAI,MAAO,8CAA+C;AAAA,IAEjE;AAEA,QAAK,CAAE,eAAe,GAAG,KAAK,cAAc,QAAQ,GAAI;AAEvD,YAAM,IAAI,MAAO,yCAAyC,eAAe,UAAU,CAAE;AAAA,IAEtF;AAEA,UAAM,WAAW,EAAE,OAAO,MAAM,YAAY,CAAC,EAAE;AAG/C,eAAY,iBAAiB,cAAe;AAE3C,YAAM,gBAAgB,KAAM,eAAgB,aAAc,CAAE;AAE5D,UAAI;AACJ,UAAI;AAMJ,UAAK,WAAW,cAAe;AAE9B,sBAAc,aAAc,aAAc;AAC1C,oBAAY,QAAQ,uBAAwB,eAAe,WAAY;AAAA,MAExE,OAAO;AAEN,sBAAc,QAAQ,eAAgB,eAAe,MAAO,aAAc,aAAc,CAAE,CAAE;AAE5F,YAAK,gBAAgB,GAAM;AAE3B,oBAAY,QAAQ,aAAc,eAAe,WAAY;AAAA,MAE9D;AAEA,YAAM,kBAAkB,gBAAiB,OAAO,SAAS,eAAe,eAAe,eAAe,SAAU;AAEhH,UAAK,kBAAkB,SAAU;AAEhC,wBAAgB,mBAAmB,WAAW;AAAA,MAE/C;AAEA,eAAS,WAAW,KAAM,eAAgB;AAAA,IAE3C;AAGA,QAAK,iBAAiB,MAAM,iBAAkB;AAE7C,eAAS,QAAQ,YAAa,OAAO,SAAS,aAAc;AAAA,IAE7D;AAEA,UAAM,QAAS,aAAc;AAE7B,WAAO;AAAA,EAER;AAEA,WAAS,YAAa,OAAO,SAAS,eAAgB;AAErD,UAAM,WAAW,cAAc,UAAU;AACzC,UAAM,aAAa,WAAW;AAC9B,UAAM,aAAa,aAAa;AAEhC,UAAM,MAAM,MAAM,QAAS,UAAW;AACtC,YAAQ,wBAAyB,eAAe,YAAY,GAAI;AAChE,UAAM,QAAQ,IAAI,YAAa,MAAM,QAAQ,QAAQ,KAAK,UAAW,EAAE,MAAM;AAC7E,UAAM,MAAO,GAAI;AAEjB,WAAO,EAAE,OAAO,OAAO,UAAU,EAAE;AAAA,EAEpC;AAEA,WAAS,gBAAiB,OAAO,SAAS,eAAe,eAAe,eAAe,WAAY;AAElG,UAAM,gBAAgB,UAAU,eAAe;AAC/C,UAAM,YAAY,cAAc,WAAW;AAC3C,UAAM,YAAY,YAAY;AAC9B,UAAM,aAAa,YAAY,cAAc;AAC7C,UAAM,WAAW,iBAAkB,OAAO,aAAc;AAExD,UAAM,MAAM,MAAM,QAAS,UAAW;AACtC,YAAQ,kCAAmC,eAAe,WAAW,UAAU,YAAY,GAAI;AAC/F,UAAM,QAAQ,IAAI,cAAe,MAAM,QAAQ,QAAQ,KAAK,SAAU,EAAE,MAAM;AAC9E,UAAM,MAAO,GAAI;AAEjB,WAAO;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU;AAAA,IACX;AAAA,EAED;AAEA,WAAS,iBAAkB,OAAO,eAAgB;AAEjD,YAAS,eAAgB;AAAA,MAExB,KAAK;AAAc,eAAO,MAAM;AAAA,MAChC,KAAK;AAAW,eAAO,MAAM;AAAA,MAC7B,KAAK;AAAY,eAAO,MAAM;AAAA,MAC9B,KAAK;AAAY,eAAO,MAAM;AAAA,MAC9B,KAAK;AAAY,eAAO,MAAM;AAAA,MAC9B,KAAK;AAAa,eAAO,MAAM;AAAA,MAC/B,KAAK;AAAa,eAAO,MAAM;AAAA,IAEhC;AAAA,EAED;AAED;",
  "names": ["worker"]
}
