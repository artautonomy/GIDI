{
  "version": 3,
  "sources": ["../../@threlte/core/dist/context/fragments/cache.js", "../../@threlte/core/dist/utilities/observe.svelte.js", "../../@threlte/core/dist/utilities/isInstanceOf.js", "../../@threlte/core/dist/utilities/asyncWritable.js", "../../@threlte/core/dist/utilities/browser.js", "../../@threlte/core/dist/utilities/revision.js", "../../@threlte/core/dist/utilities/watch.js", "../../@threlte/core/dist/utilities/currentWritable.js", "../../@threlte/core/dist/utilities/resolvePropertyPath.js", "../../@threlte/core/dist/context/fragments/canvas.js", "../../@threlte/core/dist/frame-scheduling/DAG.js", "../../@threlte/core/dist/frame-scheduling/Task.js", "../../@threlte/core/dist/frame-scheduling/Stage.js", "../../@threlte/core/dist/frame-scheduling/Scheduler.js", "../../@threlte/core/dist/context/fragments/scheduler.svelte.js", "../../@threlte/core/dist/context/fragments/camera.js", "../../@threlte/core/dist/context/fragments/disposal.js", "../../@threlte/core/dist/context/fragments/parent.js", "../../@threlte/core/dist/context/fragments/parentObject3D.js", "../../@threlte/core/dist/hooks/useTask.js", "../../@threlte/core/dist/context/fragments/scene.js", "../../@threlte/core/dist/context/fragments/renderer.svelte.js", "../../@threlte/core/dist/context/fragments/user.js", "../../@threlte/core/dist/context/createThrelteContext.svelte.js", "../../@threlte/core/dist/components/Context/Context.svelte", "../../@threlte/core/dist/Canvas.svelte", "../../@threlte/core/dist/context/compounds/useThrelte.js", "../../@threlte/core/dist/components/T/utils/useAttach.js", "../../@threlte/core/dist/components/T/utils/useCamera.js", "../../@threlte/core/dist/components/T/utils/useCreateEvent.js", "../../@threlte/core/dist/components/T/utils/useDispose.js", "../../@threlte/core/dist/components/T/utils/useEvents.js", "../../@threlte/core/dist/components/T/utils/useIs.js", "../../@threlte/core/dist/components/T/utils/usePlugins.js", "../../@threlte/core/dist/components/T/utils/useProps.js", "../../@threlte/core/dist/components/T/utils/utils.js", "../../@threlte/core/dist/components/T/T.svelte", "../../@threlte/core/dist/components/T/T.js", "../../@threlte/core/dist/plugins/injectPlugin.js", "../../@threlte/core/dist/hooks/useStage.js", "../../@threlte/core/dist/hooks/useThrelteUserContext.js", "../../@threlte/core/dist/hooks/useLoader.js", "../../@threlte/core/dist/index.js"],
  "sourcesContent": ["import { getContext, setContext } from 'svelte';\nexport const shallowEqualArrays = (arrA, arrB) => {\n    if (arrA === arrB)\n        return true;\n    if (!arrA || !arrB)\n        return false;\n    const len = arrA.length;\n    if (arrB.length !== len)\n        return false;\n    for (let i = 0; i < len; i++)\n        if (arrA[i] !== arrB[i])\n            return false;\n    return true;\n};\n/**\n * ### `createCacheContext`\n *\n * Every Threlte application has its own cache. This prevents models from being\n * shared between applications because e.g. THREE.Mesh objects cannot be mounted\n * in multiple scenes.\n */\nexport const createCacheContext = () => {\n    const items = [];\n    const remember = (callback, keys) => {\n        for (let i = 0; i < items.length; i++) {\n            const entry = items[i];\n            if (shallowEqualArrays(keys, entry.keys)) {\n                if (entry.promise)\n                    return entry.promise;\n            }\n        }\n        // If no match was found, create a new entry\n        const entry = {\n            promise: callback(),\n            keys\n        };\n        // Add the entry to the cache\n        items.push(entry);\n        // Return the promise\n        return entry.promise;\n    };\n    const clear = (keys) => {\n        for (let i = 0; i < items.length; i++) {\n            const entry = items[i];\n            if (shallowEqualArrays(keys, entry.keys)) {\n                items.splice(i, 1);\n                return;\n            }\n        }\n    };\n    const context = { items, remember, clear };\n    setContext('threlte-cache', context);\n    return context;\n};\n/**\n * ### `useCache`\n *\n * This hook is used to access the cache. It returns a `remember` function that\n * can be used to cache a promise based on the provided keys. The `remember`\n * function will return the cached value if the promise has already been\n * resolved and the keys match.\n *\n * @example\n * ```ts\n * const { remember } = useCache()\n *\n * const asnycWritable = remember(async () => {\n *  const loader = new GLTFLoader()\n *  const { scene } = await loader.loadAsync('/path/to/model.glb')\n *  return scene\n * })\n * ```\n *\n * The model will only be loaded once, even if `remember` is invoked multiple\n * times with the same keys.\n *\n * The `clear` function can be used to clear the cache for a specific set of keys.\n */\nexport const useCache = () => {\n    const cache = getContext('threlte-cache');\n    if (!cache) {\n        throw new Error('No cache found. The cache can only be used in a child component to <Canvas>.');\n    }\n    return cache;\n};\n", "import { untrack } from 'svelte';\nimport { fromStore } from 'svelte/store';\nconst signal = Symbol();\nconst isStore = (dep) => {\n    return typeof dep?.subscribe === 'function';\n};\nconst runObserve = (dependencies, callback, pre) => {\n    const stores = dependencies().map((d) => {\n        if (isStore(d)) {\n            return fromStore(d);\n        }\n        return signal;\n    });\n    const deps = $derived(dependencies().map((d, i) => {\n        if (stores[i] === signal)\n            return d;\n        return stores[i].current;\n    }));\n    const effect = () => {\n        deps;\n        let cleanup = undefined;\n        untrack(() => {\n            cleanup = callback(deps);\n        });\n        return cleanup;\n    };\n    if (pre) {\n        $effect.pre(effect);\n    }\n    else {\n        $effect(effect);\n    }\n};\n/**\n * ### `observe`\n *\n * Observe multiple stores and reactive values and call a callback when they\n * change to trigger side effects. The callback can return a cleanup function\n * that will be called when the dependencies change again or when the effect\n * root (most likely a component) is destroyed. Under the hood, `observe` uses\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\n * version that uses `$effect.pre`, use `observe.pre`.\n *\n * ```ts\n * const count = writable(0)\n * let name = $state('John')\n *\n * observe(() => [count, name], ([count, name]) => {\n *  console.log(count, name) // 0 John\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the\n * dependencies change again or when the component is destroyed.\n *\n * ```ts\n * const count = writable(0)\n *\n * observe(() => [count], ([count]) => {\n *  console.log(count) // 0\n *  return () => {\n *    console.log('cleanup')\n *  }\n * })\n * ```\n *\n * @param dependencies - A function that returns an array of dependencies.\n * @param callback - A function that will be called with the current values of\n * the dependencies. The callback can return a cleanup function that will be\n * called when the dependencies change again or when the component is destroyed.\n */\nconst observePost = (dependencies, callback) => {\n    return runObserve(dependencies, callback, false);\n};\n/**\n * ### `observe.pre`\n *\n * Observe multiple stores and reactive values and call a callback when they\n * change to trigger side effects. The callback can return a cleanup function\n * that will be called when the dependencies change again or when the effect\n * root (most likely a component) is destroyed. Under the hood, `observe.pre` uses\n * Svelte's `$effect` to track dependencies and trigger the callback. For a\n * version that uses `$effect`, use `observe`.\n *\n * ```ts\n * const count = writable(0)\n * let name = $state('John')\n *\n * observe.pre(() => [count, name], ([count, name]) => {\n *  console.log(count, name) // 0 John\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the\n * dependencies change again or when the component is destroyed.\n *\n * ```ts\n * const count = writable(0)\n *\n * observe.pre(() => [count], ([count]) => {\n *  console.log(count) // 0\n *  return () => {\n *    console.log('cleanup')\n *  }\n * })\n * ```\n *\n * @param dependencies - A function that returns an array of dependencies.\n * @param callback - A function that will be called with the current values of\n * the dependencies. The callback can return a cleanup function that will be\n * called when the dependencies change again or when the component is destroyed.\n */\nconst observePre = (dependencies, callback) => {\n    return runObserve(dependencies, callback, true);\n};\nexport const observe = Object.assign(observePost, { pre: observePre });\n", "/**\n * Check if an object is an instance of a given THREE class. Can be used as a\n * type guard and as an alternative to `instanceof` which is prone to error and\n * slower. It uses the `isFoo` property that THREE classes have to determine if\n * an object is of a particular class.\n *\n * @example\n * ```ts\n * const obj = new THREE.Object3D()\n * isInstanceOf(obj, 'Object3D') // true\n * ```\n *\n * @param obj - The object to check.\n * @param type - The class name to check against.\n * @returns `true` if the object is an instance of the class, `false` otherwise.\n */\nexport const isInstanceOf = (obj, type) => {\n    return obj?.[`is${type}`] === true;\n};\n", "import { writable } from 'svelte/store';\n/**\n * ### `asyncWritable`\n *\n * Creates a writable store that is initialized with a promise. The store also\n * implements the `then` and `catch` methods of the promise so that it can be\n * used in `await` expressions and `{#await}` blocks of Svelte.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    // Do something async\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  $: console.log($store) // asyncOp result\n * </script>\n *\n * <h1>\n *  {#await store then data}\n *    // Do something with the data\n *  {/await}\n * </h1>\n * ```\n *\n * If an error occurs in the promise, the error will be logged to the console\n * and the error can be accessed via the `error` property of the store with in\n * turn is a store.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    throw new Error('Something went wrong')\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  const error = store.error\n *\n *  $: console.log($store) // undefined\n *  $: console.log($error) // Error: Something went wrong\n * </script>\n * ```\n */\nexport const asyncWritable = (promise) => {\n    const store = writable(undefined);\n    const error = writable(undefined);\n    promise\n        .then((result) => {\n        store.set(result);\n    })\n        .catch((e) => {\n        console.error('Error in asyncWritable:', e.message);\n        error.set(e);\n    });\n    return Object.assign(Object.assign(promise, store), { error, promise });\n};\n", "export const browser = typeof window !== 'undefined';\n", "import { REVISION } from 'three';\n// REVISION can be '{number}' or '{number}dev'\nconst normalizedRevision = REVISION.replace('dev', '');\n/**\n * The current Three.js revision.\n */\nexport const revision = Number.parseInt(normalizedRevision);\n", "import { onDestroy } from 'svelte';\nimport { derived } from 'svelte/store';\n/**\n * ### `watch`\n *\n * Watch a single store or multiple stores and call a callback when they change to trigger side effects.\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * })\n * ```\n *\n * You can also watch multiple stores:\n *\n * ```ts\n * const store1 = writable(0)\n * const store2 = writable(1)\n *\n * watch([store1, store2], ([value1, value2]) => {\n * \tconsole.log(value1, value2) // 0 1\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * \treturn () => {\n * \t\tconsole.log('cleanup')\n * \t}\n * })\n * ```\n *\n * @param stores\n * @param callback\n */\nexport const watch = (stores, callback) => {\n    const d = derived(stores, (values) => {\n        return values;\n    });\n    let cleanupFn;\n    const unsubscribe = d.subscribe(async (values) => {\n        if (cleanupFn)\n            cleanupFn();\n        const fn = await callback(values);\n        if (fn)\n            cleanupFn = fn;\n    });\n    onDestroy(() => {\n        unsubscribe();\n        if (cleanupFn)\n            cleanupFn();\n    });\n};\n", "import { writable } from 'svelte/store';\n/**\n * ### `currentWritable`\n *\n * A writable store that also has a `current` property that is updated synchronously.\n * For use in non-reactive contexts e.g. loops where unwrapping a store every frame is expensive.\n *\n * ```ts\n * const store = currentWritable(0)\n *\n * useTask(() => {\n * \tconsole.log(store.current) // 0\n * })\n *\n * @param value\n * @returns\n */\nexport const currentWritable = (value) => {\n    const store = writable(value);\n    const extendedWritable = {\n        set: (value) => {\n            extendedWritable.current = value;\n            store.set(value);\n        },\n        subscribe: store.subscribe,\n        update: (fn) => {\n            const newValue = fn(extendedWritable.current);\n            extendedWritable.current = newValue;\n            store.set(newValue);\n        },\n        current: value\n    };\n    return extendedWritable;\n};\nexport const toCurrentReadable = (store) => {\n    return {\n        subscribe: store.subscribe,\n        get current() {\n            return store.current;\n        }\n    };\n};\n", "/**\n * ### `resolvePropertyPath`\n *\n * This function resolves a property path to a target object and the property\n * key. The property path can include dots to indicate nested objects.\n *\n *  ```ts\n * const object = { position: { x: 0 } }\n * const { target, key } = resolvePropertyPath(object, 'position.x')\n *\n * // target is { x: 0 }\n * // key is 'x'\n * ```\n */\nexport const resolvePropertyPath = (target, propertyPath) => {\n    if (propertyPath.includes('.')) {\n        const path = propertyPath.split('.');\n        const key = path.pop();\n        for (let i = 0; i < path.length; i += 1) {\n            target = target[path[i]];\n        }\n        return {\n            target,\n            key\n        };\n    }\n    else {\n        return {\n            target,\n            key: propertyPath\n        };\n    }\n};\n", "import { getContext, onMount, setContext } from 'svelte';\nimport { currentWritable, toCurrentReadable } from '../../utilities';\nexport const createCanvasContext = (options) => {\n    const wrapperRect = options.wrapper.getBoundingClientRect();\n    let lastWidth = wrapperRect.width;\n    let lastHeight = wrapperRect.height;\n    const size = currentWritable({ width: wrapperRect.width, height: wrapperRect.height });\n    onMount(() => {\n        const resizeObserver = new ResizeObserver((entries) => {\n            for (const entry of entries) {\n                const { width, height } = entry.contentRect;\n                if (width === lastWidth && height === lastHeight)\n                    return;\n                lastWidth = width;\n                lastHeight = height;\n                size.set({ width, height });\n            }\n        });\n        resizeObserver.observe(options.wrapper);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    });\n    const context = {\n        wrapper: options.wrapper,\n        canvas: options.canvas,\n        size: toCurrentReadable(size)\n    };\n    setContext('threlte-canvas-context', context);\n    return context;\n};\nexport const useCanvas = () => {\n    const context = getContext('threlte-canvas-context');\n    if (!context) {\n        throw new Error('useCanvas can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import mitt from 'mitt';\nexport class DAG {\n    allVertices = {};\n    /** Nodes that are fully unlinked */\n    isolatedVertices = {};\n    connectedVertices = {};\n    sortedConnectedValues = [];\n    needsSort = false;\n    emitter = mitt();\n    emit = this.emitter.emit.bind(this.emitter);\n    on = this.emitter.on.bind(this.emitter);\n    off = this.emitter.off.bind(this.emitter);\n    get sortedVertices() {\n        return this.mapNodes((value) => value);\n    }\n    moveToIsolated(key) {\n        const vertex = this.connectedVertices[key];\n        if (!vertex)\n            return;\n        this.isolatedVertices[key] = vertex;\n        delete this.connectedVertices[key];\n    }\n    moveToConnected(key) {\n        const vertex = this.isolatedVertices[key];\n        if (!vertex)\n            return;\n        this.connectedVertices[key] = vertex;\n        delete this.isolatedVertices[key];\n    }\n    getKey = (v) => {\n        if (typeof v === 'object') {\n            return v.key;\n        }\n        return v;\n    };\n    add(key, value, options) {\n        if (this.allVertices[key] && this.allVertices[key].value !== undefined) {\n            throw new Error(`A node with the key ${key.toString()} already exists`);\n        }\n        let vertex = this.allVertices[key];\n        if (!vertex) {\n            vertex = {\n                value: value,\n                previous: new Set(),\n                next: new Set()\n            };\n            // add the vertex to the list of all vertices\n            this.allVertices[key] = vertex;\n        }\n        else if (vertex.value === undefined) {\n            vertex.value = value;\n        }\n        // if another node referenced this node before, we have inverse links\n        const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\n        if (!options?.after && !options?.before && !hasEdges) {\n            // the node we're about to add is fully unlinked\n            this.isolatedVertices[key] = vertex;\n            this.emit('node:added', {\n                key,\n                type: 'isolated',\n                value\n            });\n            return;\n        }\n        else {\n            this.connectedVertices[key] = vertex;\n        }\n        if (options?.after) {\n            const afterArr = Array.isArray(options.after) ? options.after : [options.after];\n            // we need to update the vertex to include the new \"after\" nodes\n            afterArr.forEach((after) => {\n                vertex.previous.add(this.getKey(after));\n            });\n            afterArr.forEach((after) => {\n                const afterKey = this.getKey(after);\n                // we get the vertex from the list of all vertices\n                const linkedAfter = this.allVertices[afterKey];\n                if (!linkedAfter) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[afterKey] = {\n                        value: undefined,\n                        previous: new Set(),\n                        next: new Set([key])\n                    };\n                    this.connectedVertices[afterKey] = this.allVertices[afterKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedAfter.next.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(afterKey);\n                }\n            });\n        }\n        if (options?.before) {\n            const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\n            // we need to update the vertex to include the new \"before\" nodes\n            beforeArr.forEach((before) => {\n                vertex.next.add(this.getKey(before));\n            });\n            beforeArr.forEach((before) => {\n                const beforeKey = this.getKey(before);\n                // we get the vertex from the list of all vertices\n                const linkedBefore = this.allVertices[beforeKey];\n                if (!linkedBefore) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[beforeKey] = {\n                        value: undefined,\n                        previous: new Set([key]),\n                        next: new Set()\n                    };\n                    this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedBefore.previous.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(beforeKey);\n                }\n            });\n        }\n        this.emit('node:added', {\n            key,\n            type: 'connected',\n            value\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    remove(key) {\n        const removeKey = this.getKey(key);\n        // check if it's an unlinked vertex\n        const unlinkedVertex = this.isolatedVertices[removeKey];\n        if (unlinkedVertex) {\n            delete this.isolatedVertices[removeKey];\n            delete this.allVertices[removeKey];\n            this.emit('node:removed', {\n                key: removeKey,\n                type: 'isolated'\n            });\n            return;\n        }\n        // if it's not, it's a bit more complicated\n        const linkedVertex = this.connectedVertices[removeKey];\n        if (!linkedVertex) {\n            // The node does not exist in the graph.\n            return;\n        }\n        // Update the 'next' nodes that this node points to\n        linkedVertex.next.forEach((nextKey) => {\n            const nextVertex = this.connectedVertices[nextKey];\n            if (nextVertex) {\n                nextVertex.previous.delete(removeKey);\n                if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\n                    this.moveToIsolated(nextKey);\n                }\n            }\n        });\n        // Update the 'previous' nodes that point to this node\n        linkedVertex.previous.forEach((prevKey) => {\n            const prevVertex = this.connectedVertices[prevKey];\n            if (prevVertex) {\n                prevVertex.next.delete(removeKey);\n                if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\n                    this.moveToIsolated(prevKey);\n                }\n            }\n        });\n        // Finally, remove the node from the graph\n        delete this.connectedVertices[removeKey];\n        delete this.allVertices[removeKey];\n        this.emit('node:removed', {\n            key: removeKey,\n            type: 'connected'\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    mapNodes(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        const result = [];\n        this.forEachNode((value, index) => {\n            result.push(callback(value, index));\n        });\n        return result;\n    }\n    forEachNode(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        let index = 0;\n        for (; index < this.sortedConnectedValues.length; index++) {\n            callback(this.sortedConnectedValues[index], index);\n        }\n        Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\n            const vertex = this.isolatedVertices[key];\n            if (vertex.value !== undefined)\n                callback(vertex.value, index++);\n        });\n    }\n    getValueByKey(key) {\n        return this.allVertices[key]?.value;\n    }\n    getKeyByValue(value) {\n        return (Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ??\n            Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value));\n    }\n    sort() {\n        const inDegree = new Map();\n        const zeroInDegreeQueue = [];\n        const result = [];\n        // we're only interested in vertices that have a value\n        const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\n            const vertex = this.connectedVertices[key];\n            return vertex.value !== undefined;\n        });\n        // Initialize inDegree (count of incoming edges) for each vertex\n        connectedVertexKeysWithValues.forEach((vertex) => {\n            inDegree.set(vertex, 0);\n        });\n        // Calculate inDegree for each vertex\n        connectedVertexKeysWithValues.forEach((vertexKey) => {\n            const vertex = this.connectedVertices[vertexKey];\n            vertex.next.forEach((next) => {\n                // check if \"next\" vertex has a value\n                const nextVertex = this.connectedVertices[next];\n                if (!nextVertex)\n                    return;\n                inDegree.set(next, (inDegree.get(next) || 0) + 1);\n            });\n        });\n        // Enqueue vertices with inDegree 0\n        inDegree.forEach((degree, value) => {\n            if (degree === 0) {\n                zeroInDegreeQueue.push(value);\n            }\n        });\n        // Process vertices with inDegree 0 and decrease inDegree of adjacent vertices\n        while (zeroInDegreeQueue.length > 0) {\n            const vertexKey = zeroInDegreeQueue.shift();\n            result.push(vertexKey);\n            const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\n            if (v) {\n                this.connectedVertices[v]?.next.forEach((adjVertex) => {\n                    const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\n                    inDegree.set(adjVertex, adjVertexInDegree);\n                    if (adjVertexInDegree === 0) {\n                        zeroInDegreeQueue.push(adjVertex);\n                    }\n                });\n            }\n        }\n        // Check for cycles in the graph\n        if (result.length !== connectedVertexKeysWithValues.length) {\n            throw new Error('The graph contains a cycle, and thus can not be sorted topologically.');\n        }\n        const filterUndefined = (value) => value !== undefined;\n        this.sortedConnectedValues = result\n            .map((key) => this.connectedVertices[key].value)\n            .filter(filterUndefined);\n        this.needsSort = false;\n    }\n    clear() {\n        this.allVertices = {};\n        this.isolatedVertices = {};\n        this.connectedVertices = {};\n        this.sortedConnectedValues = [];\n        this.needsSort = false;\n    }\n    static isKey(value) {\n        return typeof value === 'string' || typeof value === 'symbol';\n    }\n    static isValue(value) {\n        return typeof value === 'object' && 'key' in value;\n    }\n}\n", "export class Task {\n    key;\n    stage;\n    callback;\n    runTask = true;\n    stop() {\n        this.runTask = false;\n    }\n    start() {\n        this.runTask = true;\n    }\n    constructor(stage, key, callback) {\n        this.stage = stage;\n        this.key = key;\n        this.callback = callback;\n    }\n    run(delta) {\n        if (!this.runTask)\n            return;\n        this.callback(delta);\n    }\n}\n", "import { DAG } from './DAG';\nimport { Task } from './Task';\n/**\n * A Stage is a collection of steps. The steps are run in a topological sort\n * order.\n */\nexport class Stage extends DAG {\n    key;\n    scheduler;\n    runTask = true;\n    stop() {\n        this.runTask = false;\n    }\n    start() {\n        this.runTask = true;\n    }\n    get tasks() {\n        return this.sortedVertices;\n    }\n    callback = (_, r) => r();\n    constructor(scheduler, key, callback) {\n        super();\n        this.scheduler = scheduler;\n        this.key = key;\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        if (callback)\n            this.callback = callback.bind(this);\n    }\n    createTask(key, callback, options) {\n        const task = new Task(this, key, callback);\n        this.add(key, task, options);\n        return task;\n    }\n    getTask(key) {\n        return this.getValueByKey(key);\n    }\n    removeTask = this.remove.bind(this);\n    run(delta) {\n        if (!this.runTask)\n            return;\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                task.run(deltaOverride ?? delta);\n            });\n        });\n    }\n    runWithTiming(delta) {\n        if (!this.runTask)\n            return {};\n        const taskTimings = {};\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                const start = performance.now();\n                task.run(deltaOverride ?? delta);\n                const duration = performance.now() - start;\n                taskTimings[task.key] = duration;\n            });\n        });\n        return taskTimings;\n    }\n    getSchedule() {\n        return this.mapNodes((l) => l.key.toString());\n    }\n}\n", "import { DAG } from './DAG';\nimport { Stage } from './Stage';\n/**\n * A Scheduler is responsible for running stages. It runs the stages in a\n * requestAnimationFrame stage.\n */\nexport class Scheduler extends DAG {\n    lastTime = performance.now();\n    clampDeltaTo = 0.1;\n    get stages() {\n        return this.sortedVertices;\n    }\n    constructor(options) {\n        super();\n        if (options?.clampDeltaTo)\n            this.clampDeltaTo = options.clampDeltaTo;\n        this.run = this.run.bind(this);\n    }\n    createStage(key, options) {\n        const stage = new Stage(this, key, options?.callback);\n        this.add(key, stage, {\n            after: options?.after,\n            before: options?.before\n        });\n        return stage;\n    }\n    getStage(key) {\n        return this.getValueByKey(key);\n    }\n    removeStage = this.remove.bind(this);\n    /**\n     * Runs all the stages in the scheduler.\n     *\n     * @param time The time in milliseconds since the start of the program.\n     */\n    run(time) {\n        const delta = time - this.lastTime;\n        this.forEachNode((stage) => {\n            // we pass the delta as seconds, not milliseconds,\n            // this is in line with how Three.js, Unity and\n            // other game engines do it. On top of that, it\n            // needs to be clamped to prevent large delta\n            // values from causing large jumps in the game\n            // state.\n            stage.run(Math.min(delta / 1000, this.clampDeltaTo));\n        });\n        this.lastTime = time;\n    }\n    runWithTiming(time) {\n        const delta = time - this.lastTime;\n        const stageTimings = {};\n        const start = performance.now();\n        this.forEachNode((stage) => {\n            const start = performance.now();\n            const taskTimings = stage.runWithTiming(Math.min(delta / 1000, this.clampDeltaTo));\n            const duration = performance.now() - start;\n            stageTimings[stage.key.toString()] = {\n                duration,\n                tasks: taskTimings\n            };\n        });\n        return {\n            total: performance.now() - start,\n            stages: stageTimings\n        };\n    }\n    getSchedule(include = {\n        tasks: true\n    }) {\n        return {\n            stages: this.mapNodes((stage) => {\n                if (stage === undefined)\n                    throw new Error('Stage not found');\n                return {\n                    key: stage.key.toString(),\n                    ...{ tasks: include.tasks ? stage.getSchedule() : undefined }\n                };\n            })\n        };\n    }\n    dispose() {\n        this.clear();\n    }\n}\n", "import { getContext, onDestroy, setContext } from 'svelte';\nimport { currentWritable } from '../../utilities';\nimport { Scheduler } from '../../frame-scheduling';\nexport const createSchedulerContext = (options) => {\n    const scheduler = new Scheduler();\n    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));\n    const context = {\n        scheduler,\n        frameInvalidated: true,\n        autoInvalidations: new Set(),\n        shouldAdvance: false,\n        advance: () => {\n            context.shouldAdvance = true;\n        },\n        autoRender: currentWritable(options.autoRender ?? true),\n        renderMode: currentWritable(options.renderMode ?? 'on-demand'),\n        invalidate() {\n            context.frameInvalidated = true;\n        },\n        mainStage,\n        shouldRender: () => {\n            return (context.renderMode.current === 'always' ||\n                (context.renderMode.current === 'on-demand' &&\n                    (context.frameInvalidated || context.autoInvalidations.size > 0)) ||\n                (context.renderMode.current === 'manual' && context.shouldAdvance));\n        },\n        renderStage: scheduler.createStage(Symbol('threlte-render-stage'), {\n            after: mainStage,\n            callback(_, runTasks) {\n                if (context.shouldRender())\n                    runTasks();\n            }\n        }),\n        resetFrameInvalidation() {\n            context.frameInvalidated = false;\n            context.shouldAdvance = false;\n        }\n    };\n    $effect(() => {\n        context.autoRender.set(options.autoRender ?? true);\n    });\n    $effect(() => {\n        context.renderMode.set(options.renderMode ?? 'on-demand');\n    });\n    onDestroy(() => {\n        context.scheduler.dispose();\n    });\n    setContext('threlte-scheduler-context', context);\n    return context;\n};\nexport const useScheduler = () => {\n    const context = getContext('threlte-scheduler-context');\n    if (!context) {\n        throw new Error('useScheduler can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { PerspectiveCamera } from 'three';\nimport { currentWritable, watch } from '../../utilities';\nimport { useCanvas } from './canvas';\nimport { useScheduler } from './scheduler.svelte';\nexport const createCameraContext = () => {\n    const { size } = useCanvas();\n    const { invalidate } = useScheduler();\n    // Create a default camera to use when no camera is defined by the user\n    const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1000);\n    defaultCamera.position.z = 5;\n    defaultCamera.lookAt(0, 0, 0);\n    const camera = currentWritable(defaultCamera);\n    watch(size, (size) => {\n        if (camera.current === defaultCamera) {\n            const cam = camera.current;\n            cam.aspect = size.width / size.height;\n            cam.updateProjectionMatrix();\n            invalidate();\n        }\n    });\n    const context = { camera };\n    setContext('threlte-camera-context', context);\n    return context;\n};\nexport const useCamera = () => {\n    const context = getContext('threlte-camera-context');\n    if (!context) {\n        throw new Error('useCamera can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, onDestroy, setContext, tick } from 'svelte';\nexport const createDisposalContext = () => {\n    const context = {\n        removeObjectFromDisposal: (object) => {\n            context.disposableObjects.delete(object);\n        },\n        disposableObjectMounted: (object) => {\n            const currentValue = context.disposableObjects.get(object);\n            if (currentValue) {\n                context.disposableObjects.set(object, currentValue + 1);\n            }\n            else {\n                context.disposableObjects.set(object, 1);\n            }\n        },\n        disposableObjectUnmounted: (object) => {\n            const currentValue = context.disposableObjects.get(object);\n            if (currentValue && currentValue > 0) {\n                context.disposableObjects.set(object, currentValue - 1);\n                if (currentValue - 1 <= 0) {\n                    context.shouldDispose = true;\n                }\n            }\n        },\n        disposableObjects: new Map(),\n        shouldDispose: false,\n        dispose: async (force = false) => {\n            await tick();\n            if (!context.shouldDispose && !force)\n                return;\n            context.disposableObjects.forEach((mounted, object) => {\n                if (mounted === 0 || force) {\n                    object?.dispose?.();\n                    context.disposableObjects.delete(object);\n                }\n            });\n            context.shouldDispose = false;\n        }\n    };\n    onDestroy(() => {\n        context.dispose(true);\n    });\n    setContext('threlte-disposal-context', context);\n    return context;\n};\nexport const useDisposal = () => {\n    const context = getContext('threlte-disposal-context');\n    if (!context) {\n        throw new Error('useDisposal can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { currentWritable } from '../../utilities';\nconst parentContextKey = Symbol('threlte-parent-context');\n/**\n * The parent context is used to access the parent object created by a `<T>`\n * component.\n */\nexport const createParentContext = (parent) => {\n    const ctx = currentWritable(parent);\n    setContext(parentContextKey, ctx);\n    return ctx;\n};\n/**\n * The parent context is used to access the parent object created by a `<T>`\n * component.\n *\n * @example\n * ```svelte\n * <T.Mesh>\n *   <CustomComponent />\n * </T.Mesh>\n * ```\n *\n * The parent as retrieved inside the component `<CustomComponent>`\n * will be the mesh created by the `<T.Mesh>` component.\n */\nexport const useParent = () => {\n    const parent = getContext(parentContextKey);\n    return parent;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { derived, readable, writable } from 'svelte/store';\nconst parentObject3DContextKey = Symbol('threlte-parent-object3d-context');\nexport const createRootParentObject3DContext = (object) => {\n    const ctx = readable(object);\n    setContext(parentObject3DContextKey, ctx);\n    return ctx;\n};\n/**\n * The parentObject3D context is used to access the parent `THREE.Object3D`\n * created by a `<T>` component. The context is automatically merged with the\n * parentObject3D context of the parent component when the local context store\n * is `undefined`.\n */\nexport const createParentObject3DContext = (object) => {\n    const parentObject3D = getContext(parentObject3DContextKey);\n    const object3D = writable(object);\n    const ctx = derived([object3D, parentObject3D], ([object3D, parentObject3D]) => {\n        return object3D ?? parentObject3D;\n    });\n    setContext(parentObject3DContextKey, ctx);\n    return object3D;\n};\n/**\n * The parentObject3D context is used to access the parent `THREE.Object3D`\n * created by a `<T>` component.\n *\n * @example\n * ```svelte\n * <T.Mesh>\n *   <T.MeshStandardMaterial>\n *     <CustomComponent />\n *   </T.MeshStandardMaterial>\n * </T.Mesh>\n * ```\n *\n * The parentObject3D as retrieved inside the component `<CustomComponent>`\n * will be the mesh created by the `<T.Mesh>` component.\n */\nexport const useParentObject3D = () => {\n    return getContext(parentObject3DContextKey);\n};\n", "import { onDestroy } from 'svelte';\nimport { readable, writable } from 'svelte/store';\nimport { useScheduler } from '../context/fragments/scheduler.svelte';\nimport { DAG } from '../frame-scheduling';\nimport { browser } from '../utilities';\nexport function useTask(keyOrFn, fnOrOptions, options) {\n    if (!browser) {\n        return {\n            task: undefined,\n            start: () => undefined,\n            stop: () => undefined,\n            started: readable(false)\n        };\n    }\n    let key;\n    let fn;\n    let opts;\n    if (DAG.isKey(keyOrFn)) {\n        key = keyOrFn;\n        fn = fnOrOptions;\n        opts = options;\n    }\n    else {\n        key = Symbol('useTask');\n        fn = keyOrFn;\n        opts = fnOrOptions;\n    }\n    const schedulerCtx = useScheduler();\n    let stage = schedulerCtx.mainStage;\n    if (opts) {\n        if (opts.stage) {\n            if (DAG.isValue(opts.stage)) {\n                stage = opts.stage;\n            }\n            else {\n                const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);\n                if (!maybeStage) {\n                    throw new Error(`No stage found with key ${opts.stage.toString()}`);\n                }\n                stage = maybeStage;\n            }\n        }\n        else if (opts.after) {\n            if (Array.isArray(opts.after)) {\n                for (let index = 0; index < opts.after.length; index++) {\n                    const element = opts.after[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.after)) {\n                stage = opts.after.stage;\n            }\n        }\n        else if (opts.before) {\n            if (Array.isArray(opts.before)) {\n                for (let index = 0; index < opts.before.length; index++) {\n                    const element = opts.before[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.before)) {\n                stage = opts.before.stage;\n            }\n        }\n    }\n    const started = writable(false);\n    const task = stage.createTask(key, fn, opts);\n    const start = () => {\n        started.set(true);\n        if (opts?.autoInvalidate ?? true) {\n            schedulerCtx.autoInvalidations.add(fn);\n        }\n        task.start();\n    };\n    const stop = () => {\n        started.set(false);\n        if (opts?.autoInvalidate ?? true) {\n            schedulerCtx.autoInvalidations.delete(fn);\n        }\n        task.stop();\n    };\n    if (opts?.autoStart ?? true) {\n        start();\n    }\n    else {\n        stop();\n    }\n    onDestroy(() => {\n        if (!stage)\n            return;\n        stage.removeTask(key);\n    });\n    return {\n        task,\n        start,\n        stop,\n        started: {\n            subscribe: started.subscribe\n        }\n    };\n}\n", "import { getContext, setContext } from 'svelte';\nimport { Scene } from 'three';\nexport const createSceneContext = (scene) => {\n    const context = { scene: scene || new Scene() };\n    setContext('threlte-scene-context', context);\n    return context;\n};\nexport const useScene = () => {\n    const context = getContext('threlte-scene-context');\n    if (!context) {\n        throw new Error('useScene can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { getContext, onDestroy, setContext } from 'svelte';\nimport { AgXToneMapping, ColorManagement, PCFSoftShadowMap, WebGLRenderer } from 'three';\nimport { useTask } from '../../hooks/useTask';\nimport { currentWritable, watch } from '../../utilities';\nimport { useCamera } from './camera';\nimport { useCanvas } from './canvas';\nimport { useDisposal } from './disposal';\nimport { useScene } from './scene';\nimport { useScheduler } from './scheduler.svelte';\nexport const createRendererContext = (options) => {\n    const { dispose } = useDisposal();\n    const { camera } = useCamera();\n    const { scene } = useScene();\n    const { invalidate, renderStage, autoRender, scheduler, resetFrameInvalidation } = useScheduler();\n    const { canvas, size } = useCanvas();\n    const renderer = options.createRenderer\n        ? options.createRenderer(canvas)\n        : new WebGLRenderer({\n            canvas,\n            powerPreference: 'high-performance',\n            antialias: true,\n            alpha: true\n        });\n    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), () => {\n        renderer.render(scene, camera.current);\n    });\n    const context = {\n        renderer: renderer,\n        colorManagementEnabled: currentWritable(options.colorManagementEnabled ?? true),\n        colorSpace: currentWritable(options.colorSpace ?? 'srgb'),\n        dpr: currentWritable(options.dpr ?? window.devicePixelRatio),\n        shadows: currentWritable(options.shadows ?? PCFSoftShadowMap),\n        toneMapping: currentWritable(options.toneMapping ?? AgXToneMapping),\n        autoRenderTask\n    };\n    setContext('threlte-renderer-context', context);\n    watch([context.colorManagementEnabled], ([colorManagementEnabled]) => {\n        ColorManagement.enabled = colorManagementEnabled;\n    });\n    watch([context.colorSpace], ([colorSpace]) => {\n        if ('outputColorSpace' in renderer) {\n            renderer.outputColorSpace = colorSpace;\n        }\n    });\n    watch([context.dpr], ([dpr]) => {\n        if ('setPixelRatio' in renderer) {\n            renderer.setPixelRatio(dpr);\n        }\n    });\n    // Resize the renderer when the size changes\n    const { start, stop } = useTask(() => {\n        if (!('xr' in renderer) || renderer.xr?.isPresenting)\n            return;\n        renderer.setSize(size.current.width, size.current.height);\n        invalidate();\n        stop();\n    }, {\n        before: autoRenderTask,\n        autoStart: false,\n        autoInvalidate: false\n    });\n    watch([size], () => {\n        start();\n    });\n    watch([context.shadows], ([shadows]) => {\n        if (!('shadowMap' in renderer))\n            return;\n        renderer.shadowMap.enabled = !!shadows;\n        if (shadows && shadows !== true) {\n            renderer.shadowMap.type = shadows;\n        }\n        else if (shadows === true) {\n            renderer.shadowMap.type = PCFSoftShadowMap;\n        }\n    });\n    watch([context.toneMapping], ([toneMapping]) => {\n        if (!('toneMapping' in renderer))\n            return;\n        renderer.toneMapping = toneMapping;\n    });\n    watch([autoRender], ([autoRender]) => {\n        if (autoRender) {\n            context.autoRenderTask.start();\n        }\n        else {\n            context.autoRenderTask.stop();\n        }\n        return () => {\n            context.autoRenderTask.stop();\n        };\n    });\n    if ('setAnimationLoop' in context.renderer) {\n        const renderer = context.renderer;\n        renderer.setAnimationLoop((time) => {\n            dispose();\n            scheduler.run(time);\n            resetFrameInvalidation();\n        });\n    }\n    onDestroy(() => {\n        if ('dispose' in context.renderer) {\n            const dispose = context.renderer.dispose;\n            dispose();\n        }\n    });\n    $effect(() => {\n        context.colorManagementEnabled.set(options.colorManagementEnabled ?? true);\n    });\n    $effect(() => {\n        context.colorSpace.set(options.colorSpace ?? 'srgb');\n    });\n    $effect(() => {\n        context.toneMapping.set(options.toneMapping ?? AgXToneMapping);\n    });\n    $effect(() => {\n        context.shadows.set(options.shadows ?? PCFSoftShadowMap);\n    });\n    $effect(() => {\n        context.dpr.set(options.dpr ?? window.devicePixelRatio);\n    });\n    return context;\n};\nexport const useRenderer = () => {\n    const context = getContext('threlte-renderer-context');\n    if (!context) {\n        throw new Error('useRenderer can only be used in a child component to <Canvas>.');\n    }\n    return context;\n};\n", "import { setContext } from 'svelte';\nimport { currentWritable } from '../../utilities';\nexport const createUserContext = () => {\n    const userCtx = currentWritable({});\n    setContext('threlte-user-context', userCtx);\n};\n", "import { createCacheContext } from './fragments/cache';\nimport { createCameraContext } from './fragments/camera';\nimport { createCanvasContext } from './fragments/canvas';\nimport { createDisposalContext } from './fragments/disposal';\nimport { createParentContext } from './fragments/parent';\nimport { createRootParentObject3DContext } from './fragments/parentObject3D';\nimport { createRendererContext } from './fragments/renderer.svelte';\nimport { createSceneContext } from './fragments/scene';\nimport { createSchedulerContext } from './fragments/scheduler.svelte';\nimport { createUserContext } from './fragments/user';\nexport const createThrelteContext = (options) => {\n    createCanvasContext(options);\n    createCacheContext();\n    const { scene } = createSceneContext();\n    createParentContext(scene);\n    createRootParentObject3DContext(scene);\n    createDisposalContext();\n    createSchedulerContext(options);\n    createCameraContext();\n    createRendererContext(options);\n    createUserContext();\n};\n", null, null, "import { useCamera } from '../fragments/camera';\nimport { useCanvas } from '../fragments/canvas';\nimport { useRenderer } from '../fragments/renderer.svelte';\nimport { useScene } from '../fragments/scene';\nimport { useScheduler } from '../fragments/scheduler.svelte';\n/**\n * ### `useThrelte`\n *\n * This hook provides access to the main context of a Threlte application.\n *\n * ```svelte\n * <script>\n *   import { useThrelte } from 'threlte'\n *   const { camera } = useThrelte()\n *\n *   // Access the camera\n *   console.log(camera.current) // => PerspectiveCamera {  }\n * </script>\n * ```\n */\nexport const useThrelte = () => {\n    const schedulerCtx = useScheduler();\n    const rendererCtx = useRenderer();\n    const cameraCtx = useCamera();\n    const sceneCtx = useScene();\n    const canvasCtx = useCanvas();\n    const context = {\n        advance: schedulerCtx.advance,\n        autoRender: schedulerCtx.autoRender,\n        autoRenderTask: rendererCtx.autoRenderTask,\n        camera: cameraCtx.camera,\n        colorManagementEnabled: rendererCtx.colorManagementEnabled,\n        colorSpace: rendererCtx.colorSpace,\n        dpr: rendererCtx.dpr,\n        invalidate: schedulerCtx.invalidate,\n        mainStage: schedulerCtx.mainStage,\n        renderer: rendererCtx.renderer,\n        renderMode: schedulerCtx.renderMode,\n        renderStage: schedulerCtx.renderStage,\n        scheduler: schedulerCtx.scheduler,\n        shadows: rendererCtx.shadows,\n        shouldRender: schedulerCtx.shouldRender,\n        size: canvasCtx.size,\n        toneMapping: rendererCtx.toneMapping,\n        get scene() {\n            return sceneCtx.scene;\n        },\n        set scene(scene) {\n            sceneCtx.scene = scene;\n        }\n    };\n    return context;\n};\n", "import { onDestroy } from 'svelte';\nimport { writable } from 'svelte/store';\nimport { useThrelte } from '../../../context/compounds/useThrelte';\nimport { createParentContext, useParent } from '../../../context/fragments/parent';\nimport { createParentObject3DContext, useParentObject3D } from '../../../context/fragments/parentObject3D';\nimport { isInstanceOf, resolvePropertyPath, watch } from '../../../utilities';\nconst isObject = (ref) => {\n    return typeof ref === 'object' && ref !== null;\n};\nexport const useAttach = () => {\n    const { invalidate } = useThrelte();\n    let detachFn;\n    const attach = writable();\n    const parent = useParent();\n    const parentObject3D = useParentObject3D();\n    const currentRef = createParentContext();\n    const object3D = createParentObject3DContext();\n    watch([attach, currentRef, parent, parentObject3D], ([attach, ref, parent, parentObject3D]) => {\n        // Always detach first\n        detachFn?.();\n        detachFn = undefined;\n        if (!ref) {\n            invalidate();\n            return;\n        }\n        if (attach !== undefined) {\n            // Manual attach\n            if (attach) {\n                if (typeof attach === 'function') {\n                    detachFn = attach({ ref: ref, parent, parentObject3D });\n                }\n                else if (isInstanceOf(attach, 'Object3D') && isInstanceOf(ref, 'Object3D')) {\n                    detachFn = () => attach?.remove(ref);\n                    // Add to parent Object3D\n                    attach?.add(ref);\n                }\n                else if (typeof attach === 'string') {\n                    const { target, key } = resolvePropertyPath(parent, attach);\n                    const valueBeforeAttach = target[key];\n                    detachFn = () => (target[key] = valueBeforeAttach);\n                    target[key] = ref;\n                }\n            }\n        }\n        else {\n            // Auto attach\n            if (isInstanceOf(ref, 'Object3D')) {\n                // Build detach function\n                detachFn = () => parentObject3D?.remove(ref);\n                // Add to parent Object3D\n                parentObject3D?.add(ref);\n            }\n            else if (isObject(parent)) {\n                // Auto-attach to parent material or geometry\n                if (isInstanceOf(ref, 'Material')) {\n                    parent['material'] = ref;\n                }\n                else if (isInstanceOf(ref, 'BufferGeometry')) {\n                    parent['geometry'] = ref;\n                }\n            }\n        }\n        invalidate();\n    });\n    const updateAttach = (a) => {\n        attach.set(a);\n    };\n    const updateRef = (value) => {\n        currentRef.set(value);\n        if (isInstanceOf(value, 'Object3D')) {\n            object3D.set(value);\n        }\n    };\n    onDestroy(() => {\n        detachFn?.();\n        invalidate();\n    });\n    return {\n        updateRef,\n        updateAttach\n    };\n};\n", "import { writable } from 'svelte/store';\nimport { useThrelte } from '../../../context/compounds/useThrelte';\nimport { isInstanceOf, watch } from '../../../utilities';\nconst isPerspectiveOrOrthographicCamera = (value) => {\n    return isInstanceOf(value, 'PerspectiveCamera') || isInstanceOf(value, 'OrthographicCamera');\n};\nexport const useCamera = () => {\n    const { invalidate, size, camera } = useThrelte();\n    const currentRef = writable();\n    const manual = writable(true);\n    const makeDefault = writable(false);\n    watch([currentRef, makeDefault], ([ref, makeDefault]) => {\n        if (!ref || !makeDefault)\n            return;\n        camera.set(ref);\n        invalidate();\n    });\n    watch([currentRef, manual, size], ([ref, manual, size]) => {\n        if (!ref || manual)\n            return;\n        if (isInstanceOf(ref, 'OrthographicCamera')) {\n            ref.left = size.width / -2;\n            ref.right = size.width / 2;\n            ref.top = size.height / 2;\n            ref.bottom = size.height / -2;\n            ref.updateProjectionMatrix();\n            ref.updateMatrixWorld();\n            invalidate();\n        }\n        else if (isInstanceOf(ref, 'PerspectiveCamera')) {\n            ref.aspect = size.width / size.height;\n            ref.updateProjectionMatrix();\n            ref.updateMatrixWorld();\n            invalidate();\n        }\n    });\n    const updateRef = (ref) => {\n        if (!isPerspectiveOrOrthographicCamera(ref))\n            return;\n        currentRef.set(ref);\n    };\n    const updateManual = (m) => {\n        manual.set(m);\n    };\n    const updateMakeDefault = (d) => {\n        makeDefault.set(d);\n    };\n    return {\n        updateRef,\n        updateManual,\n        updateMakeDefault\n    };\n};\n", "import { onDestroy, onMount } from 'svelte';\nexport const useCreateEvent = (oncreate) => {\n    let cleanupFunction;\n    let ref = undefined;\n    let mounted = false;\n    const dispatchCreateEvent = () => {\n        cleanupFunction?.();\n        cleanupFunction = oncreate?.(ref);\n    };\n    const updateRef = (newRef) => {\n        ref = newRef;\n        if (!mounted)\n            return;\n        dispatchCreateEvent();\n    };\n    onMount(() => {\n        dispatchCreateEvent();\n        mounted = true;\n    });\n    onDestroy(() => cleanupFunction?.());\n    return {\n        updateRef\n    };\n};\n", "import { getContext, onDestroy, setContext } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nimport { useDisposal } from '../../../context/fragments/disposal';\nimport { isInstanceOf, watch } from '../../../utilities';\nconst contextName = Symbol('threlte-disposable-object-context');\n/**\n * Checks if the given object is a disposable object. Scenes are not disposable.\n * @param object - The object to check.\n * @returns True if the object is a disposable object, false otherwise.\n */\nconst isDisposableObject = (object) => {\n    return typeof object?.dispose === 'function' && !isInstanceOf(object, 'Scene');\n};\nexport const useDispose = (dispose) => {\n    let previousRef = undefined;\n    const currentRef = writable(undefined);\n    const localDispose = writable(dispose);\n    const { disposableObjectMounted, disposableObjectUnmounted, removeObjectFromDisposal } = useDisposal();\n    const parentDispose = getContext(contextName);\n    // We merge the local dispose with the parent dispose. If the parent dispose\n    // is not set, we use true as default.\n    const mergedDispose = derived([localDispose, parentDispose ?? writable(true)], ([localDispose, parentDispose]) => localDispose ?? parentDispose ?? true);\n    setContext(contextName, mergedDispose);\n    watch([currentRef, mergedDispose], ([ref, mergedDispose]) => {\n        if (ref === previousRef) {\n            // dispose changed\n            if (!mergedDispose) {\n                // disposal is no longer enabled, so we need to deregister the previous ref\n                if (previousRef)\n                    removeObjectFromDisposal(previousRef);\n            }\n            else {\n                // disposal is enabled, so we need to register the previous ref\n                if (previousRef)\n                    disposableObjectMounted(previousRef);\n            }\n        }\n        else {\n            // ref changed\n            if (mergedDispose) {\n                // we're disposing the old ref\n                if (previousRef)\n                    disposableObjectUnmounted(previousRef);\n                // and registering the new ref\n                if (ref)\n                    disposableObjectMounted(ref);\n            }\n        }\n        previousRef = ref;\n    });\n    onDestroy(() => {\n        if (!get(mergedDispose))\n            return;\n        const ref = get(currentRef);\n        if (ref)\n            disposableObjectUnmounted(ref);\n    });\n    const updateRef = (ref) => {\n        if (!isDisposableObject(ref))\n            return;\n        currentRef.set(ref);\n    };\n    const updateDispose = (dispose) => {\n        localDispose.set(dispose);\n    };\n    return {\n        updateRef,\n        updateDispose\n    };\n};\n", "/**\n * Typeguard to check if a value is extending THREE.EventDispatcher\n * @param value\n * @returns\n */\nconst isEventDispatcher = (value) => {\n    return (value !== null &&\n        typeof value === 'object' &&\n        'addEventListener' in value &&\n        'removeEventListener' in value);\n};\nexport const useEvents = (props = {}) => {\n    const eventHandlerProxy = (event) => {\n        if (event?.type) {\n            props[`on${event.type}`]?.(event);\n        }\n    };\n    const addEventListeners = (ref, props) => {\n        const eventNames = [];\n        for (const eventName of Object.keys(props)) {\n            if (eventName.startsWith('on')) {\n                ref.addEventListener(eventName.slice(2), eventHandlerProxy);\n                eventNames.push(eventName);\n            }\n        }\n        return () => {\n            for (let i = 0; i < eventNames.length; i++) {\n                ref.removeEventListener(eventNames[i], eventHandlerProxy);\n            }\n        };\n    };\n    const updateRef = (ref) => {\n        if (!isEventDispatcher(ref))\n            return;\n        return addEventListeners(ref, props);\n    };\n    return {\n        updateRef\n    };\n};\n", "let currentIs;\nexport const setIs = (is) => {\n    currentIs = is;\n};\nexport const useIs = () => {\n    const is = currentIs;\n    currentIs = undefined;\n    return is;\n};\n", "import { getContext } from 'svelte';\nexport const usePlugins = (args) => {\n    const pluginContextName = 'threlte-plugin-context';\n    const plugins = getContext(pluginContextName);\n    if (!plugins)\n        return;\n    const pluginsProps = [];\n    const pluginsArray = Object.values(plugins);\n    if (pluginsArray.length) {\n        const pluginArgs = args();\n        // initalize plugins\n        for (let i = 0; i < pluginsArray.length; i++) {\n            const plugin = pluginsArray[i];\n            // initialize plugin\n            const p = plugin(pluginArgs);\n            if (p && p.pluginProps) {\n                pluginsProps.push(...p.pluginProps);\n            }\n        }\n    }\n    return {\n        pluginsProps\n    };\n};\n", "import { useThrelte } from '../../../context/compounds/useThrelte';\nimport { resolvePropertyPath } from '../../../utilities';\nconst ignoredProps = new Set(['$$scope', '$$slots', 'type', 'args', 'attach', 'instance']);\nconst updateProjectionMatrixKeys = new Set([\n    'fov',\n    'aspect',\n    'near',\n    'far',\n    'left',\n    'right',\n    'top',\n    'bottom',\n    'zoom'\n]);\n/**\n * Only scalar values are memoized, objects and arrays are considered\n * non-equa by default, to ensure reactivity works as you would\n * expect in svelte.\n * @param value\n * @returns\n */\nexport const memoizeProp = (value) => {\n    // scalar values are memoized\n    if (typeof value === 'string')\n        return true;\n    if (typeof value === 'number')\n        return true;\n    if (typeof value === 'boolean')\n        return true;\n    if (typeof value === 'undefined')\n        return true;\n    if (value === null)\n        return true;\n    // objects and arrays cannot be reliably memoized\n    return false;\n};\nconst createSetter = (target, key, value) => {\n    if (!Array.isArray(value) &&\n        typeof value === 'number' &&\n        typeof target[key]?.setScalar === 'function' &&\n        // colors do have a setScalar function, but we don't want to use it, because\n        // the hex notation (i.e. 0xff0000) is very popular and matches the number\n        // type. So we exclude colors here.\n        !target[key]?.isColor) {\n        // edge case of setScalar setters\n        return (target, key, value) => {\n            target[key].setScalar(value);\n        };\n    }\n    else {\n        if (typeof target[key]?.set === 'function') {\n            // if the property has a \"set\" function, we can use it\n            if (Array.isArray(value)) {\n                return (target, key, value) => {\n                    target[key].set(...value);\n                };\n            }\n            else {\n                return (target, key, value) => {\n                    target[key].set(value);\n                };\n            }\n        }\n        else {\n            // otherwise, we just set the value\n            return (target, key, value) => {\n                target[key] = value;\n            };\n        }\n    }\n};\nexport const useProps = () => {\n    const { invalidate } = useThrelte();\n    const memoizedProps = new Map();\n    const memoizedSetters = new Map();\n    const setProp = (instance, propertyPath, value, options) => {\n        if (memoizeProp(value)) {\n            const memoizedProp = memoizedProps.get(propertyPath);\n            if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\n                return;\n            }\n            memoizedProps.set(propertyPath, {\n                instance,\n                value\n            });\n        }\n        const { key, target } = resolvePropertyPath(instance, propertyPath);\n        if (value !== undefined && value !== null) {\n            const memoizedSetter = memoizedSetters.get(propertyPath);\n            if (memoizedSetter) {\n                memoizedSetter(target, key, value);\n            }\n            else {\n                const setter = createSetter(target, key, value);\n                memoizedSetters.set(propertyPath, setter);\n                setter(target, key, value);\n            }\n        }\n        else {\n            createSetter(target, key, value)(target, key, value);\n        }\n        if (options.manualCamera)\n            return;\n        if (updateProjectionMatrixKeys.has(key) &&\n            (target.isPerspectiveCamera || target.isOrthographicCamera)) {\n            target.updateProjectionMatrix();\n        }\n    };\n    const updateProp = (instance, key, value, options) => {\n        if (!ignoredProps.has(key) && !options.pluginsProps?.includes(key)) {\n            setProp(instance, key, value, options);\n        }\n        invalidate();\n    };\n    return {\n        updateProp\n    };\n};\n", "const classRegex = /^\\s*class\\s+/;\n// Type Guards\nconst isClass = (input) => {\n    if (typeof input !== 'function') {\n        return false;\n    }\n    return classRegex.test(input.toString());\n};\nconst argsIsConstructorParameters = (args) => {\n    return Array.isArray(args);\n};\nexport const determineRef = (is, args) => {\n    if (isClass(is)) {\n        if (argsIsConstructorParameters(args)) {\n            return new is(...args);\n        }\n        else {\n            return new is();\n        }\n    }\n    return is;\n};\n", null, "import * as THREE from 'three';\nimport TComp from './T.svelte';\nimport { setIs } from './utils/useIs';\nconst catalogue = {};\n/**\n * Extends the default THREE namespace and allows using custom Three.js objects with `<T>`.\n *\n * @example\n * ```svelte\n * <script>\n * \timport { extend, T } from 'threlte'\n * \timport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n *\n * \textend({ OrbitControls })\n * </script>\n *\n * <T.OrbitControls />\n * ```\n */\nexport const extend = (extensions) => {\n    Object.assign(catalogue, extensions);\n};\n/**\n * ## `<T>`\n *\n * Threlte's `<T>` component is a wrapper around Three.js objects. It is a generic component that can be used to create any Three.js object.\n *\n * @example\n *\n * ```svelte\n * <script>\n * \timport { T } from 'threlte'\n * </script>\n *\n * <T.PerspectiveCamera makeDefault />\n *\n * <T.Mesh>\n * \t<T.BoxGeometry />\n * \t<T.MeshBasicMaterial color=\"red\" />\n * </T.Mesh>\n * ```\n */\nexport const T = new Proxy(function () { }, {\n    apply(_target, _thisArg, argArray) {\n        return TComp(...argArray);\n    },\n    get(_target, is) {\n        // Handle snippets\n        if (typeof is !== 'string') {\n            return TComp;\n        }\n        const module = catalogue[is] || THREE[is];\n        if (module === undefined) {\n            throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\n        }\n        setIs(module);\n        return TComp;\n    }\n});\n", "import { getContext, setContext } from 'svelte';\nexport function injectPlugin(name, plugin) {\n    const contextName = 'threlte-plugin-context';\n    if (!plugin)\n        return;\n    setContext(contextName, {\n        ...getContext(contextName),\n        [name]: plugin\n    });\n}\n", "import { useThrelte } from '../context/compounds/useThrelte';\n/**\n * Creates a stage and returns it. If the stage already exists, it is returned.\n *\n * @param key The key of the stage.\n * @param options Options for creating the stage.\n */\nexport function useStage(key, options) {\n    const { scheduler } = useThrelte();\n    return scheduler.getStage(key) ?? scheduler.createStage(key, options);\n}\n", "import { getContext } from 'svelte';\nimport { derived } from 'svelte/store';\nexport function useThrelteUserContext(namespace, value, options) {\n    const userCtxStore = getContext('threlte-user-context');\n    if (!userCtxStore) {\n        throw new Error('No user context store found, did you invoke this function outside of your main <Canvas> component?');\n    }\n    // return the plain user context store\n    if (!namespace) {\n        return {\n            subscribe: userCtxStore.subscribe\n        };\n    }\n    // return a specific user context entry\n    if (namespace && !value) {\n        return derived(userCtxStore, (ctx) => ctx[namespace]);\n    }\n    // we are possibly setting a new user context entry here\n    userCtxStore.update((ctx) => {\n        if (namespace in ctx) {\n            // skip is the default value\n            if (!options || options.existing === 'skip')\n                return ctx;\n            if (options.existing === 'merge') {\n                const v = typeof value === 'function' ? value() : value;\n                Object.assign(ctx[namespace], v);\n                return ctx;\n            }\n        }\n        // also handles options.existing === 'replace'\n        const v = typeof value === 'function' ? value() : value;\n        ctx[namespace] = v;\n        return ctx;\n    });\n    return userCtxStore.current[namespace];\n}\n", "import { useCache } from '../context/fragments/cache';\nimport { asyncWritable } from '../utilities';\nexport function useLoader(Proto, options) {\n    const { remember, clear: clearCacheItem } = useCache();\n    let loader;\n    const initializeLoader = () => {\n        // Type-wrestling galore\n        const lazyLoader = new Proto(...(options?.args ?? []));\n        // extend the loader if necessary\n        options?.extend?.(lazyLoader);\n        return lazyLoader;\n    };\n    const load = (input, options) => {\n        // Allow Async and Sync loaders\n        const loadResource = async (url) => {\n            if (!loader) {\n                loader = initializeLoader();\n            }\n            if ('loadAsync' in loader) {\n                const result = await loader.loadAsync(url, options?.onProgress);\n                return options?.transform?.(result) ?? result;\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    ;\n                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);\n                });\n            }\n        };\n        if (Array.isArray(input)) {\n            // map over the input array and return an array of promises\n            const promises = input.map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the array of promises\n            const store = asyncWritable(Promise.all(promises));\n            return store; // TODO: Dirty escape hatch\n        }\n        else if (typeof input === 'string') {\n            const promise = remember(() => loadResource(input), [Proto, input]);\n            // return an AsyncWritable that resolves to the promise\n            const store = asyncWritable(promise);\n            return store; // TODO: Dirty escape hatch\n        }\n        else {\n            // map over the input object and return an array of promises\n            const promises = Object.values(input).map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the object of promises\n            const store = asyncWritable(Promise.all(promises).then((results) => {\n                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));\n            }));\n            return store; // TODO: Dirty escape hatch\n        }\n    };\n    const clear = (input) => {\n        if (Array.isArray(input)) {\n            input.forEach((url) => {\n                clearCacheItem([Proto, url]);\n            });\n        }\n        else if (typeof input === 'string') {\n            clearCacheItem([Proto, input]);\n        }\n        else {\n            Object.entries(input).forEach(([key, url]) => {\n                clearCacheItem([Proto, key, url]);\n            });\n        }\n    };\n    return {\n        load,\n        clear,\n        loader\n    };\n}\n// Type tests\n// class WithConstructorParameters {\n//   constructor(hello: 'abc' | 'def') {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithOptionalConstructorParameters {\n//   constructor(hello?: string) {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithoutConstructorParameters {\n//   constructor() {\n//     console.log('without')\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// const shouldFail = () => {\n//   useLoader(WithConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     args: ['hello']\n//   })\n// }\n// const shouldSucceed = () => {\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc']\n//   })\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc'],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters)\n//   useLoader(WithOptionalConstructorParameters, {\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: [],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello'],\n//     extend(loader) {\n//       // \n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello']\n//   })\n//   useLoader(WithoutConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     extend(loader) {\n//       // \n//     }\n//   })\n// }\n", "import './types.d.ts';\nexport const VERSION = 8;\n// canvas component\nexport { default as Canvas } from './Canvas.svelte';\n// components (v6)\nexport { T, extend } from './components/T/T';\n// plugins\nexport { injectPlugin } from './plugins/injectPlugin';\n// hooks\nexport { useThrelte } from './context/compounds/useThrelte';\nexport { useStage } from './hooks/useStage';\nexport { useTask } from './hooks/useTask';\nexport { useThrelteUserContext } from './hooks/useThrelteUserContext';\n// useLoader\nexport { useLoader } from './hooks/useLoader';\nexport { createThrelteContext } from './context/createThrelteContext.svelte';\nexport { createCacheContext, useCache } from './context/fragments/cache';\nexport { createCameraContext, useCamera } from './context/fragments/camera';\nexport { createCanvasContext, useCanvas } from './context/fragments/canvas';\nexport { createDisposalContext, useDisposal } from './context/fragments/disposal';\nexport { createParentContext, useParent } from './context/fragments/parent';\nexport { createParentObject3DContext, useParentObject3D } from './context/fragments/parentObject3D';\nexport { createRendererContext, useRenderer } from './context/fragments/renderer.svelte';\nexport { createSceneContext, useScene } from './context/fragments/scene';\nexport { createSchedulerContext, useScheduler } from './context/fragments/scheduler.svelte';\n// utils\nexport * from './utilities';\n"],
  "mappings": "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",
  "names": ["entry", "derived", "value", "start", "size", "derived", "object3D", "parentObject3D", "autoRender", "renderer", "dispose", "attach", "parent", "parentObject3D", "useCamera", "makeDefault", "manual", "size", "derived", "localDispose", "parentDispose", "mergedDispose", "get", "dispose", "props", "target", "key", "value", "useCamera", "T", "contextName", "derived", "v", "options", "_a"]
}
