{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/BufferGeometryUtils.js"],
  "sourcesContent": ["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tInstancedBufferAttribute,\r\n\tInterleavedBuffer,\r\n\tInterleavedBufferAttribute,\r\n\tTriangleFanDrawMode,\r\n\tTriangleStripDrawMode,\r\n\tTrianglesDrawMode,\r\n\tVector3,\r\n} from 'three';\r\n\r\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\r\n\r\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\r\n\r\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\r\n\r\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\r\n\r\n\t}\r\n\r\n\tfunction getAttributeArray( attribute ) {\r\n\r\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\r\n\r\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\r\n\r\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\r\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\r\n\r\n\t\t\t\tif ( attribute.itemSize > 2 ) {\r\n\r\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn dstArray;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attribute.array instanceof Float32Array ) {\r\n\r\n\t\t\treturn attribute.array;\r\n\r\n\t\t}\r\n\r\n\t\treturn new Float32Array( attribute.array );\r\n\r\n\t}\r\n\r\n\t// MikkTSpace algorithm requires non-indexed input.\r\n\r\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\r\n\r\n\t// Compute vertex tangents.\r\n\r\n\tconst tangents = MikkTSpace.generateTangents(\r\n\r\n\t\tgetAttributeArray( _geometry.attributes.position ),\r\n\t\tgetAttributeArray( _geometry.attributes.normal ),\r\n\t\tgetAttributeArray( _geometry.attributes.uv )\r\n\r\n\t);\r\n\r\n\t// Texture coordinate convention of glTF differs from the apparent\r\n\t// default of the MikkTSpace library; .w component must be flipped.\r\n\r\n\tif ( negateSign ) {\r\n\r\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\r\n\r\n\t\t\ttangents[ i ] *= - 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\r\n\r\n\tif ( geometry !== _geometry ) {\r\n\r\n\t\tgeometry.copy( _geometry );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\n/**\r\n * @param  {Array<BufferGeometry>} geometries\r\n * @param  {Boolean} useGroups\r\n * @return {BufferGeometry}\r\n */\r\nfunction mergeGeometries( geometries, useGroups = false ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\r\n\r\n\tconst attributes = {};\r\n\tconst morphAttributes = {};\r\n\r\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\r\n\r\n\tconst mergedGeometry = new BufferGeometry();\r\n\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// gather morph attributes, exit early if they're different\r\n\r\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const name in geometry.morphAttributes ) {\r\n\r\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\r\n\r\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmergedGeometry.addGroup( offset, count, i );\r\n\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet indexOffset = 0;\r\n\t\tconst mergedIndex = [];\r\n\r\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\tconst index = geometries[ i ].index;\r\n\r\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\r\n\r\n\t\t}\r\n\r\n\t\tmergedGeometry.setIndex( mergedIndex );\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\r\n\r\n\t\tif ( ! mergedAttribute ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\r\n\r\n\t}\r\n\r\n\t// merge morph attributes\r\n\r\n\tfor ( const name in morphAttributes ) {\r\n\r\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\r\n\r\n\t\tif ( numMorphTargets === 0 ) break;\r\n\r\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n\t\tmergedGeometry.morphAttributes[ name ] = [];\r\n\r\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\r\n\r\n\t\t\tconst morphAttributesToMerge = [];\r\n\r\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\r\n\r\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\r\n\r\n\t\t\tif ( ! mergedMorphAttribute ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn mergedGeometry;\r\n\r\n}\r\n\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {BufferAttribute}\r\n */\r\nfunction mergeAttributes( attributes ) {\r\n\r\n\tlet TypedArray;\r\n\tlet itemSize;\r\n\tlet normalized;\r\n\tlet gpuType = - 1;\r\n\tlet arrayLength = 0;\r\n\r\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\r\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\r\n\t\tif ( TypedArray !== attribute.array.constructor ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\r\n\t\tif ( itemSize !== attribute.itemSize ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\r\n\t\tif ( normalized !== attribute.normalized ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\r\n\t\tif ( gpuType !== attribute.gpuType ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tarrayLength += attribute.count * itemSize;\r\n\r\n\t}\r\n\r\n\tconst array = new TypedArray( arrayLength );\r\n\tconst result = new BufferAttribute( array, itemSize, normalized );\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tconst tupleOffset = offset / itemSize;\r\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\r\n\r\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\r\n\r\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\r\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray.set( attribute.array, offset );\r\n\r\n\t\t}\r\n\r\n\t\toffset += attribute.count * itemSize;\r\n\r\n\t}\r\n\r\n\tif ( gpuType !== undefined ) {\r\n\r\n\t\tresult.gpuType = gpuType;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferAttribute}\r\n * @return {BufferAttribute}\r\n */\r\nexport function deepCloneAttribute( attribute ) {\r\n\r\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\treturn deinterleaveAttribute( attribute );\r\n\r\n\t}\r\n\r\n\tif ( attribute.isInstancedBufferAttribute ) {\r\n\r\n\t\treturn new InstancedBufferAttribute().copy( attribute );\r\n\r\n\t}\r\n\r\n\treturn new BufferAttribute().copy( attribute );\r\n\r\n}\r\n\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {Array<InterleavedBufferAttribute>}\r\n */\r\nfunction interleaveAttributes( attributes ) {\r\n\r\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\r\n\t// a set of InterleavedBufferAttributes for each attribute\r\n\tlet TypedArray;\r\n\tlet arrayLength = 0;\r\n\tlet stride = 0;\r\n\r\n\t// calculate the length and type of the interleavedBuffer\r\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\r\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\r\n\t\tif ( TypedArray !== attribute.array.constructor ) {\r\n\r\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tarrayLength += attribute.array.length;\r\n\t\tstride += attribute.itemSize;\r\n\r\n\t}\r\n\r\n\t// Create the set of buffer attributes\r\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\r\n\tlet offset = 0;\r\n\tconst res = [];\r\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\r\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\r\n\r\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\r\n\r\n\t\tconst attribute = attributes[ j ];\r\n\t\tconst itemSize = attribute.itemSize;\r\n\t\tconst count = attribute.count;\r\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\r\n\t\tres.push( iba );\r\n\r\n\t\toffset += itemSize;\r\n\r\n\t\t// Move the data for each attribute into the new interleavedBuffer\r\n\t\t// at the appropriate offset\r\n\t\tfor ( let c = 0; c < count; c ++ ) {\r\n\r\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\n// returns a new, non-interleaved version of the provided attribute\r\nexport function deinterleaveAttribute( attribute ) {\r\n\r\n\tconst cons = attribute.data.array.constructor;\r\n\tconst count = attribute.count;\r\n\tconst itemSize = attribute.itemSize;\r\n\tconst normalized = attribute.normalized;\r\n\r\n\tconst array = new cons( count * itemSize );\r\n\tlet newAttribute;\r\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\r\n\r\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\r\n\r\n\t} else {\r\n\r\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\r\n\r\n\t\tif ( itemSize >= 2 ) {\r\n\r\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize >= 3 ) {\r\n\r\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize >= 4 ) {\r\n\r\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn newAttribute;\r\n\r\n}\r\n\r\n// deinterleaves all attributes on the geometry\r\nexport function deinterleaveGeometry( geometry ) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst morphTargets = geometry.morphTargets;\r\n\tconst attrMap = new Map();\r\n\r\n\tfor ( const key in attributes ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tif ( ! attrMap.has( attr ) ) {\r\n\r\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ key ] = attrMap.get( attr );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( const key in morphTargets ) {\r\n\r\n\t\tconst attr = morphTargets[ key ];\r\n\t\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tif ( ! attrMap.has( attr ) ) {\r\n\r\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @return {number}\r\n */\r\nfunction estimateBytesUsed( geometry ) {\r\n\r\n\t// Return the estimated memory used by this geometry in bytes\r\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\r\n\t// for InterleavedBufferAttributes.\r\n\tlet mem = 0;\r\n\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\tconst attr = geometry.getAttribute( name );\r\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\r\n\r\n\t}\r\n\r\n\tconst indices = geometry.getIndex();\r\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\r\n\treturn mem;\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} tolerance\r\n * @return {BufferGeometry}\r\n */\r\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\r\n\r\n\ttolerance = Math.max( tolerance, Number.EPSILON );\r\n\r\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\r\n\t// if it's already available.\r\n\tconst hashToIndex = {};\r\n\tconst indices = geometry.getIndex();\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst vertexCount = indices ? indices.count : positions.count;\r\n\r\n\t// next value for triangle indices\r\n\tlet nextIndex = 0;\r\n\r\n\t// attributes and new attribute arrays\r\n\tconst attributeNames = Object.keys( geometry.attributes );\r\n\tconst tmpAttributes = {};\r\n\tconst tmpMorphAttributes = {};\r\n\tconst newIndices = [];\r\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\r\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\r\n\r\n\t// Initialize the arrays, allocating space conservatively. Extra\r\n\t// space will be trimmed in the last step.\r\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\r\n\r\n\t\tconst name = attributeNames[ i ];\r\n\t\tconst attr = geometry.attributes[ name ];\r\n\r\n\t\ttmpAttributes[ name ] = new attr.constructor(\r\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\r\n\t\t\tattr.itemSize,\r\n\t\t\tattr.normalized\r\n\t\t);\r\n\r\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\r\n\t\tif ( morphAttributes ) {\r\n\r\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\r\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\r\n\r\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\r\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// convert the error tolerance to an amount of decimal places to truncate to\r\n\tconst halfTolerance = tolerance * 0.5;\r\n\tconst exponent = Math.log10( 1 / tolerance );\r\n\tconst hashMultiplier = Math.pow( 10, exponent );\r\n\tconst hashAdditive = halfTolerance * hashMultiplier;\r\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\tconst index = indices ? indices.getX( i ) : i;\r\n\r\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\r\n\t\tlet hash = '';\r\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\r\n\r\n\t\t\tconst name = attributeNames[ j ];\r\n\t\t\tconst attribute = geometry.getAttribute( name );\r\n\t\t\tconst itemSize = attribute.itemSize;\r\n\r\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\t// double tilde truncates the decimal value\r\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add another reference to the vertex if it's already\r\n\t\t// used by another index\r\n\t\tif ( hash in hashToIndex ) {\r\n\r\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// copy data to the new index in the temporary attributes\r\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\r\n\r\n\t\t\t\tconst name = attributeNames[ j ];\r\n\t\t\t\tconst attribute = geometry.getAttribute( name );\r\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\r\n\t\t\t\tconst itemSize = attribute.itemSize;\r\n\t\t\t\tconst newArray = tmpAttributes[ name ];\r\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\r\n\r\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\t\tconst getterFunc = getters[ k ];\r\n\t\t\t\t\tconst setterFunc = setters[ k ];\r\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\r\n\r\n\t\t\t\t\tif ( morphAttributes ) {\r\n\r\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\thashToIndex[ hash ] = nextIndex;\r\n\t\t\tnewIndices.push( nextIndex );\r\n\t\t\tnextIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate result BufferGeometry\r\n\tconst result = geometry.clone();\r\n\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\tconst tmpAttribute = tmpAttributes[ name ];\r\n\r\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\r\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\r\n\t\t\ttmpAttribute.itemSize,\r\n\t\t\ttmpAttribute.normalized,\r\n\t\t) );\r\n\r\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\r\n\r\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\r\n\r\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\r\n\r\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\r\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\r\n\t\t\t\ttmpMorphAttribute.itemSize,\r\n\t\t\t\ttmpMorphAttribute.normalized,\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tresult.setIndex( newIndices );\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\nfunction toTrianglesDrawMode( geometry, drawMode ) {\r\n\r\n\tif ( drawMode === TrianglesDrawMode ) {\r\n\r\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\r\n\r\n\t\tlet index = geometry.getIndex();\r\n\r\n\t\t// generate index if not present\r\n\r\n\t\tif ( index === null ) {\r\n\r\n\t\t\tconst indices = [];\r\n\r\n\t\t\tconst position = geometry.getAttribute( 'position' );\r\n\r\n\t\t\tif ( position !== undefined ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\r\n\r\n\t\t\t\t\tindices.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\t\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst numberOfTriangles = index.count - 2;\r\n\t\tconst newIndices = [];\r\n\r\n\t\tif ( drawMode === TriangleFanDrawMode ) {\r\n\r\n\t\t\t// gl.TRIANGLE_FAN\r\n\r\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// gl.TRIANGLE_STRIP\r\n\r\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\r\n\r\n\t\t}\r\n\r\n\t\t// build final geometry\r\n\r\n\t\tconst newGeometry = geometry.clone();\r\n\t\tnewGeometry.setIndex( newIndices );\r\n\t\tnewGeometry.clearGroups();\r\n\r\n\t\treturn newGeometry;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\r\n * Helpful for Raytracing or Decals.\r\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\r\n * @return {Object} An Object with original position/normal attributes and morphed ones.\r\n */\r\nfunction computeMorphedAttributes( object ) {\r\n\r\n\tconst _vA = new Vector3();\r\n\tconst _vB = new Vector3();\r\n\tconst _vC = new Vector3();\r\n\r\n\tconst _tempA = new Vector3();\r\n\tconst _tempB = new Vector3();\r\n\tconst _tempC = new Vector3();\r\n\r\n\tconst _morphA = new Vector3();\r\n\tconst _morphB = new Vector3();\r\n\tconst _morphC = new Vector3();\r\n\r\n\tfunction _calculateMorphedAttributeData(\r\n\t\tobject,\r\n\t\tattribute,\r\n\t\tmorphAttribute,\r\n\t\tmorphTargetsRelative,\r\n\t\ta,\r\n\t\tb,\r\n\t\tc,\r\n\t\tmodifiedAttributeArray\r\n\t) {\r\n\r\n\t\t_vA.fromBufferAttribute( attribute, a );\r\n\t\t_vB.fromBufferAttribute( attribute, b );\r\n\t\t_vC.fromBufferAttribute( attribute, c );\r\n\r\n\t\tconst morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( morphAttribute && morphInfluences ) {\r\n\r\n\t\t\t_morphA.set( 0, 0, 0 );\r\n\t\t\t_morphB.set( 0, 0, 0 );\r\n\t\t\t_morphC.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst influence = morphInfluences[ i ];\r\n\t\t\t\tconst morph = morphAttribute[ i ];\r\n\r\n\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\r\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\r\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\r\n\r\n\t\t\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\r\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\r\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\r\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\r\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_vA.add( _morphA );\r\n\t\t\t_vB.add( _morphB );\r\n\t\t\t_vC.add( _morphC );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\tobject.applyBoneTransform( a, _vA );\r\n\t\t\tobject.applyBoneTransform( b, _vB );\r\n\t\t\tobject.applyBoneTransform( c, _vC );\r\n\r\n\t\t}\r\n\r\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\r\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\r\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\r\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\r\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\r\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\r\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\r\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\r\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\r\n\r\n\t}\r\n\r\n\tconst geometry = object.geometry;\r\n\tconst material = object.material;\r\n\r\n\tlet a, b, c;\r\n\tconst index = geometry.index;\r\n\tconst positionAttribute = geometry.attributes.position;\r\n\tconst morphPosition = geometry.morphAttributes.position;\r\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\tconst normalAttribute = geometry.attributes.normal;\r\n\tconst morphNormal = geometry.morphAttributes.position;\r\n\r\n\tconst groups = geometry.groups;\r\n\tconst drawRange = geometry.drawRange;\r\n\tlet i, j, il, jl;\r\n\tlet group;\r\n\tlet start, end;\r\n\r\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\r\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\r\n\r\n\tif ( index !== null ) {\r\n\r\n\t\t// indexed buffer geometry\r\n\r\n\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup = groups[ i ];\r\n\r\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\ta = index.getX( j );\r\n\t\t\t\t\tb = index.getX( j + 1 );\r\n\t\t\t\t\tc = index.getX( j + 2 );\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\ta = index.getX( i );\r\n\t\t\t\tb = index.getX( i + 1 );\r\n\t\t\t\tc = index.getX( i + 2 );\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// non-indexed buffer geometry\r\n\r\n\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup = groups[ i ];\r\n\r\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\ta = j;\r\n\t\t\t\t\tb = j + 1;\r\n\t\t\t\t\tc = j + 2;\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\ta = i;\r\n\t\t\t\tb = i + 1;\r\n\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\r\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\r\n\r\n\treturn {\r\n\r\n\t\tpositionAttribute: positionAttribute,\r\n\t\tnormalAttribute: normalAttribute,\r\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\r\n\t\tmorphedNormalAttribute: morphedNormalAttribute\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction mergeGroups( geometry ) {\r\n\r\n\tif ( geometry.groups.length === 0 ) {\r\n\r\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tlet groups = geometry.groups;\r\n\r\n\t// sort groups by material index\r\n\r\n\tgroups = groups.sort( ( a, b ) => {\r\n\r\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\r\n\r\n\t\treturn a.start - b.start;\r\n\r\n\t} );\r\n\r\n\t// create index for non-indexed geometries\r\n\r\n\tif ( geometry.getIndex() === null ) {\r\n\r\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\r\n\t\tconst indices = [];\r\n\r\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\r\n\r\n\t\t\tindices.push( i, i + 1, i + 2 );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.setIndex( indices );\r\n\r\n\t}\r\n\r\n\t// sort index\r\n\r\n\tconst index = geometry.getIndex();\r\n\r\n\tconst newIndices = [];\r\n\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tconst groupStart = group.start;\r\n\t\tconst groupLength = groupStart + group.count;\r\n\r\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\r\n\r\n\t\t\tnewIndices.push( index.getX( j ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.dispose(); // Required to force buffer recreation\r\n\tgeometry.setIndex( newIndices );\r\n\r\n\t// update groups indices\r\n\r\n\tlet start = 0;\r\n\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tgroup.start = start;\r\n\t\tstart += group.count;\r\n\r\n\t}\r\n\r\n\t// merge groups\r\n\r\n\tlet currentGroup = groups[ 0 ];\r\n\r\n\tgeometry.groups = [ currentGroup ];\r\n\r\n\tfor ( let i = 1; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\r\n\r\n\t\t\tcurrentGroup.count += group.count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentGroup = group;\r\n\t\t\tgeometry.groups.push( currentGroup );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\r\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\r\n * faces that meet at an angle greater than the crease angle.\r\n *\r\n * @param {BufferGeometry} geometry\r\n * @param {number} [creaseAngle]\r\n * @return {BufferGeometry}\r\n */\r\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\r\n\r\n\tconst creaseDot = Math.cos( creaseAngle );\r\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\r\n\r\n\t// reusable vectors\r\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\r\n\tconst tempVec1 = new Vector3();\r\n\tconst tempVec2 = new Vector3();\r\n\tconst tempNorm = new Vector3();\r\n\tconst tempNorm2 = new Vector3();\r\n\r\n\t// hashes a vector\r\n\tfunction hashVertex( v ) {\r\n\r\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\r\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\r\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\r\n\t\treturn `${x},${y},${z}`;\r\n\r\n\t}\r\n\r\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\r\n\t// and returns the original geometry\r\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\r\n\tconst posAttr = resultGeometry.attributes.position;\r\n\tconst vertexMap = {};\r\n\r\n\t// find all the normals shared by commonly located vertices\r\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\r\n\r\n\t\tconst i3 = 3 * i;\r\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\r\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\r\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\r\n\r\n\t\ttempVec1.subVectors( c, b );\r\n\t\ttempVec2.subVectors( a, b );\r\n\r\n\t\t// add the normal to the map for all vertices\r\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\r\n\t\tfor ( let n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\tconst vert = verts[ n ];\r\n\t\t\tconst hash = hashVertex( vert );\r\n\t\t\tif ( ! ( hash in vertexMap ) ) {\r\n\r\n\t\t\t\tvertexMap[ hash ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertexMap[ hash ].push( normal );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// average normals from all vertices that share a common location if they are within the\r\n\t// provided crease threshold\r\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\r\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\r\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\r\n\r\n\t\t// get the face normal for this vertex\r\n\t\tconst i3 = 3 * i;\r\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\r\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\r\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\r\n\r\n\t\ttempVec1.subVectors( c, b );\r\n\t\ttempVec2.subVectors( a, b );\r\n\r\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\r\n\r\n\t\t// average all normals that meet the threshold and set the normal value\r\n\t\tfor ( let n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\tconst vert = verts[ n ];\r\n\t\t\tconst hash = hashVertex( vert );\r\n\t\t\tconst otherNormals = vertexMap[ hash ];\r\n\t\t\ttempNorm2.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\tconst otherNorm = otherNormals[ k ];\r\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\r\n\r\n\t\t\t\t\ttempNorm2.add( otherNorm );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttempNorm2.normalize();\r\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresultGeometry.setAttribute( 'normal', normAttr );\r\n\treturn resultGeometry;\r\n\r\n}\r\n\r\nexport {\r\n\tcomputeMikkTSpaceTangents,\r\n\tmergeGeometries,\r\n\tmergeAttributes,\r\n\tinterleaveAttributes,\r\n\testimateBytesUsed,\r\n\tmergeVertices,\r\n\ttoTrianglesDrawMode,\r\n\tcomputeMorphedAttributes,\r\n\tmergeGroups,\r\n\ttoCreasedNormals\r\n};\r\n"],
  "mappings": "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",
  "names": ["i", "object", "morphTargetsRelative", "a", "b", "c", "il"]
}
