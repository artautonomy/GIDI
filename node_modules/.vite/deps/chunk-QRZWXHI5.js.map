{
  "version": 3,
  "sources": ["../../three/examples/jsm/csm/CSMFrustum.js", "../../three/examples/jsm/csm/CSMShader.js", "../../three/examples/jsm/csm/CSM.js"],
  "sourcesContent": ["import { Vector3, Matrix4 } from 'three';\r\n\r\nconst inverseProjectionMatrix = new Matrix4();\r\n\r\nclass CSMFrustum {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tdata = data || {};\r\n\r\n\t\tthis.zNear = data.webGL === true ? - 1 : 0;\r\n\r\n\t\tthis.vertices = {\r\n\t\t\tnear: [\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3()\r\n\t\t\t],\r\n\t\t\tfar: [\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3()\r\n\t\t\t]\r\n\t\t};\r\n\r\n\t\tif ( data.projectionMatrix !== undefined ) {\r\n\r\n\t\t\tthis.setFromProjectionMatrix( data.projectionMatrix, data.maxFar || 10000 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetFromProjectionMatrix( projectionMatrix, maxFar ) {\r\n\r\n\t\tconst zNear = this.zNear;\r\n\t\tconst isOrthographic = projectionMatrix.elements[ 2 * 4 + 3 ] === 0;\r\n\r\n\t\tinverseProjectionMatrix.copy( projectionMatrix ).invert();\r\n\r\n\t\t// 3 --- 0  vertices.near/far order\r\n\t\t// |     |\r\n\t\t// 2 --- 1\r\n\t\t// clip space spans from [-1, 1]\r\n\r\n\t\tthis.vertices.near[ 0 ].set( 1, 1, zNear );\r\n\t\tthis.vertices.near[ 1 ].set( 1, - 1, zNear );\r\n\t\tthis.vertices.near[ 2 ].set( - 1, - 1, zNear );\r\n\t\tthis.vertices.near[ 3 ].set( - 1, 1, zNear );\r\n\t\tthis.vertices.near.forEach( function ( v ) {\r\n\r\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.vertices.far[ 0 ].set( 1, 1, 1 );\r\n\t\tthis.vertices.far[ 1 ].set( 1, - 1, 1 );\r\n\t\tthis.vertices.far[ 2 ].set( - 1, - 1, 1 );\r\n\t\tthis.vertices.far[ 3 ].set( - 1, 1, 1 );\r\n\t\tthis.vertices.far.forEach( function ( v ) {\r\n\r\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\r\n\r\n\t\t\tconst absZ = Math.abs( v.z );\r\n\t\t\tif ( isOrthographic ) {\r\n\r\n\t\t\t\tv.z *= Math.min( maxFar / absZ, 1.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.multiplyScalar( Math.min( maxFar / absZ, 1.0 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn this.vertices;\r\n\r\n\t}\r\n\r\n\tsplit( breaks, target ) {\r\n\r\n\t\twhile ( breaks.length > target.length ) {\r\n\r\n\t\t\ttarget.push( new CSMFrustum() );\r\n\r\n\t\t}\r\n\r\n\t\ttarget.length = breaks.length;\r\n\r\n\t\tfor ( let i = 0; i < breaks.length; i ++ ) {\r\n\r\n\t\t\tconst cascade = target[ i ];\r\n\r\n\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.near[ j ].copy( this.vertices.near[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.near[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i - 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( i === breaks.length - 1 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.far[ j ].copy( this.vertices.far[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.far[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoSpace( cameraMatrix, target ) {\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\ttarget.vertices.near[ i ]\r\n\t\t\t\t.copy( this.vertices.near[ i ] )\r\n\t\t\t\t.applyMatrix4( cameraMatrix );\r\n\r\n\t\t\ttarget.vertices.far[ i ]\r\n\t\t\t\t.copy( this.vertices.far[ i ] )\r\n\t\t\t\t.applyMatrix4( cameraMatrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { CSMFrustum };\r\n", "import { ShaderChunk } from 'three';\r\n\r\nconst CSMShader = {\r\n\tlights_fragment_begin: /* glsl */`\r\nvec3 geometryPosition = - vViewPosition;\r\nvec3 geometryNormal = normal;\r\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n\r\nvec3 geometryClearcoatNormal = vec3( 0.0 );\r\n\r\n#ifdef USE_CLEARCOAT\r\n\r\n\tgeometryClearcoatNormal = clearcoatNormal;\r\n\r\n#endif\r\n\r\n#ifdef USE_IRIDESCENCE\r\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\r\n\tif ( material.iridescenceThickness == 0.0 ) {\r\n\t\tmaterial.iridescence = 0.0;\r\n\t} else {\r\n\t\tmaterial.iridescence = saturate( material.iridescence );\r\n\t}\r\n\tif ( material.iridescence > 0.0 ) {\r\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\r\n\t\t// Iridescence F0 approximation\r\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\r\n\t}\r\n#endif\r\n\r\nIncidentLight directLight;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n\tPointLightShadow pointLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n\t\tpointLightShadow = pointLightShadows[ i ];\r\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n \tvec4 spotColor;\r\n\tvec3 spotLightCoord;\r\n\tbool inSpotLightMap;\r\n\r\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n\tSpotLightShadow spotLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\r\n\r\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\r\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\r\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\r\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\r\n\t\t#else\r\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\r\n\t\t#endif\r\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\r\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\r\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\r\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\r\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\r\n\t\t#endif\r\n\t\t#undef SPOT_LIGHT_MAP_INDEX\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n\t\tspotLightShadow = spotLightShadows[ i ];\r\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\r\n\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\r\n\t\tvec2 cascade;\r\n\t\tfloat cascadeCenter;\r\n\t\tfloat closestEdge;\r\n\t\tfloat margin;\r\n\t\tfloat csmx;\r\n\t\tfloat csmy;\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\tdirectionalLight = directionalLights[ i ];\r\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\r\n\r\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\r\n\t\t\t\t// cascade.x is closer, cascade.y is further\r\n\t\t\t\tcascade = CSM_cascades[ i ];\r\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\r\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\r\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\r\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\r\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\r\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\r\n\r\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\r\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\r\n\r\n\t\t\t\t\tvec3 prevColor = directLight.color;\r\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\r\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\r\n\r\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\r\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\r\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\r\n\r\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\r\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\r\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\r\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\r\n\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\t#elif defined (USE_SHADOWMAP)\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\tdirectionalLight = directionalLights[ i ];\r\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\r\n\r\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\r\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\r\n\t\t// note: no loop here - all CSM lights are in fact one light only\r\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\r\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t#endif\r\n\r\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\r\n\t\t// compute the lights not casting shadows (if any)\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\r\n\r\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 iblIrradiance = vec3( 0.0 );\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#if defined( USE_LIGHT_PROBES )\r\n\r\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\r\n\r\n\t#endif\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearcoatRadiance = vec3( 0.0 );\r\n\r\n#endif\r\n`,\r\n\tlights_pars_begin: /* glsl */`\r\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\r\nuniform vec2 CSM_cascades[CSM_CASCADES];\r\nuniform float cameraNear;\r\nuniform float shadowFar;\r\n#endif\r\n\t` + ShaderChunk.lights_pars_begin\r\n};\r\n\r\nexport { CSMShader };\r\n", "import {\r\n\tVector2,\r\n\tVector3,\r\n\tDirectionalLight,\r\n\tMathUtils,\r\n\tShaderChunk,\r\n\tMatrix4,\r\n\tBox3\r\n} from 'three';\r\nimport { CSMFrustum } from './CSMFrustum.js';\r\nimport { CSMShader } from './CSMShader.js';\r\n\r\nconst _cameraToLightMatrix = new Matrix4();\r\nconst _lightSpaceFrustum = new CSMFrustum( { webGL: true } );\r\nconst _center = new Vector3();\r\nconst _bbox = new Box3();\r\nconst _uniformArray = [];\r\nconst _logArray = [];\r\nconst _lightOrientationMatrix = new Matrix4();\r\nconst _lightOrientationMatrixInverse = new Matrix4();\r\nconst _up = new Vector3( 0, 1, 0 );\r\n\r\nexport class CSM {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tthis.camera = data.camera;\r\n\t\tthis.parent = data.parent;\r\n\t\tthis.cascades = data.cascades || 3;\r\n\t\tthis.maxFar = data.maxFar || 100000;\r\n\t\tthis.mode = data.mode || 'practical';\r\n\t\tthis.shadowMapSize = data.shadowMapSize || 2048;\r\n\t\tthis.shadowBias = data.shadowBias || 0.000001;\r\n\t\tthis.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();\r\n\t\tthis.lightIntensity = data.lightIntensity || 3;\r\n\t\tthis.lightNear = data.lightNear || 1;\r\n\t\tthis.lightFar = data.lightFar || 2000;\r\n\t\tthis.lightMargin = data.lightMargin || 200;\r\n\t\tthis.customSplitsCallback = data.customSplitsCallback;\r\n\t\tthis.fade = false;\r\n\t\tthis.mainFrustum = new CSMFrustum( { webGL: true } );\r\n\t\tthis.frustums = [];\r\n\t\tthis.breaks = [];\r\n\r\n\t\tthis.lights = [];\r\n\t\tthis.shaders = new Map();\r\n\r\n\t\tthis.createLights();\r\n\t\tthis.updateFrustums();\r\n\t\tthis.injectInclude();\r\n\r\n\t}\r\n\r\n\tcreateLights() {\r\n\r\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\r\n\r\n\t\t\tconst light = new DirectionalLight( 0xffffff, this.lightIntensity );\r\n\t\t\tlight.castShadow = true;\r\n\t\t\tlight.shadow.mapSize.width = this.shadowMapSize;\r\n\t\t\tlight.shadow.mapSize.height = this.shadowMapSize;\r\n\r\n\t\t\tlight.shadow.camera.near = this.lightNear;\r\n\t\t\tlight.shadow.camera.far = this.lightFar;\r\n\t\t\tlight.shadow.bias = this.shadowBias;\r\n\r\n\t\t\tthis.parent.add( light );\r\n\t\t\tthis.parent.add( light.target );\r\n\t\t\tthis.lights.push( light );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tinitCascades() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tcamera.updateProjectionMatrix();\r\n\t\tthis.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );\r\n\t\tthis.mainFrustum.split( this.breaks, this.frustums );\r\n\r\n\t}\r\n\r\n\tupdateShadowBounds() {\r\n\r\n\t\tconst frustums = this.frustums;\r\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\r\n\r\n\t\t\tconst light = this.lights[ i ];\r\n\t\t\tconst shadowCam = light.shadow.camera;\r\n\t\t\tconst frustum = this.frustums[ i ];\r\n\r\n\t\t\t// Get the two points that represent that furthest points on the frustum assuming\r\n\t\t\t// that's either the diagonal across the far plane or the diagonal across the whole\r\n\t\t\t// frustum itself.\r\n\t\t\tconst nearVerts = frustum.vertices.near;\r\n\t\t\tconst farVerts = frustum.vertices.far;\r\n\t\t\tconst point1 = farVerts[ 0 ];\r\n\t\t\tlet point2;\r\n\t\t\tif ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {\r\n\r\n\t\t\t\tpoint2 = farVerts[ 2 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tpoint2 = nearVerts[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet squaredBBWidth = point1.distanceTo( point2 );\r\n\t\t\tif ( this.fade ) {\r\n\r\n\t\t\t\t// expand the shadow extents by the fade margin if fade is enabled.\r\n\t\t\t\tconst camera = this.camera;\r\n\t\t\t\tconst far = Math.max( camera.far, this.maxFar );\r\n\t\t\t\tconst linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );\r\n\t\t\t\tconst margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );\r\n\r\n\t\t\t\tsquaredBBWidth += margin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowCam.left = - squaredBBWidth / 2;\r\n\t\t\tshadowCam.right = squaredBBWidth / 2;\r\n\t\t\tshadowCam.top = squaredBBWidth / 2;\r\n\t\t\tshadowCam.bottom = - squaredBBWidth / 2;\r\n\t\t\tshadowCam.updateProjectionMatrix();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetBreaks() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tconst far = Math.min( camera.far, this.maxFar );\r\n\t\tthis.breaks.length = 0;\r\n\r\n\t\tswitch ( this.mode ) {\r\n\r\n\t\t\tcase 'uniform':\r\n\t\t\t\tuniformSplit( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'logarithmic':\r\n\t\t\t\tlogarithmicSplit( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'practical':\r\n\t\t\t\tpracticalSplit( this.cascades, camera.near, far, 0.5, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'custom':\r\n\t\t\t\tif ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );\r\n\t\t\t\tthis.customSplitsCallback( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tfunction uniformSplit( amount, near, far, target ) {\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( ( near + ( far - near ) * i / amount ) / far );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction logarithmicSplit( amount, near, far, target ) {\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( ( near * ( far / near ) ** ( i / amount ) ) / far );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction practicalSplit( amount, near, far, lambda, target ) {\r\n\r\n\t\t\t_uniformArray.length = 0;\r\n\t\t\t_logArray.length = 0;\r\n\t\t\tlogarithmicSplit( amount, near, far, _logArray );\r\n\t\t\tuniformSplit( amount, near, far, _uniformArray );\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tconst frustums = this.frustums;\r\n\r\n\t\t// for each frustum we need to find its min-max box aligned with the light orientation\r\n\t\t// the position in _lightOrientationMatrix does not matter, as we transform there and back\r\n\t\t_lightOrientationMatrix.lookAt( new Vector3(), this.lightDirection, _up );\r\n\t\t_lightOrientationMatrixInverse.copy( _lightOrientationMatrix ).invert();\r\n\r\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\r\n\r\n\t\t\tconst light = this.lights[ i ];\r\n\t\t\tconst shadowCam = light.shadow.camera;\r\n\t\t\tconst texelWidth = ( shadowCam.right - shadowCam.left ) / this.shadowMapSize;\r\n\t\t\tconst texelHeight = ( shadowCam.top - shadowCam.bottom ) / this.shadowMapSize;\r\n\t\t\t_cameraToLightMatrix.multiplyMatrices( _lightOrientationMatrixInverse, camera.matrixWorld );\r\n\t\t\tfrustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );\r\n\r\n\t\t\tconst nearVerts = _lightSpaceFrustum.vertices.near;\r\n\t\t\tconst farVerts = _lightSpaceFrustum.vertices.far;\r\n\t\t\t_bbox.makeEmpty();\r\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t_bbox.expandByPoint( nearVerts[ j ] );\r\n\t\t\t\t_bbox.expandByPoint( farVerts[ j ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_bbox.getCenter( _center );\r\n\t\t\t_center.z = _bbox.max.z + this.lightMargin;\r\n\t\t\t_center.x = Math.floor( _center.x / texelWidth ) * texelWidth;\r\n\t\t\t_center.y = Math.floor( _center.y / texelHeight ) * texelHeight;\r\n\t\t\t_center.applyMatrix4( _lightOrientationMatrix );\r\n\r\n\t\t\tlight.position.copy( _center );\r\n\t\t\tlight.target.position.copy( _center );\r\n\r\n\t\t\tlight.target.position.x += this.lightDirection.x;\r\n\t\t\tlight.target.position.y += this.lightDirection.y;\r\n\t\t\tlight.target.position.z += this.lightDirection.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tinjectInclude() {\r\n\r\n\t\tShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\r\n\t\tShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\r\n\r\n\t}\r\n\r\n\tsetupMaterial( material ) {\r\n\r\n\t\tmaterial.defines = material.defines || {};\r\n\t\tmaterial.defines.USE_CSM = 1;\r\n\t\tmaterial.defines.CSM_CASCADES = this.cascades;\r\n\r\n\t\tif ( this.fade ) {\r\n\r\n\t\t\tmaterial.defines.CSM_FADE = '';\r\n\r\n\t\t}\r\n\r\n\t\tconst breaksVec2 = [];\r\n\t\tconst scope = this;\r\n\t\tconst shaders = this.shaders;\r\n\r\n\t\tmaterial.onBeforeCompile = function ( shader ) {\r\n\r\n\t\t\tconst far = Math.min( scope.camera.far, scope.maxFar );\r\n\t\t\tscope.getExtendedBreaks( breaksVec2 );\r\n\r\n\t\t\tshader.uniforms.CSM_cascades = { value: breaksVec2 };\r\n\t\t\tshader.uniforms.cameraNear = { value: scope.camera.near };\r\n\t\t\tshader.uniforms.shadowFar = { value: far };\r\n\r\n\t\t\tshaders.set( material, shader );\r\n\r\n\t\t};\r\n\r\n\t\tshaders.set( material, null );\r\n\r\n\t}\r\n\r\n\tupdateUniforms() {\r\n\r\n\t\tconst far = Math.min( this.camera.far, this.maxFar );\r\n\t\tconst shaders = this.shaders;\r\n\r\n\t\tshaders.forEach( function ( shader, material ) {\r\n\r\n\t\t\tif ( shader !== null ) {\r\n\r\n\t\t\t\tconst uniforms = shader.uniforms;\r\n\t\t\t\tthis.getExtendedBreaks( uniforms.CSM_cascades.value );\r\n\t\t\t\tuniforms.cameraNear.value = this.camera.near;\r\n\t\t\t\tuniforms.shadowFar.value = far;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! this.fade && 'CSM_FADE' in material.defines ) {\r\n\r\n\t\t\t\tdelete material.defines.CSM_FADE;\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t} else if ( this.fade && ! ( 'CSM_FADE' in material.defines ) ) {\r\n\r\n\t\t\t\tmaterial.defines.CSM_FADE = '';\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}, this );\r\n\r\n\t}\r\n\r\n\tgetExtendedBreaks( target ) {\r\n\r\n\t\twhile ( target.length < this.breaks.length ) {\r\n\r\n\t\t\ttarget.push( new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\ttarget.length = this.breaks.length;\r\n\r\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\r\n\r\n\t\t\tconst amount = this.breaks[ i ];\r\n\t\t\tconst prev = this.breaks[ i - 1 ] || 0;\r\n\t\t\ttarget[ i ].x = prev;\r\n\t\t\ttarget[ i ].y = amount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateFrustums() {\r\n\r\n\t\tthis.getBreaks();\r\n\t\tthis.initCascades();\r\n\t\tthis.updateShadowBounds();\r\n\t\tthis.updateUniforms();\r\n\r\n\t}\r\n\r\n\tremove() {\r\n\r\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\r\n\r\n\t\t\tthis.parent.remove( this.lights[ i ].target );\r\n\t\t\tthis.parent.remove( this.lights[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tconst shaders = this.shaders;\r\n\t\tshaders.forEach( function ( shader, material ) {\r\n\r\n\t\t\tdelete material.onBeforeCompile;\r\n\t\t\tdelete material.defines.USE_CSM;\r\n\t\t\tdelete material.defines.CSM_CASCADES;\r\n\t\t\tdelete material.defines.CSM_FADE;\r\n\r\n\t\t\tif ( shader !== null ) {\r\n\r\n\t\t\t\tdelete shader.uniforms.CSM_cascades;\r\n\t\t\t\tdelete shader.uniforms.cameraNear;\r\n\t\t\t\tdelete shader.uniforms.shadowFar;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t} );\r\n\t\tshaders.clear();\r\n\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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AAAA,IAE9B;AAAA,EAED;AAED;;;ACtJA,IAAM,YAAY;AAAA,EACjB;AAAA;AAAA,IAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["far"]
}
