import {
  mitt_default
} from "./chunk-SKZTLOIB.js";
import {
  AgXToneMapping,
  ColorManagement,
  PCFSoftShadowMap,
  PerspectiveCamera,
  REVISION,
  Scene,
  WebGLRenderer,
  three_module_exports
} from "./chunk-5LA6WP7F.js";
import {
  fromStore
} from "./chunk-YB2SDMOJ.js";
import {
  derived as derived2,
  get as get2,
  readable,
  writable
} from "./chunk-CUEHFFWS.js";
import {
  add_locations,
  append_styles,
  bind_this,
  check_target,
  cleanup_styles,
  hmr,
  if_block,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  rest_props,
  snippet,
  spread_props,
  validate_prop_bindings,
  wrap_snippet
} from "./chunk-DVXCBMAG.js";
import {
  append,
  comment,
  template
} from "./chunk-457JZRJI.js";
import {
  FILENAME,
  HMR,
  child,
  derived,
  first_child,
  get,
  getContext,
  mark_module_end,
  mark_module_start,
  noop,
  pop,
  push,
  reset,
  set,
  setContext,
  state,
  strict_equals,
  tick,
  untrack,
  user_effect,
  user_pre_effect
} from "./chunk-6B2HMSQ2.js";
import {
  __publicField
} from "./chunk-B4Q33VKO.js";

// node_modules/@threlte/core/dist/context/fragments/cache.js
var shallowEqualArrays = (arrA, arrB) => {
  if (arrA === arrB)
    return true;
  if (!arrA || !arrB)
    return false;
  const len = arrA.length;
  if (arrB.length !== len)
    return false;
  for (let i = 0; i < len; i++)
    if (arrA[i] !== arrB[i])
      return false;
  return true;
};
var createCacheContext = () => {
  const items = [];
  const remember = (callback, keys) => {
    for (let i = 0; i < items.length; i++) {
      const entry2 = items[i];
      if (shallowEqualArrays(keys, entry2.keys)) {
        if (entry2.promise)
          return entry2.promise;
      }
    }
    const entry = {
      promise: callback(),
      keys
    };
    items.push(entry);
    return entry.promise;
  };
  const clear = (keys) => {
    for (let i = 0; i < items.length; i++) {
      const entry = items[i];
      if (shallowEqualArrays(keys, entry.keys)) {
        items.splice(i, 1);
        return;
      }
    }
  };
  const context = { items, remember, clear };
  setContext("threlte-cache", context);
  return context;
};
var useCache = () => {
  const cache = getContext("threlte-cache");
  if (!cache) {
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  }
  return cache;
};

// node_modules/@threlte/core/dist/utilities/observe.svelte.js
var signal = Symbol();
var isStore = (dep) => {
  return strict_equals(typeof (dep == null ? void 0 : dep.subscribe), "function");
};
var runObserve = (dependencies, callback, pre) => {
  const stores = dependencies().map((d) => {
    if (isStore(d)) {
      return fromStore(d);
    }
    return signal;
  });
  const deps = derived(() => dependencies().map((d, i) => {
    if (strict_equals(stores[i], signal)) return d;
    return stores[i].current;
  }));
  const effect = () => {
    get(deps);
    let cleanup = void 0;
    untrack(() => {
      cleanup = callback(get(deps));
    });
    return cleanup;
  };
  if (pre) {
    user_pre_effect(effect);
  } else {
    user_effect(effect);
  }
};
var observePost = (dependencies, callback) => {
  return runObserve(dependencies, callback, false);
};
var observePre = (dependencies, callback) => {
  return runObserve(dependencies, callback, true);
};
var observe = Object.assign(observePost, { pre: observePre });

// node_modules/@threlte/core/dist/utilities/isInstanceOf.js
var isInstanceOf = (obj, type) => {
  return (obj == null ? void 0 : obj[`is${type}`]) === true;
};

// node_modules/@threlte/core/dist/utilities/asyncWritable.js
var asyncWritable = (promise) => {
  const store = writable(void 0);
  const error = writable(void 0);
  promise.then((result) => {
    store.set(result);
  }).catch((e) => {
    console.error("Error in asyncWritable:", e.message);
    error.set(e);
  });
  return Object.assign(Object.assign(promise, store), { error, promise });
};

// node_modules/@threlte/core/dist/utilities/browser.js
var browser = typeof window !== "undefined";

// node_modules/@threlte/core/dist/utilities/revision.js
var normalizedRevision = REVISION.replace("dev", "");
var revision = Number.parseInt(normalizedRevision);

// node_modules/@threlte/core/dist/utilities/watch.js
var watch = (stores, callback) => {
  const d = derived2(stores, (values) => {
    return values;
  });
  let cleanupFn;
  const unsubscribe = d.subscribe(async (values) => {
    if (cleanupFn)
      cleanupFn();
    const fn = await callback(values);
    if (fn)
      cleanupFn = fn;
  });
  onDestroy(() => {
    unsubscribe();
    if (cleanupFn)
      cleanupFn();
  });
};

// node_modules/@threlte/core/dist/utilities/currentWritable.js
var currentWritable = (value) => {
  const store = writable(value);
  const extendedWritable = {
    set: (value2) => {
      extendedWritable.current = value2;
      store.set(value2);
    },
    subscribe: store.subscribe,
    update: (fn) => {
      const newValue = fn(extendedWritable.current);
      extendedWritable.current = newValue;
      store.set(newValue);
    },
    current: value
  };
  return extendedWritable;
};
var toCurrentReadable = (store) => {
  return {
    subscribe: store.subscribe,
    get current() {
      return store.current;
    }
  };
};

// node_modules/@threlte/core/dist/utilities/resolvePropertyPath.js
var resolvePropertyPath = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key
    };
  } else {
    return {
      target,
      key: propertyPath
    };
  }
};

// node_modules/@threlte/core/dist/context/fragments/canvas.js
var createCanvasContext = (options) => {
  const wrapperRect = options.wrapper.getBoundingClientRect();
  let lastWidth = wrapperRect.width;
  let lastHeight = wrapperRect.height;
  const size = currentWritable({ width: wrapperRect.width, height: wrapperRect.height });
  onMount(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width === lastWidth && height === lastHeight)
          return;
        lastWidth = width;
        lastHeight = height;
        size.set({ width, height });
      }
    });
    resizeObserver.observe(options.wrapper);
    return () => {
      resizeObserver.disconnect();
    };
  });
  const context = {
    wrapper: options.wrapper,
    canvas: options.canvas,
    size: toCurrentReadable(size)
  };
  setContext("threlte-canvas-context", context);
  return context;
};
var useCanvas = () => {
  const context = getContext("threlte-canvas-context");
  if (!context) {
    throw new Error("useCanvas can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/frame-scheduling/DAG.js
var DAG = class {
  constructor() {
    __publicField(this, "allVertices", {});
    /** Nodes that are fully unlinked */
    __publicField(this, "isolatedVertices", {});
    __publicField(this, "connectedVertices", {});
    __publicField(this, "sortedConnectedValues", []);
    __publicField(this, "needsSort", false);
    __publicField(this, "emitter", mitt_default());
    __publicField(this, "emit", this.emitter.emit.bind(this.emitter));
    __publicField(this, "on", this.emitter.on.bind(this.emitter));
    __publicField(this, "off", this.emitter.off.bind(this.emitter));
    __publicField(this, "getKey", (v) => {
      if (typeof v === "object") {
        return v.key;
      }
      return v;
    });
  }
  get sortedVertices() {
    return this.mapNodes((value) => value);
  }
  moveToIsolated(key) {
    const vertex = this.connectedVertices[key];
    if (!vertex)
      return;
    this.isolatedVertices[key] = vertex;
    delete this.connectedVertices[key];
  }
  moveToConnected(key) {
    const vertex = this.isolatedVertices[key];
    if (!vertex)
      return;
    this.connectedVertices[key] = vertex;
    delete this.isolatedVertices[key];
  }
  add(key, value, options) {
    if (this.allVertices[key] && this.allVertices[key].value !== void 0) {
      throw new Error(`A node with the key ${key.toString()} already exists`);
    }
    let vertex = this.allVertices[key];
    if (!vertex) {
      vertex = {
        value,
        previous: /* @__PURE__ */ new Set(),
        next: /* @__PURE__ */ new Set()
      };
      this.allVertices[key] = vertex;
    } else if (vertex.value === void 0) {
      vertex.value = value;
    }
    const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;
    if (!(options == null ? void 0 : options.after) && !(options == null ? void 0 : options.before) && !hasEdges) {
      this.isolatedVertices[key] = vertex;
      this.emit("node:added", {
        key,
        type: "isolated",
        value
      });
      return;
    } else {
      this.connectedVertices[key] = vertex;
    }
    if (options == null ? void 0 : options.after) {
      const afterArr = Array.isArray(options.after) ? options.after : [options.after];
      afterArr.forEach((after) => {
        vertex.previous.add(this.getKey(after));
      });
      afterArr.forEach((after) => {
        const afterKey = this.getKey(after);
        const linkedAfter = this.allVertices[afterKey];
        if (!linkedAfter) {
          this.allVertices[afterKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set(),
            next: /* @__PURE__ */ new Set([key])
          };
          this.connectedVertices[afterKey] = this.allVertices[afterKey];
        } else {
          linkedAfter.next.add(key);
          this.moveToConnected(afterKey);
        }
      });
    }
    if (options == null ? void 0 : options.before) {
      const beforeArr = Array.isArray(options.before) ? options.before : [options.before];
      beforeArr.forEach((before) => {
        vertex.next.add(this.getKey(before));
      });
      beforeArr.forEach((before) => {
        const beforeKey = this.getKey(before);
        const linkedBefore = this.allVertices[beforeKey];
        if (!linkedBefore) {
          this.allVertices[beforeKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set([key]),
            next: /* @__PURE__ */ new Set()
          };
          this.connectedVertices[beforeKey] = this.allVertices[beforeKey];
        } else {
          linkedBefore.previous.add(key);
          this.moveToConnected(beforeKey);
        }
      });
    }
    this.emit("node:added", {
      key,
      type: "connected",
      value
    });
    this.needsSort = true;
  }
  remove(key) {
    const removeKey = this.getKey(key);
    const unlinkedVertex = this.isolatedVertices[removeKey];
    if (unlinkedVertex) {
      delete this.isolatedVertices[removeKey];
      delete this.allVertices[removeKey];
      this.emit("node:removed", {
        key: removeKey,
        type: "isolated"
      });
      return;
    }
    const linkedVertex = this.connectedVertices[removeKey];
    if (!linkedVertex) {
      return;
    }
    linkedVertex.next.forEach((nextKey) => {
      const nextVertex = this.connectedVertices[nextKey];
      if (nextVertex) {
        nextVertex.previous.delete(removeKey);
        if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {
          this.moveToIsolated(nextKey);
        }
      }
    });
    linkedVertex.previous.forEach((prevKey) => {
      const prevVertex = this.connectedVertices[prevKey];
      if (prevVertex) {
        prevVertex.next.delete(removeKey);
        if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {
          this.moveToIsolated(prevKey);
        }
      }
    });
    delete this.connectedVertices[removeKey];
    delete this.allVertices[removeKey];
    this.emit("node:removed", {
      key: removeKey,
      type: "connected"
    });
    this.needsSort = true;
  }
  mapNodes(callback) {
    if (this.needsSort) {
      this.sort();
    }
    const result = [];
    this.forEachNode((value, index) => {
      result.push(callback(value, index));
    });
    return result;
  }
  forEachNode(callback) {
    if (this.needsSort) {
      this.sort();
    }
    let index = 0;
    for (; index < this.sortedConnectedValues.length; index++) {
      callback(this.sortedConnectedValues[index], index);
    }
    Reflect.ownKeys(this.isolatedVertices).forEach((key) => {
      const vertex = this.isolatedVertices[key];
      if (vertex.value !== void 0)
        callback(vertex.value, index++);
    });
  }
  getValueByKey(key) {
    var _a;
    return (_a = this.allVertices[key]) == null ? void 0 : _a.value;
  }
  getKeyByValue(value) {
    return Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ?? Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value);
  }
  sort() {
    var _a;
    const inDegree = /* @__PURE__ */ new Map();
    const zeroInDegreeQueue = [];
    const result = [];
    const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {
      const vertex = this.connectedVertices[key];
      return vertex.value !== void 0;
    });
    connectedVertexKeysWithValues.forEach((vertex) => {
      inDegree.set(vertex, 0);
    });
    connectedVertexKeysWithValues.forEach((vertexKey) => {
      const vertex = this.connectedVertices[vertexKey];
      vertex.next.forEach((next) => {
        const nextVertex = this.connectedVertices[next];
        if (!nextVertex)
          return;
        inDegree.set(next, (inDegree.get(next) || 0) + 1);
      });
    });
    inDegree.forEach((degree, value) => {
      if (degree === 0) {
        zeroInDegreeQueue.push(value);
      }
    });
    while (zeroInDegreeQueue.length > 0) {
      const vertexKey = zeroInDegreeQueue.shift();
      result.push(vertexKey);
      const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);
      if (v) {
        (_a = this.connectedVertices[v]) == null ? void 0 : _a.next.forEach((adjVertex) => {
          const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;
          inDegree.set(adjVertex, adjVertexInDegree);
          if (adjVertexInDegree === 0) {
            zeroInDegreeQueue.push(adjVertex);
          }
        });
      }
    }
    if (result.length !== connectedVertexKeysWithValues.length) {
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    }
    const filterUndefined = (value) => value !== void 0;
    this.sortedConnectedValues = result.map((key) => this.connectedVertices[key].value).filter(filterUndefined);
    this.needsSort = false;
  }
  clear() {
    this.allVertices = {};
    this.isolatedVertices = {};
    this.connectedVertices = {};
    this.sortedConnectedValues = [];
    this.needsSort = false;
  }
  static isKey(value) {
    return typeof value === "string" || typeof value === "symbol";
  }
  static isValue(value) {
    return typeof value === "object" && "key" in value;
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Task.js
var Task = class {
  constructor(stage, key, callback) {
    __publicField(this, "key");
    __publicField(this, "stage");
    __publicField(this, "callback");
    __publicField(this, "runTask", true);
    this.stage = stage;
    this.key = key;
    this.callback = callback;
  }
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  run(delta) {
    if (!this.runTask)
      return;
    this.callback(delta);
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Stage.js
var Stage = class extends DAG {
  constructor(scheduler, key, callback) {
    super();
    __publicField(this, "key");
    __publicField(this, "scheduler");
    __publicField(this, "runTask", true);
    __publicField(this, "callback", (_, r) => r());
    __publicField(this, "removeTask", this.remove.bind(this));
    this.scheduler = scheduler;
    this.key = key;
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    if (callback)
      this.callback = callback.bind(this);
  }
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  get tasks() {
    return this.sortedVertices;
  }
  createTask(key, callback, options) {
    const task = new Task(this, key, callback);
    this.add(key, task, options);
    return task;
  }
  getTask(key) {
    return this.getValueByKey(key);
  }
  run(delta) {
    if (!this.runTask)
      return;
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        task.run(deltaOverride ?? delta);
      });
    });
  }
  runWithTiming(delta) {
    if (!this.runTask)
      return {};
    const taskTimings = {};
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        const start = performance.now();
        task.run(deltaOverride ?? delta);
        const duration = performance.now() - start;
        taskTimings[task.key] = duration;
      });
    });
    return taskTimings;
  }
  getSchedule() {
    return this.mapNodes((l) => l.key.toString());
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Scheduler.js
var Scheduler = class extends DAG {
  constructor(options) {
    super();
    __publicField(this, "lastTime", performance.now());
    __publicField(this, "clampDeltaTo", 0.1);
    __publicField(this, "removeStage", this.remove.bind(this));
    if (options == null ? void 0 : options.clampDeltaTo)
      this.clampDeltaTo = options.clampDeltaTo;
    this.run = this.run.bind(this);
  }
  get stages() {
    return this.sortedVertices;
  }
  createStage(key, options) {
    const stage = new Stage(this, key, options == null ? void 0 : options.callback);
    this.add(key, stage, {
      after: options == null ? void 0 : options.after,
      before: options == null ? void 0 : options.before
    });
    return stage;
  }
  getStage(key) {
    return this.getValueByKey(key);
  }
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(time) {
    const delta = time - this.lastTime;
    this.forEachNode((stage) => {
      stage.run(Math.min(delta / 1e3, this.clampDeltaTo));
    });
    this.lastTime = time;
  }
  runWithTiming(time) {
    const delta = time - this.lastTime;
    const stageTimings = {};
    const start = performance.now();
    this.forEachNode((stage) => {
      const start2 = performance.now();
      const taskTimings = stage.runWithTiming(Math.min(delta / 1e3, this.clampDeltaTo));
      const duration = performance.now() - start2;
      stageTimings[stage.key.toString()] = {
        duration,
        tasks: taskTimings
      };
    });
    return {
      total: performance.now() - start,
      stages: stageTimings
    };
  }
  getSchedule(include = {
    tasks: true
  }) {
    return {
      stages: this.mapNodes((stage) => {
        if (stage === void 0)
          throw new Error("Stage not found");
        return {
          key: stage.key.toString(),
          ...{ tasks: include.tasks ? stage.getSchedule() : void 0 }
        };
      })
    };
  }
  dispose() {
    this.clear();
  }
};

// node_modules/@threlte/core/dist/context/fragments/scheduler.svelte.js
var createSchedulerContext = (options) => {
  const scheduler = new Scheduler();
  const mainStage = scheduler.createStage(Symbol("threlte-main-stage"));
  const context = {
    scheduler,
    frameInvalidated: true,
    autoInvalidations: /* @__PURE__ */ new Set(),
    shouldAdvance: false,
    advance: () => {
      context.shouldAdvance = true;
    },
    autoRender: currentWritable(options.autoRender ?? true),
    renderMode: currentWritable(options.renderMode ?? "on-demand"),
    invalidate() {
      context.frameInvalidated = true;
    },
    mainStage,
    shouldRender: () => {
      return strict_equals(context.renderMode.current, "always") || strict_equals(context.renderMode.current, "on-demand") && (context.frameInvalidated || context.autoInvalidations.size > 0) || strict_equals(context.renderMode.current, "manual") && context.shouldAdvance;
    },
    renderStage: scheduler.createStage(Symbol("threlte-render-stage"), {
      after: mainStage,
      callback(_, runTasks) {
        if (context.shouldRender()) runTasks();
      }
    }),
    resetFrameInvalidation() {
      context.frameInvalidated = false;
      context.shouldAdvance = false;
    }
  };
  user_effect(() => {
    context.autoRender.set(options.autoRender ?? true);
  });
  user_effect(() => {
    context.renderMode.set(options.renderMode ?? "on-demand");
  });
  onDestroy(() => {
    context.scheduler.dispose();
  });
  setContext("threlte-scheduler-context", context);
  return context;
};
var useScheduler = () => {
  const context = getContext("threlte-scheduler-context");
  if (!context) {
    throw new Error("useScheduler can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/camera.js
var createCameraContext = () => {
  const { size } = useCanvas();
  const { invalidate } = useScheduler();
  const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
  defaultCamera.position.z = 5;
  defaultCamera.lookAt(0, 0, 0);
  const camera = currentWritable(defaultCamera);
  watch(size, (size2) => {
    if (camera.current === defaultCamera) {
      const cam = camera.current;
      cam.aspect = size2.width / size2.height;
      cam.updateProjectionMatrix();
      invalidate();
    }
  });
  const context = { camera };
  setContext("threlte-camera-context", context);
  return context;
};
var useCamera = () => {
  const context = getContext("threlte-camera-context");
  if (!context) {
    throw new Error("useCamera can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/disposal.js
var createDisposalContext = () => {
  const context = {
    removeObjectFromDisposal: (object) => {
      context.disposableObjects.delete(object);
    },
    disposableObjectMounted: (object) => {
      const currentValue = context.disposableObjects.get(object);
      if (currentValue) {
        context.disposableObjects.set(object, currentValue + 1);
      } else {
        context.disposableObjects.set(object, 1);
      }
    },
    disposableObjectUnmounted: (object) => {
      const currentValue = context.disposableObjects.get(object);
      if (currentValue && currentValue > 0) {
        context.disposableObjects.set(object, currentValue - 1);
        if (currentValue - 1 <= 0) {
          context.shouldDispose = true;
        }
      }
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false,
    dispose: async (force = false) => {
      await tick();
      if (!context.shouldDispose && !force)
        return;
      context.disposableObjects.forEach((mounted, object) => {
        var _a;
        if (mounted === 0 || force) {
          (_a = object == null ? void 0 : object.dispose) == null ? void 0 : _a.call(object);
          context.disposableObjects.delete(object);
        }
      });
      context.shouldDispose = false;
    }
  };
  onDestroy(() => {
    context.dispose(true);
  });
  setContext("threlte-disposal-context", context);
  return context;
};
var useDisposal = () => {
  const context = getContext("threlte-disposal-context");
  if (!context) {
    throw new Error("useDisposal can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/parent.js
var parentContextKey = Symbol("threlte-parent-context");
var createParentContext = (parent) => {
  const ctx = currentWritable(parent);
  setContext(parentContextKey, ctx);
  return ctx;
};
var useParent = () => {
  const parent = getContext(parentContextKey);
  return parent;
};

// node_modules/@threlte/core/dist/context/fragments/parentObject3D.js
var parentObject3DContextKey = Symbol("threlte-parent-object3d-context");
var createRootParentObject3DContext = (object) => {
  const ctx = readable(object);
  setContext(parentObject3DContextKey, ctx);
  return ctx;
};
var createParentObject3DContext = (object) => {
  const parentObject3D = getContext(parentObject3DContextKey);
  const object3D = writable(object);
  const ctx = derived2([object3D, parentObject3D], ([object3D2, parentObject3D2]) => {
    return object3D2 ?? parentObject3D2;
  });
  setContext(parentObject3DContextKey, ctx);
  return object3D;
};
var useParentObject3D = () => {
  return getContext(parentObject3DContextKey);
};

// node_modules/@threlte/core/dist/hooks/useTask.js
function useTask(keyOrFn, fnOrOptions, options) {
  if (!browser) {
    return {
      task: void 0,
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  let key;
  let fn;
  let opts;
  if (DAG.isKey(keyOrFn)) {
    key = keyOrFn;
    fn = fnOrOptions;
    opts = options;
  } else {
    key = Symbol("useTask");
    fn = keyOrFn;
    opts = fnOrOptions;
  }
  const schedulerCtx = useScheduler();
  let stage = schedulerCtx.mainStage;
  if (opts) {
    if (opts.stage) {
      if (DAG.isValue(opts.stage)) {
        stage = opts.stage;
      } else {
        const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);
        if (!maybeStage) {
          throw new Error(`No stage found with key ${opts.stage.toString()}`);
        }
        stage = maybeStage;
      }
    } else if (opts.after) {
      if (Array.isArray(opts.after)) {
        for (let index = 0; index < opts.after.length; index++) {
          const element = opts.after[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.after)) {
        stage = opts.after.stage;
      }
    } else if (opts.before) {
      if (Array.isArray(opts.before)) {
        for (let index = 0; index < opts.before.length; index++) {
          const element = opts.before[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.before)) {
        stage = opts.before.stage;
      }
    }
  }
  const started = writable(false);
  const task = stage.createTask(key, fn, opts);
  const start = () => {
    started.set(true);
    if ((opts == null ? void 0 : opts.autoInvalidate) ?? true) {
      schedulerCtx.autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(false);
    if ((opts == null ? void 0 : opts.autoInvalidate) ?? true) {
      schedulerCtx.autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if ((opts == null ? void 0 : opts.autoStart) ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    if (!stage)
      return;
    stage.removeTask(key);
  });
  return {
    task,
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
}

// node_modules/@threlte/core/dist/context/fragments/scene.js
var createSceneContext = (scene) => {
  const context = { scene: scene || new Scene() };
  setContext("threlte-scene-context", context);
  return context;
};
var useScene = () => {
  const context = getContext("threlte-scene-context");
  if (!context) {
    throw new Error("useScene can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/renderer.svelte.js
var createRendererContext = (options) => {
  const { dispose } = useDisposal();
  const { camera } = useCamera();
  const { scene } = useScene();
  const {
    invalidate,
    renderStage,
    autoRender,
    scheduler,
    resetFrameInvalidation
  } = useScheduler();
  const { canvas, size } = useCanvas();
  const renderer = options.createRenderer ? options.createRenderer(canvas) : new WebGLRenderer({
    canvas,
    powerPreference: "high-performance",
    antialias: true,
    alpha: true
  });
  const autoRenderTask = renderStage.createTask(Symbol("threlte-auto-render-task"), () => {
    renderer.render(scene, camera.current);
  });
  const context = {
    renderer,
    colorManagementEnabled: currentWritable(options.colorManagementEnabled ?? true),
    colorSpace: currentWritable(options.colorSpace ?? "srgb"),
    dpr: currentWritable(options.dpr ?? window.devicePixelRatio),
    shadows: currentWritable(options.shadows ?? PCFSoftShadowMap),
    toneMapping: currentWritable(options.toneMapping ?? AgXToneMapping),
    autoRenderTask
  };
  setContext("threlte-renderer-context", context);
  watch([context.colorManagementEnabled], ([colorManagementEnabled]) => {
    ColorManagement.enabled = colorManagementEnabled;
  });
  watch([context.colorSpace], ([colorSpace]) => {
    if ("outputColorSpace" in renderer) {
      renderer.outputColorSpace = colorSpace;
    }
  });
  watch([context.dpr], ([dpr]) => {
    if ("setPixelRatio" in renderer) {
      renderer.setPixelRatio(dpr);
    }
  });
  const { start, stop } = useTask(
    () => {
      var _a;
      if (!("xr" in renderer) || ((_a = renderer.xr) == null ? void 0 : _a.isPresenting)) return;
      renderer.setSize(size.current.width, size.current.height);
      invalidate();
      stop();
    },
    {
      before: autoRenderTask,
      autoStart: false,
      autoInvalidate: false
    }
  );
  watch([size], () => {
    start();
  });
  watch([context.shadows], ([shadows]) => {
    if (!("shadowMap" in renderer)) return;
    renderer.shadowMap.enabled = !!shadows;
    if (shadows && strict_equals(shadows, true, false)) {
      renderer.shadowMap.type = shadows;
    } else if (strict_equals(shadows, true)) {
      renderer.shadowMap.type = PCFSoftShadowMap;
    }
  });
  watch([context.toneMapping], ([toneMapping]) => {
    if (!("toneMapping" in renderer)) return;
    renderer.toneMapping = toneMapping;
  });
  watch([autoRender], ([autoRender2]) => {
    if (autoRender2) {
      context.autoRenderTask.start();
    } else {
      context.autoRenderTask.stop();
    }
    return () => {
      context.autoRenderTask.stop();
    };
  });
  if ("setAnimationLoop" in context.renderer) {
    const renderer2 = context.renderer;
    renderer2.setAnimationLoop((time) => {
      dispose();
      scheduler.run(time);
      resetFrameInvalidation();
    });
  }
  onDestroy(() => {
    if ("dispose" in context.renderer) {
      const dispose2 = context.renderer.dispose;
      dispose2();
    }
  });
  user_effect(() => {
    context.colorManagementEnabled.set(options.colorManagementEnabled ?? true);
  });
  user_effect(() => {
    context.colorSpace.set(options.colorSpace ?? "srgb");
  });
  user_effect(() => {
    context.toneMapping.set(options.toneMapping ?? AgXToneMapping);
  });
  user_effect(() => {
    context.shadows.set(options.shadows ?? PCFSoftShadowMap);
  });
  user_effect(() => {
    context.dpr.set(options.dpr ?? window.devicePixelRatio);
  });
  return context;
};
var useRenderer = () => {
  const context = getContext("threlte-renderer-context");
  if (!context) {
    throw new Error("useRenderer can only be used in a child component to <Canvas>.");
  }
  return context;
};

// node_modules/@threlte/core/dist/context/fragments/user.js
var createUserContext = () => {
  const userCtx = currentWritable({});
  setContext("threlte-user-context", userCtx);
};

// node_modules/@threlte/core/dist/context/createThrelteContext.svelte.js
var createThrelteContext = (options) => {
  createCanvasContext(options);
  createCacheContext();
  const { scene } = createSceneContext();
  createParentContext(scene);
  createRootParentObject3DContext(scene);
  createDisposalContext();
  createSchedulerContext(options);
  createCameraContext();
  createRendererContext(options);
  createUserContext();
};

// node_modules/@threlte/core/dist/components/Context/Context.svelte
mark_module_start();
Context[FILENAME] = "node_modules/@threlte/core/dist/components/Context/Context.svelte";
function Context($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context);
  validate_prop_bindings($$props, [], [], Context);
  let rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children"
    ],
    "rest"
  );
  createThrelteContext(rest);
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context = hmr(Context, () => Context[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context[HMR].source;
    set(Context[HMR].source, module.default[HMR].original);
  });
}
var Context_default = Context;
mark_module_end(Context);

// node_modules/@threlte/core/dist/Canvas.svelte
mark_module_start();
Canvas[FILENAME] = "node_modules/@threlte/core/dist/Canvas.svelte";
var root = add_locations(template(`<div class="s-JZDOlXZiom9z"><canvas class="s-JZDOlXZiom9z"><!></canvas></div>`), Canvas[FILENAME], [[8, 0, [[9, 2]]]]);
var $$css = {
  hash: "s-JZDOlXZiom9z",
  code: "\n  div.s-JZDOlXZiom9z {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n  canvas.s-JZDOlXZiom9z {\n    display: block;\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBc0JBLEVBQUUsa0JBQUcsQ0FBQztBQUNOLElBQUksa0JBQWtCO0FBQ3RCLElBQUksV0FBVztBQUNmLElBQUksWUFBWTtBQUNoQjs7QUFFQSxFQUFFLHFCQUFNLENBQUM7QUFDVCxJQUFJLGNBQWM7QUFDbEIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxXQUFXO0FBQ2YsSUFBSSxZQUFZO0FBQ2hCIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDYW52YXMuc3ZlbHRlIl19 */"
};
function Canvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Canvas);
  append_styles($$anchor, $$css);
  validate_prop_bindings($$props, [], [], Canvas);
  let rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children"
    ],
    "rest"
  );
  let canvas = state(void 0);
  let wrapper = state(void 0);
  var div = root();
  var canvas_1 = child(div);
  var node = child(canvas_1);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      Context_default(node_1, spread_props(
        {
          get wrapper() {
            return get(wrapper);
          },
          get canvas() {
            return get(canvas);
          }
        },
        () => rest,
        {
          children: wrap_snippet(Canvas, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_2 = first_child(fragment_1);
            snippet(node_2, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      ));
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (get(canvas) && get(wrapper)) $$render(consequent);
    });
  }
  reset(canvas_1);
  bind_this(canvas_1, ($$value) => set(canvas, $$value), () => get(canvas));
  reset(div);
  bind_this(div, ($$value) => set(wrapper, $$value), () => get(wrapper));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Canvas = hmr(Canvas, () => Canvas[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-JZDOlXZiom9z");
    module.default[HMR].source = Canvas[HMR].source;
    set(Canvas[HMR].source, module.default[HMR].original);
  });
}
var Canvas_default = Canvas;
mark_module_end(Canvas);

// node_modules/@threlte/core/dist/context/compounds/useThrelte.js
var useThrelte = () => {
  const schedulerCtx = useScheduler();
  const rendererCtx = useRenderer();
  const cameraCtx = useCamera();
  const sceneCtx = useScene();
  const canvasCtx = useCanvas();
  const context = {
    advance: schedulerCtx.advance,
    autoRender: schedulerCtx.autoRender,
    autoRenderTask: rendererCtx.autoRenderTask,
    camera: cameraCtx.camera,
    colorManagementEnabled: rendererCtx.colorManagementEnabled,
    colorSpace: rendererCtx.colorSpace,
    dpr: rendererCtx.dpr,
    invalidate: schedulerCtx.invalidate,
    mainStage: schedulerCtx.mainStage,
    renderer: rendererCtx.renderer,
    renderMode: schedulerCtx.renderMode,
    renderStage: schedulerCtx.renderStage,
    scheduler: schedulerCtx.scheduler,
    shadows: rendererCtx.shadows,
    shouldRender: schedulerCtx.shouldRender,
    size: canvasCtx.size,
    toneMapping: rendererCtx.toneMapping,
    get scene() {
      return sceneCtx.scene;
    },
    set scene(scene) {
      sceneCtx.scene = scene;
    }
  };
  return context;
};

// node_modules/@threlte/core/dist/components/T/utils/useAttach.js
var isObject = (ref) => {
  return typeof ref === "object" && ref !== null;
};
var useAttach = () => {
  const { invalidate } = useThrelte();
  let detachFn;
  const attach = writable();
  const parent = useParent();
  const parentObject3D = useParentObject3D();
  const currentRef = createParentContext();
  const object3D = createParentObject3DContext();
  watch([attach, currentRef, parent, parentObject3D], ([attach2, ref, parent2, parentObject3D2]) => {
    detachFn == null ? void 0 : detachFn();
    detachFn = void 0;
    if (!ref) {
      invalidate();
      return;
    }
    if (attach2 !== void 0) {
      if (attach2) {
        if (typeof attach2 === "function") {
          detachFn = attach2({ ref, parent: parent2, parentObject3D: parentObject3D2 });
        } else if (isInstanceOf(attach2, "Object3D") && isInstanceOf(ref, "Object3D")) {
          detachFn = () => attach2 == null ? void 0 : attach2.remove(ref);
          attach2 == null ? void 0 : attach2.add(ref);
        } else if (typeof attach2 === "string") {
          const { target, key } = resolvePropertyPath(parent2, attach2);
          const valueBeforeAttach = target[key];
          detachFn = () => target[key] = valueBeforeAttach;
          target[key] = ref;
        }
      }
    } else {
      if (isInstanceOf(ref, "Object3D")) {
        detachFn = () => parentObject3D2 == null ? void 0 : parentObject3D2.remove(ref);
        parentObject3D2 == null ? void 0 : parentObject3D2.add(ref);
      } else if (isObject(parent2)) {
        if (isInstanceOf(ref, "Material")) {
          parent2["material"] = ref;
        } else if (isInstanceOf(ref, "BufferGeometry")) {
          parent2["geometry"] = ref;
        }
      }
    }
    invalidate();
  });
  const updateAttach = (a) => {
    attach.set(a);
  };
  const updateRef = (value) => {
    currentRef.set(value);
    if (isInstanceOf(value, "Object3D")) {
      object3D.set(value);
    }
  };
  onDestroy(() => {
    detachFn == null ? void 0 : detachFn();
    invalidate();
  });
  return {
    updateRef,
    updateAttach
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useCamera.js
var isPerspectiveOrOrthographicCamera = (value) => {
  return isInstanceOf(value, "PerspectiveCamera") || isInstanceOf(value, "OrthographicCamera");
};
var useCamera2 = () => {
  const { invalidate, size, camera } = useThrelte();
  const currentRef = writable();
  const manual = writable(true);
  const makeDefault = writable(false);
  watch([currentRef, makeDefault], ([ref, makeDefault2]) => {
    if (!ref || !makeDefault2)
      return;
    camera.set(ref);
    invalidate();
  });
  watch([currentRef, manual, size], ([ref, manual2, size2]) => {
    if (!ref || manual2)
      return;
    if (isInstanceOf(ref, "OrthographicCamera")) {
      ref.left = size2.width / -2;
      ref.right = size2.width / 2;
      ref.top = size2.height / 2;
      ref.bottom = size2.height / -2;
      ref.updateProjectionMatrix();
      ref.updateMatrixWorld();
      invalidate();
    } else if (isInstanceOf(ref, "PerspectiveCamera")) {
      ref.aspect = size2.width / size2.height;
      ref.updateProjectionMatrix();
      ref.updateMatrixWorld();
      invalidate();
    }
  });
  const updateRef = (ref) => {
    if (!isPerspectiveOrOrthographicCamera(ref))
      return;
    currentRef.set(ref);
  };
  const updateManual = (m) => {
    manual.set(m);
  };
  const updateMakeDefault = (d) => {
    makeDefault.set(d);
  };
  return {
    updateRef,
    updateManual,
    updateMakeDefault
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useCreateEvent.js
var useCreateEvent = (oncreate) => {
  let cleanupFunction;
  let ref = void 0;
  let mounted = false;
  const dispatchCreateEvent = () => {
    cleanupFunction == null ? void 0 : cleanupFunction();
    cleanupFunction = oncreate == null ? void 0 : oncreate(ref);
  };
  const updateRef = (newRef) => {
    ref = newRef;
    if (!mounted)
      return;
    dispatchCreateEvent();
  };
  onMount(() => {
    dispatchCreateEvent();
    mounted = true;
  });
  onDestroy(() => cleanupFunction == null ? void 0 : cleanupFunction());
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useDispose.js
var contextName = Symbol("threlte-disposable-object-context");
var isDisposableObject = (object) => {
  return typeof (object == null ? void 0 : object.dispose) === "function" && !isInstanceOf(object, "Scene");
};
var useDispose = (dispose) => {
  let previousRef = void 0;
  const currentRef = writable(void 0);
  const localDispose = writable(dispose);
  const { disposableObjectMounted, disposableObjectUnmounted, removeObjectFromDisposal } = useDisposal();
  const parentDispose = getContext(contextName);
  const mergedDispose = derived2([localDispose, parentDispose ?? writable(true)], ([localDispose2, parentDispose2]) => localDispose2 ?? parentDispose2 ?? true);
  setContext(contextName, mergedDispose);
  watch([currentRef, mergedDispose], ([ref, mergedDispose2]) => {
    if (ref === previousRef) {
      if (!mergedDispose2) {
        if (previousRef)
          removeObjectFromDisposal(previousRef);
      } else {
        if (previousRef)
          disposableObjectMounted(previousRef);
      }
    } else {
      if (mergedDispose2) {
        if (previousRef)
          disposableObjectUnmounted(previousRef);
        if (ref)
          disposableObjectMounted(ref);
      }
    }
    previousRef = ref;
  });
  onDestroy(() => {
    if (!get2(mergedDispose))
      return;
    const ref = get2(currentRef);
    if (ref)
      disposableObjectUnmounted(ref);
  });
  const updateRef = (ref) => {
    if (!isDisposableObject(ref))
      return;
    currentRef.set(ref);
  };
  const updateDispose = (dispose2) => {
    localDispose.set(dispose2);
  };
  return {
    updateRef,
    updateDispose
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useEvents.js
var isEventDispatcher = (value) => {
  return value !== null && typeof value === "object" && "addEventListener" in value && "removeEventListener" in value;
};
var useEvents = (props = {}) => {
  const eventHandlerProxy = (event) => {
    var _a;
    if (event == null ? void 0 : event.type) {
      (_a = props[`on${event.type}`]) == null ? void 0 : _a.call(props, event);
    }
  };
  const addEventListeners = (ref, props2) => {
    const eventNames = [];
    for (const eventName of Object.keys(props2)) {
      if (eventName.startsWith("on")) {
        ref.addEventListener(eventName.slice(2), eventHandlerProxy);
        eventNames.push(eventName);
      }
    }
    return () => {
      for (let i = 0; i < eventNames.length; i++) {
        ref.removeEventListener(eventNames[i], eventHandlerProxy);
      }
    };
  };
  const updateRef = (ref) => {
    if (!isEventDispatcher(ref))
      return;
    return addEventListeners(ref, props);
  };
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useIs.js
var currentIs;
var setIs = (is) => {
  currentIs = is;
};
var useIs = () => {
  const is = currentIs;
  currentIs = void 0;
  return is;
};

// node_modules/@threlte/core/dist/components/T/utils/usePlugins.js
var usePlugins = (args) => {
  const pluginContextName = "threlte-plugin-context";
  const plugins = getContext(pluginContextName);
  if (!plugins)
    return;
  const pluginsProps = [];
  const pluginsArray = Object.values(plugins);
  if (pluginsArray.length) {
    const pluginArgs = args();
    for (let i = 0; i < pluginsArray.length; i++) {
      const plugin = pluginsArray[i];
      const p = plugin(pluginArgs);
      if (p && p.pluginProps) {
        pluginsProps.push(...p.pluginProps);
      }
    }
  }
  return {
    pluginsProps
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useProps.js
var ignoredProps = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]);
var updateProjectionMatrixKeys = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]);
var memoizeProp = (value) => {
  if (typeof value === "string")
    return true;
  if (typeof value === "number")
    return true;
  if (typeof value === "boolean")
    return true;
  if (typeof value === "undefined")
    return true;
  if (value === null)
    return true;
  return false;
};
var createSetter = (target, key, value) => {
  var _a, _b, _c;
  if (!Array.isArray(value) && typeof value === "number" && typeof ((_a = target[key]) == null ? void 0 : _a.setScalar) === "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !((_b = target[key]) == null ? void 0 : _b.isColor)) {
    return (target2, key2, value2) => {
      target2[key2].setScalar(value2);
    };
  } else {
    if (typeof ((_c = target[key]) == null ? void 0 : _c.set) === "function") {
      if (Array.isArray(value)) {
        return (target2, key2, value2) => {
          target2[key2].set(...value2);
        };
      } else {
        return (target2, key2, value2) => {
          target2[key2].set(value2);
        };
      }
    } else {
      return (target2, key2, value2) => {
        target2[key2] = value2;
      };
    }
  }
};
var useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const memoizedSetters = /* @__PURE__ */ new Map();
  const setProp = (instance, propertyPath, value, options) => {
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance,
        value
      });
    }
    const { key, target } = resolvePropertyPath(instance, propertyPath);
    if (value !== void 0 && value !== null) {
      const memoizedSetter = memoizedSetters.get(propertyPath);
      if (memoizedSetter) {
        memoizedSetter(target, key, value);
      } else {
        const setter = createSetter(target, key, value);
        memoizedSetters.set(propertyPath, setter);
        setter(target, key, value);
      }
    } else {
      createSetter(target, key, value)(target, key, value);
    }
    if (options.manualCamera)
      return;
    if (updateProjectionMatrixKeys.has(key) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {
      target.updateProjectionMatrix();
    }
  };
  const updateProp = (instance, key, value, options) => {
    var _a;
    if (!ignoredProps.has(key) && !((_a = options.pluginsProps) == null ? void 0 : _a.includes(key))) {
      setProp(instance, key, value, options);
    }
    invalidate();
  };
  return {
    updateProp
  };
};

// node_modules/@threlte/core/dist/components/T/utils/utils.js
var classRegex = /^\s*class\s+/;
var isClass = (input) => {
  if (typeof input !== "function") {
    return false;
  }
  return classRegex.test(input.toString());
};
var argsIsConstructorParameters = (args) => {
  return Array.isArray(args);
};
var determineRef = (is, args) => {
  if (isClass(is)) {
    if (argsIsConstructorParameters(args)) {
      return new is(...args);
    } else {
      return new is();
    }
  }
  return is;
};

// node_modules/@threlte/core/dist/components/T/T.svelte
mark_module_start();
T[FILENAME] = "node_modules/@threlte/core/dist/components/T/T.svelte";
function T($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, T);
  validate_prop_bindings($$props, ["ref"], [], T);
  let is = prop($$props, "is", 19, useIs), manual = prop($$props, "manual", 3, false), makeDefault = prop($$props, "makeDefault", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "is",
      "args",
      "attach",
      "manual",
      "makeDefault",
      "dispose",
      "ref",
      "oncreate",
      "children"
    ],
    "props"
  );
  let internalRef = derived(() => determineRef(is(), $$props.args));
  const createEvent = useCreateEvent($$props.oncreate);
  user_pre_effect(() => {
    if (strict_equals(ref(), get(internalRef))) return;
    ref(get(internalRef));
    createEvent.updateRef(get(internalRef));
  });
  const plugins = usePlugins(() => ({
    get ref() {
      return get(internalRef);
    },
    get args() {
      return $$props.args;
    },
    get attach() {
      return $$props.attach;
    },
    get manual() {
      return manual();
    },
    get makeDefault() {
      return makeDefault();
    },
    get dispose() {
      return $$props.dispose;
    },
    get props() {
      return props;
    }
  }));
  const { updateProp } = useProps();
  Object.keys(props).forEach((key) => {
    user_pre_effect(() => {
      updateProp(get(internalRef), key, props[key], {
        manualCamera: manual(),
        pluginsProps: plugins == null ? void 0 : plugins.pluginsProps
      });
    });
  });
  const attachment = useAttach();
  user_pre_effect(() => attachment.updateAttach($$props.attach));
  user_pre_effect(() => attachment.updateRef(get(internalRef)));
  const camera = useCamera2();
  user_pre_effect(() => camera.updateRef(get(internalRef)));
  user_pre_effect(() => camera.updateManual(manual()));
  user_pre_effect(() => camera.updateMakeDefault(makeDefault()));
  const disposal = useDispose($$props.dispose);
  user_pre_effect(() => disposal.updateRef(get(internalRef)));
  user_pre_effect(() => disposal.updateDispose($$props.dispose));
  const events = useEvents(props);
  user_pre_effect(() => events.updateRef(get(internalRef)));
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop, () => ({ ref: get(internalRef) }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  T = hmr(T, () => T[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = T[HMR].source;
    set(T[HMR].source, module.default[HMR].original);
  });
}
var T_default = T;
mark_module_end(T);

// node_modules/@threlte/core/dist/components/T/T.js
var catalogue = {};
var extend = (extensions) => {
  Object.assign(catalogue, extensions);
};
var T2 = new Proxy(function() {
}, {
  apply(_target, _thisArg, argArray) {
    return T_default(...argArray);
  },
  get(_target, is) {
    if (typeof is !== "string") {
      return T_default;
    }
    const module = catalogue[is] || three_module_exports[is];
    if (module === void 0) {
      throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);
    }
    setIs(module);
    return T_default;
  }
});

// node_modules/@threlte/core/dist/plugins/injectPlugin.js
function injectPlugin(name, plugin) {
  const contextName2 = "threlte-plugin-context";
  if (!plugin)
    return;
  setContext(contextName2, {
    ...getContext(contextName2),
    [name]: plugin
  });
}

// node_modules/@threlte/core/dist/hooks/useStage.js
function useStage(key, options) {
  const { scheduler } = useThrelte();
  return scheduler.getStage(key) ?? scheduler.createStage(key, options);
}

// node_modules/@threlte/core/dist/hooks/useThrelteUserContext.js
function useThrelteUserContext(namespace, value, options) {
  const userCtxStore = getContext("threlte-user-context");
  if (!userCtxStore) {
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  }
  if (!namespace) {
    return {
      subscribe: userCtxStore.subscribe
    };
  }
  if (namespace && !value) {
    return derived2(userCtxStore, (ctx) => ctx[namespace]);
  }
  userCtxStore.update((ctx) => {
    if (namespace in ctx) {
      if (!options || options.existing === "skip")
        return ctx;
      if (options.existing === "merge") {
        const v2 = typeof value === "function" ? value() : value;
        Object.assign(ctx[namespace], v2);
        return ctx;
      }
    }
    const v = typeof value === "function" ? value() : value;
    ctx[namespace] = v;
    return ctx;
  });
  return userCtxStore.current[namespace];
}

// node_modules/@threlte/core/dist/hooks/useLoader.js
function useLoader(Proto, options) {
  const { remember, clear: clearCacheItem } = useCache();
  let loader;
  const initializeLoader = () => {
    var _a;
    const lazyLoader = new Proto(...(options == null ? void 0 : options.args) ?? []);
    (_a = options == null ? void 0 : options.extend) == null ? void 0 : _a.call(options, lazyLoader);
    return lazyLoader;
  };
  const load = (input, options2) => {
    const loadResource = async (url) => {
      var _a;
      if (!loader) {
        loader = initializeLoader();
      }
      if ("loadAsync" in loader) {
        const result = await loader.loadAsync(url, options2 == null ? void 0 : options2.onProgress);
        return ((_a = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a.call(options2, result)) ?? result;
      } else {
        return new Promise((resolve, reject) => {
          ;
          loader.load(url, (data) => {
            var _a2;
            return resolve(((_a2 = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a2.call(options2, data)) ?? data);
          }, (event) => {
            var _a2;
            return (_a2 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _a2.call(options2, event);
          }, reject);
        });
      }
    };
    if (Array.isArray(input)) {
      const promises = input.map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises));
      return store;
    } else if (typeof input === "string") {
      const promise = remember(() => loadResource(input), [Proto, input]);
      const store = asyncWritable(promise);
      return store;
    } else {
      const promises = Object.values(input).map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises).then((results) => {
        return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));
      }));
      return store;
    }
  };
  const clear = (input) => {
    if (Array.isArray(input)) {
      input.forEach((url) => {
        clearCacheItem([Proto, url]);
      });
    } else if (typeof input === "string") {
      clearCacheItem([Proto, input]);
    } else {
      Object.entries(input).forEach(([key, url]) => {
        clearCacheItem([Proto, key, url]);
      });
    }
  };
  return {
    load,
    clear,
    loader
  };
}

// node_modules/@threlte/core/dist/index.js
var VERSION = 8;

export {
  createCacheContext,
  useCache,
  observe,
  isInstanceOf,
  asyncWritable,
  browser,
  revision,
  watch,
  currentWritable,
  toCurrentReadable,
  resolvePropertyPath,
  createCanvasContext,
  useCanvas,
  createSchedulerContext,
  useScheduler,
  createCameraContext,
  useCamera,
  createDisposalContext,
  useDisposal,
  createParentContext,
  useParent,
  createParentObject3DContext,
  useParentObject3D,
  useTask,
  createSceneContext,
  useScene,
  createRendererContext,
  useRenderer,
  createThrelteContext,
  Canvas_default,
  useThrelte,
  extend,
  T2 as T,
  injectPlugin,
  useStage,
  useThrelteUserContext,
  useLoader,
  VERSION
};
//# sourceMappingURL=chunk-FTGXAFGZ.js.map
