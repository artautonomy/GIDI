import {
<<<<<<< Updated upstream
  MeshBVH,
  MeshBVHUniformStruct,
  SAH,
  shaderIntersectFunction,
  shaderStructs
} from "./chunk-APPS3QMT.js";
import {
  TextGeometry
} from "./chunk-YTT5FLWB.js";
import {
  FontLoader
} from "./chunk-MWARRG2Z.js";
import {
  Text,
  preloadFont
} from "./chunk-RPHC5URA.js";
import {
  ThreePerf
} from "./chunk-QHIQWEJ3.js";
import "./chunk-PQU7CLHF.js";
import {
  Bt,
  Kt,
  jt
} from "./chunk-THJO2XLR.js";
import {
=======
>>>>>>> Stashed changes
  T,
  asyncWritable,
  createCameraContext,
  createSceneContext,
  currentWritable,
  injectPlugin,
  isInstanceOf,
  observe,
  revision,
  useCache,
  useLoader,
  useParent,
  useParentObject3D,
  useStage,
  useTask,
  useThrelte,
  useThrelteUserContext,
  watch
<<<<<<< Updated upstream
} from "./chunk-O3DYMPYW.js";
import "./chunk-SKZTLOIB.js";
import {
  HDRCubeTextureLoader
} from "./chunk-E25YQGGB.js";
import {
  RGBELoader
} from "./chunk-B62NHUHD.js";
import {
  OrbitControls
} from "./chunk-RA22WOD7.js";
=======
} from "./chunk-FTGXAFGZ.js";
import {
  Text,
  preloadFont
} from "./chunk-RPHC5URA.js";
import {
  CSM
} from "./chunk-2M7RWVVR.js";
import {
  FontLoader
} from "./chunk-MWARRG2Z.js";
>>>>>>> Stashed changes
import {
  TransformControls
} from "./chunk-JF5AMRER.js";
import {
<<<<<<< Updated upstream
  TrackballControls
} from "./chunk-RQTZ3HCA.js";
import {
  Sky
} from "./chunk-A4GGNMLO.js";
import {
  CSM
} from "./chunk-2M7RWVVR.js";
import {
=======
  ThreePerf
} from "./chunk-QHIQWEJ3.js";
import "./chunk-PQU7CLHF.js";
import "./chunk-SKZTLOIB.js";
import {
  Bt,
  Kt,
  jt
} from "./chunk-THJO2XLR.js";
import {
  TrackballControls
} from "./chunk-RQTZ3HCA.js";
import {
>>>>>>> Stashed changes
  GLTFLoader
} from "./chunk-4H2JTGGV.js";
import {
  toCreasedNormals
} from "./chunk-OCSDJF7R.js";
import {
<<<<<<< Updated upstream
  MeshoptDecoder
} from "./chunk-BXCRL7WE.js";
=======
  Sky
} from "./chunk-A4GGNMLO.js";
import {
  MeshBVH,
  MeshBVHUniformStruct,
  SAH,
  shaderIntersectFunction,
  shaderStructs
} from "./chunk-APPS3QMT.js";
import {
  OrbitControls
} from "./chunk-RA22WOD7.js";
import {
  TextGeometry
} from "./chunk-YTT5FLWB.js";
>>>>>>> Stashed changes
import {
  DRACOLoader
} from "./chunk-UU5EMWJB.js";
import {
<<<<<<< Updated upstream
=======
  HorizontalBlurShader
} from "./chunk-MHKAIRRC.js";
import {
  VerticalBlurShader
} from "./chunk-Q3JEGZBP.js";
import {
  MeshoptDecoder
} from "./chunk-BXCRL7WE.js";
import {
  HDRCubeTextureLoader
} from "./chunk-E25YQGGB.js";
import {
  RGBELoader
} from "./chunk-B62NHUHD.js";
import {
>>>>>>> Stashed changes
  KTX2Loader
} from "./chunk-2PLH7JCZ.js";
import {
  AdditiveBlending,
  AlwaysStencilFunc,
  AnimationMixer,
  Audio,
  AudioListener,
  AudioLoader,
  BackSide,
  Box3,
  BufferAttribute,
  BufferGeometry,
  CanvasTexture,
  CapsuleGeometry,
  Color,
  CubeCamera,
  CubeReflectionMapping,
  CubeTextureLoader,
  DefaultLoadingManager,
  DepthTexture,
  DoubleSide,
  DynamicDrawUsage,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  Euler,
  ExtrudeGeometry,
  FileLoader,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  InstancedMesh,
  KeepStencilOp,
  LOD,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  NearestFilter,
  NotEqualStencilFunc,
  Object3D,
  OrthographicCamera,
  Plane,
  PlaneGeometry,
  Points,
  PositionalAudio,
  Quaternion,
  REVISION,
  RGBADepthPacking,
  Ray,
  Raycaster,
  RepeatWrapping,
  ReplaceStencilOp,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderMaterial,
  Shape,
  SkinnedMesh,
  Sphere,
  Spherical,
  SpriteMaterial,
  TextureLoader,
  Vector2,
  Vector3,
  Vector4,
  WebGLCubeRenderTarget,
  WebGLRenderTarget
} from "./chunk-5LA6WP7F.js";
<<<<<<< Updated upstream
import {
  HorizontalBlurShader
} from "./chunk-MHKAIRRC.js";
import {
  VerticalBlurShader
} from "./chunk-Q3JEGZBP.js";
import {
  fromStore
} from "./chunk-UIT3XCIO.js";
=======
import "./chunk-RIXFT5AQ.js";
import {
  fromStore
} from "./chunk-YB2SDMOJ.js";
>>>>>>> Stashed changes
import {
  derived as derived2,
  get as get2,
  readable,
  writable
<<<<<<< Updated upstream
} from "./chunk-5TDCD7J6.js";
=======
} from "./chunk-CUEHFFWS.js";
>>>>>>> Stashed changes
import "./chunk-GRHVSC4S.js";
import {
  action,
  add_locations,
  assign,
  await_block,
  bind_this,
  check_target,
  clsx,
  component,
  element,
  hmr,
  if_block,
  init,
  legacy_api,
  legacy_rest_props,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  setup_stores,
  slot,
  snippet,
  spread_props,
  store_get,
  store_set,
  validate_dynamic_element_tag,
  validate_prop_bindings,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet
<<<<<<< Updated upstream
} from "./chunk-5L6QKDYZ.js";
import "./chunk-U7P2NEEE.js";
=======
} from "./chunk-DVXCBMAG.js";
>>>>>>> Stashed changes
import {
  append,
  comment,
  template
} from "./chunk-457JZRJI.js";
import {
  FILENAME,
  HMR,
  add_owner_effect,
  child,
  deep_read_state,
  derived,
  derived_safe_equal,
  equals,
  first_child,
  get,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  template_effect,
  tick,
  untrack,
  user_effect,
  user_pre_effect
} from "./chunk-6B2HMSQ2.js";
<<<<<<< Updated upstream
import "./chunk-MBL6SW7X.js";
import "./chunk-RIXFT5AQ.js";
=======
import "./chunk-U7P2NEEE.js";
import "./chunk-MBL6SW7X.js";
>>>>>>> Stashed changes
import "./chunk-RVAV4ZRS.js";
import {
  __publicField
} from "./chunk-B4Q33VKO.js";

// node_modules/@threlte/extras/dist/hooks/useCursor.js
var useCursor = (onPointerOver = "pointer", onPointerOut = "auto", target = void 0) => {
  let hovering = false;
  const hoveringStore = writable(false);
  const onPointerEnter = () => {
    hoveringStore.set(true);
  };
  const onPointerLeave = () => {
    hoveringStore.set(false);
  };
  if (typeof window === "undefined") {
    return {
      hovering: hoveringStore,
      onPointerEnter,
      onPointerLeave
    };
  }
  const el = target ?? document.body;
  let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get2(onPointerOver);
  if (typeof onPointerOver !== "string") {
    watch(onPointerOver, (cursorStyle) => {
      onPointerOverValue = cursorStyle;
      if (hovering) {
        el.style.cursor = cursorStyle;
      }
    });
  }
  let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get2(onPointerOut);
  if (typeof onPointerOut !== "string") {
    watch(onPointerOut, (cursorStyle) => {
      onPointerOutValue = cursorStyle;
      if (!hovering) {
        el.style.cursor = cursorStyle;
      }
    });
  }
  watch(hoveringStore, (isHovering) => {
    hovering = isHovering;
    if (hovering) {
      el.style.cursor = onPointerOverValue;
    } else {
      el.style.cursor = onPointerOutValue;
    }
  });
  onDestroy(() => {
    el.style.cursor = onPointerOutValue;
  });
  return {
    hovering: hoveringStore,
    onPointerEnter,
    onPointerLeave
  };
};

// node_modules/@threlte/extras/dist/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
function useGltf(urlOrOptions, options) {
  const opts = typeof urlOrOptions === "string" ? options : urlOrOptions;
  const loader = useLoader(GLTFLoader, {
    extend(loader2) {
      if (opts == null ? void 0 : opts.dracoLoader) {
        loader2.setDRACOLoader(opts.dracoLoader);
      }
      if (opts == null ? void 0 : opts.meshoptDecoder) {
        loader2.setMeshoptDecoder(opts.meshoptDecoder);
      }
      if (opts == null ? void 0 : opts.ktx2Loader) {
        loader2.setKTX2Loader(opts.ktx2Loader);
      }
    }
  });
  const load = (url2) => {
    return loader.load(url2, {
      transform(result) {
        return {
          ...result,
          ...buildSceneGraph(result.scene)
        };
      }
    });
  };
  const url = typeof urlOrOptions === "string" ? urlOrOptions : void 0;
  if (url) {
    return load(url);
  } else {
    return {
      load
    };
  }
}

// node_modules/@threlte/extras/dist/hooks/useDraco.js
var defaultPath = "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
var dracoLoaderInstances = {};
var useDraco = (decoderPath = defaultPath) => {
  const cachedLoader = dracoLoaderInstances[decoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const loader = new DRACOLoader().setDecoderPath(decoderPath);
  dracoLoaderInstances[decoderPath] = loader;
  return loader;
};

// node_modules/@threlte/extras/dist/hooks/useMeshopt.js
var useMeshopt = () => {
  return MeshoptDecoder;
};

// node_modules/@threlte/extras/dist/hooks/useKtx2.js
var ktxLoaderInstances = {};
var useKtx2 = (transcoderPath) => {
  const cachedLoader = ktxLoaderInstances[transcoderPath];
  if (cachedLoader) {
    return cachedLoader;
  }
  const { renderer } = useThrelte();
  const ktx2Loader = new KTX2Loader();
  ktx2Loader.setTranscoderPath(transcoderPath);
  ktx2Loader.detectSupport(renderer);
  ktxLoaderInstances[transcoderPath] = ktx2Loader;
  return ktx2Loader;
};

// node_modules/@threlte/extras/dist/hooks/useGltfAnimations.js
var isRoot = (value) => !!(value == null ? void 0 : value.isObject3D);
var isGltfStore = (value) => !!(value == null ? void 0 : value.subscribe) && typeof value.subscribe === "function";
function useGltfAnimations(rootOrGltf, maybeRoot) {
  const gltf = isGltfStore(rootOrGltf) ? rootOrGltf : writable(void 0);
  const root6 = currentWritable(isRoot(rootOrGltf) ? rootOrGltf : isRoot(maybeRoot) ? maybeRoot : void 0);
  const actualRoot = derived2([root6, gltf], ([root7, gltf2]) => {
    return root7 ?? (gltf2 == null ? void 0 : gltf2.scene);
  });
  const actions = currentWritable({});
  const mixer = new AnimationMixer(void 0);
  watch([gltf, actualRoot], async ([gltf2, actualRoot2]) => {
    if (!gltf2 || !gltf2.animations.length || !actualRoot2)
      return;
    await tick();
    const newActions = gltf2.animations.reduce((acc, clip) => {
      const action2 = mixer.clipAction(clip, actualRoot2);
      return {
        ...acc,
        [clip.name]: action2
      };
    }, {});
    actions.set(newActions);
    return () => {
      Object.values(newActions).forEach((a) => {
        const action2 = a;
        action2.stop();
        mixer.uncacheClip(action2.getClip());
      });
    };
  });
  const { start, stop } = useTask((delta) => {
    mixer.update(delta);
  }, { autoStart: false });
  watch(actions, (actions2) => {
    if (Object.keys(actions2).length)
      start();
    else
      stop();
  });
  return {
    gltf,
    root: root6,
    mixer,
    actions
  };
}

// node_modules/@threlte/extras/dist/lib/storeUtils.js
var toCurrentReadable = (store) => {
  return {
    subscribe: store.subscribe,
    get current() {
      return store.current;
    }
  };
};

// node_modules/@threlte/extras/dist/hooks/useProgress.js
var previousTotalLoaded = 0;
var finishedOnce = currentWritable(false);
var activeStore = currentWritable(false);
var itemStore = currentWritable(void 0);
var loadedStore = currentWritable(0);
var totalStore = currentWritable(0);
var errorsStore = currentWritable([]);
var progressStore = currentWritable(0);
var { onStart, onLoad, onError } = DefaultLoadingManager;
DefaultLoadingManager.onStart = (url, loaded, total) => {
  onStart == null ? void 0 : onStart(url, loaded, total);
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
DefaultLoadingManager.onLoad = () => {
  onLoad == null ? void 0 : onLoad();
  activeStore.set(false);
};
DefaultLoadingManager.onError = (url) => {
  onError == null ? void 0 : onError(url);
  errorsStore.update((errors) => {
    return [...errors, url];
  });
};
DefaultLoadingManager.onProgress = (url, loaded, total) => {
  if (loaded === total) {
    previousTotalLoaded = total;
  }
  activeStore.set(true);
  itemStore.set(url);
  loadedStore.set(loaded);
  totalStore.set(total);
  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;
  progressStore.set(progress);
  if (progress === 1)
    finishedOnce.set(true);
};
var stores = {
  active: toCurrentReadable(activeStore),
  item: toCurrentReadable(itemStore),
  loaded: toCurrentReadable(loadedStore),
  total: toCurrentReadable(totalStore),
  errors: toCurrentReadable(errorsStore),
  progress: toCurrentReadable(progressStore),
  finishedOnce: toCurrentReadable(finishedOnce)
};
var useProgress = () => {
  return stores;
};

// node_modules/@threlte/extras/dist/hooks/useTexture.js
var useTexture = (input, options) => {
  const loader = useLoader(TextureLoader, options);
  const { renderer } = useThrelte();
  return loader.load(input, {
    ...options,
    transform: (res) => {
      var _a;
      res.colorSpace = renderer.outputColorSpace;
      res.needsUpdate = true;
      return ((_a = options == null ? void 0 : options.transform) == null ? void 0 : _a.call(options, res)) ?? res;
    }
  });
};

// node_modules/@threlte/extras/dist/hooks/useFBO.js
var useFBO = (width, height, options) => {
  const { dpr, size } = useThrelte();
  const _width = typeof width === "number" ? width : 1 * (dpr.current ?? 1);
  const _height = typeof height === "number" ? height : 1 * (dpr.current ?? 1);
  const _options = (typeof width === "number" ? options : width) || {};
  const { samples = 0, depth, ...targetOptions } = _options;
  const target = new WebGLRenderTarget(_width, _height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    type: HalfFloatType,
    ...targetOptions
  });
  if (depth) {
    target.depthTexture = new DepthTexture(_width, _height, FloatType);
  }
  target.samples = samples;
  onMount(() => {
    if (samples)
      target.samples = samples;
    return () => target.dispose();
  });
  const unsubscribeSize = size.subscribe((val) => {
    const _width2 = typeof width === "number" ? width : val.width * dpr.current;
    const _height2 = typeof height === "number" ? height : val.height * dpr.current;
    if (target.width !== _width2 && target.height !== _height2) {
      target.setSize(_width2, _height2);
    }
  });
  onDestroy(unsubscribeSize);
  return target;
};

// node_modules/@threlte/extras/dist/hooks/useGamepad.js
var standardButtons = [
  "clusterBottom",
  "clusterRight",
  "clusterLeft",
  "clusterTop",
  "leftBumper",
  "rightBumper",
  "leftTrigger",
  "rightTrigger",
  "select",
  "start",
  "leftStickButton",
  "rightStickButton",
  "directionalTop",
  "directionalBottom",
  "directionalLeft",
  "directionalRight",
  "center"
];
var xrButtons = [
  "trigger",
  "squeeze",
  "touchpadButton",
  "thumbstickButton",
  "clusterBottom",
  "clusterTop"
];
var standardAxes = ["leftStick", "rightStick"];
var xrAxes = ["touchpad", "thumbstick"];
var createButton = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a;
    (_a = events[index])[name] ?? (_a[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    pressed: false,
    touched: false,
    value: 0,
    on,
    off
  };
};
var createAxis = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a;
    (_a = events[index])[name] ?? (_a[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    x: 0,
    y: 0,
    on,
    off
  };
};
var createXrStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Primary trigger */
    trigger: createButton(events, 0),
    /** buttons[1] - Primary squeeze button */
    squeeze: createButton(events, 1),
    /** buttons[2] - Primary touchpad */
    touchpadButton: createButton(events, 2),
    /** buttons[3] - Primary thumbstick */
    thumbstickButton: createButton(events, 3),
    /** buttons[4] - Bottom cluster button */
    clusterBottom: createButton(events, 4),
    /** buttons[5] - Top cluster button */
    clusterTop: createButton(events, 5),
    /** axes[0], axes[1] - Horizontal / vertical axis for the primary touchpad */
    touchpad: createAxis(events, 6),
    /** axes[2], axes[3] - Horizontal / vertical axis for the primary thumbstick */
    thumbstick: createAxis(events, 7)
  };
};
var createStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Botton button in right cluster */
    clusterBottom: createButton(events, 0),
    /** buttons[1] - Right button in right cluster */
    clusterRight: createButton(events, 1),
    /** buttons[2] - Left button in right cluster */
    clusterLeft: createButton(events, 2),
    /** buttons[3] - Top button in right cluster */
    clusterTop: createButton(events, 3),
    /** buttons[4] - Top left front button */
    leftBumper: createButton(events, 4),
    /** buttons[5] - Top right front button */
    rightBumper: createButton(events, 5),
    /** buttons[6] - Bottom left front button */
    leftTrigger: createButton(events, 6),
    /** buttons[7] - Bottom right front button */
    rightTrigger: createButton(events, 7),
    /** buttons[8] - Left button in center cluster */
    select: createButton(events, 8),
    /** buttons[9] - Right button in center cluster */
    start: createButton(events, 9),
    /** buttons[10] - Left stick pressed button */
    leftStickButton: createButton(events, 10),
    /** buttons[11] -	Right stick pressed button */
    rightStickButton: createButton(events, 11),
    /** buttons[12] -	Top button in left cluster */
    directionalTop: createButton(events, 12),
    /** buttons[13] -	Bottom button in left cluster */
    directionalBottom: createButton(events, 13),
    /** buttons[14] -	Left button in left cluster */
    directionalLeft: createButton(events, 14),
    /** buttons[15] -	Right button in left cluster */
    directionalRight: createButton(events, 15),
    /** buttons[16] -	Center button in center cluster */
    center: createButton(events, 16),
    /** axes[0], axes[1] - Horizontal / vertical axis for left stick (negative left/positive right) */
    leftStick: createAxis(events, 17),
    /** axes[2], axes[3] - Horizontal / vertical axis for right stick (negative left/positive right) */
    rightStick: createAxis(events, 18)
  };
};
var processButton = (target, mappedButton, allEvents, buttonEvents, source) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const lastTouched = mappedButton.touched;
  const lastPressed = mappedButton.pressed;
  const lastValue = mappedButton.value;
  mappedButton.touched = (source == null ? void 0 : source.touched) ?? false;
  mappedButton.pressed = (source == null ? void 0 : source.pressed) ?? false;
  const value = mappedButton.value = (source == null ? void 0 : source.value) ?? 0;
  if (!lastTouched && mappedButton.touched) {
    (_a = allEvents.touchstart) == null ? void 0 : _a.forEach((fn) => fn({ type: "touchstart", target, value }));
    (_b = buttonEvents.touchstart) == null ? void 0 : _b.forEach((fn) => fn({ type: "touchstart", target, value }));
  } else if (lastTouched && !mappedButton.touched) {
    (_c = allEvents.touch) == null ? void 0 : _c.forEach((fn) => fn({ type: "touch", target, value }));
    (_d = buttonEvents.touch) == null ? void 0 : _d.forEach((fn) => fn({ type: "touch", target, value }));
    (_e = allEvents.touchend) == null ? void 0 : _e.forEach((fn) => fn({ type: "touchend", target, value }));
    (_f = buttonEvents.touchend) == null ? void 0 : _f.forEach((fn) => fn({ type: "touchend", target, value }));
  }
  if (!lastPressed && mappedButton.pressed) {
    (_g = allEvents.down) == null ? void 0 : _g.forEach((fn) => fn({ type: "down", target, value }));
    (_h = buttonEvents.down) == null ? void 0 : _h.forEach((fn) => fn({ type: "down", target, value }));
  } else if (lastPressed && !mappedButton.pressed) {
    (_i = allEvents.press) == null ? void 0 : _i.forEach((fn) => fn({ type: "press", target, value }));
    (_j = buttonEvents.press) == null ? void 0 : _j.forEach((fn) => fn({ type: "press", target, value }));
    (_k = allEvents.up) == null ? void 0 : _k.forEach((fn) => fn({ type: "up", target, value }));
    (_l = buttonEvents.up) == null ? void 0 : _l.forEach((fn) => fn({ type: "up", target, value }));
  }
  if (lastValue !== mappedButton.value) {
    (_m = allEvents.change) == null ? void 0 : _m.forEach((fn) => fn({ type: "change", target, value }));
    (_n = buttonEvents.change) == null ? void 0 : _n.forEach((fn) => fn({ type: "change", target, value }));
  }
};
var processAxis = (target, mappedStick, allEvents, axisEvents, axisDeadzone, rawX = 0, rawY = 0) => {
  var _a, _b;
  const lastValueX = mappedStick.x;
  const lastValueY = mappedStick.y;
  const x = Math.abs(rawX) < axisDeadzone ? 0 : rawX;
  const y = Math.abs(rawY) < axisDeadzone ? 0 : rawY;
  mappedStick.x = x;
  mappedStick.y = y;
  if (lastValueX !== x || lastValueY !== y) {
    (_a = allEvents.change) == null ? void 0 : _a.forEach((fn) => fn({ type: "change", target, value: { x, y } }));
    (_b = axisEvents.change) == null ? void 0 : _b.forEach((fn) => fn({ type: "change", target, value: { x, y } }));
  }
};
function useGamepad(options = {}) {
  const { axisDeadzone = 0.05 } = options;
  const allEvents = {};
  const events = [];
  if ("xr" in options) {
    for (let i = 0; i < xrButtons.length + xrAxes.length; i += 1) {
      events.push({});
    }
    const gamepad = createXrStandard(allEvents, events);
    const { xr } = useThrelte().renderer;
    const processSnapshot = () => {
      var _a;
      (_a = xr.getSession()) == null ? void 0 : _a.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        gamepad.raw = source.gamepad ?? null;
        const { buttons = [], axes = [] } = gamepad.raw ?? {};
        xrButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
        processAxis("touchpad", gamepad.touchpad, allEvents, events[6], axisDeadzone, axes[0], axes[1]);
        processAxis("thumbstick", gamepad.thumbstick, allEvents, events[7], axisDeadzone, axes[2], axes[3]);
      });
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleConnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      const pad = event.data.gamepad;
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    const handleDisconnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      gamepad.raw = null;
      gamepad.connected.set(false);
      stop();
    };
    const session = xr.getSession();
    if (session) {
      session.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        const pad = source.gamepad;
        if (pad) {
          gamepad.raw = pad;
          gamepad.connected.set(true);
          start();
        }
      });
    }
    for (const index of [0, 1]) {
      const controller = xr.getController(index);
      controller.addEventListener("connected", handleConnected);
      controller.addEventListener("disconnected", handleDisconnected);
    }
    onDestroy(() => {
      for (const index of [0, 1]) {
        const controller = xr.getController(index);
        controller.removeEventListener("connected", handleConnected);
        controller.removeEventListener("disconnected", handleDisconnected);
      }
    });
    return gamepad;
  } else {
    for (let i = 0; i < standardButtons.length + standardAxes.length; i += 1) {
      events.push({});
    }
    const { index: gamepadIndex = 0 } = options;
    const gamepad = createStandard(allEvents, events);
    const processSnapshot = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      gamepad.raw = pad;
      const { buttons = [], axes = [] } = pad ?? {};
      standardButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
      processAxis("leftStick", gamepad.leftStick, allEvents, events[17], axisDeadzone, axes[0], axes[1]);
      processAxis("rightStick", gamepad.rightStick, allEvents, events[18], axisDeadzone, axes[2], axes[3]);
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleGamepadDisconnected = (event) => {
      var _a;
      const { id } = event.gamepad;
      if (id === ((_a = gamepad.raw) == null ? void 0 : _a.id)) {
        gamepad.raw = null;
        gamepad.connected.set(false);
        stop();
      }
    };
    const handleGamepadConnected = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    handleGamepadConnected();
    window.addEventListener("gamepadconnected", handleGamepadConnected);
    window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);
    onDestroy(() => {
      window.removeEventListener("gamepadconnected", handleGamepadConnected);
      window.removeEventListener("gamepaddisconnected", handleGamepadDisconnected);
    });
    return gamepad;
  }
}

// node_modules/@threlte/extras/dist/hooks/useMask.js
var useMask = (id = 1, inverse = false) => {
  return {
    stencilRef: id,
    stencilWrite: true,
    stencilFunc: inverse ? NotEqualStencilFunc : EqualStencilFunc,
    stencilFail: KeepStencilOp,
    stencilZFail: KeepStencilOp,
    stencilZPass: KeepStencilOp
  };
};

// node_modules/@threlte/extras/dist/hooks/useViewport.js
var origin = new Vector3();
var position = new Vector3();
var lastPosition = new Vector3();
var useViewport = (target) => {
  const viewport = currentWritable({
    width: 0,
    height: 0,
    factor: 0,
    distance: 0
  });
  const { camera, size, renderStage, scheduler } = useThrelte();
  const updateViewport = ($size, $camera, distance) => {
    viewport.update(($viewport) => {
      const { width, height } = $size;
      if (Array.isArray(target)) {
        origin.fromArray(target);
      } else if (target !== void 0) {
        origin.copy(target);
      }
      $viewport.distance = distance;
      if ("isOrthographicCamera" in $camera) {
        $viewport.width = width / $camera.zoom;
        $viewport.height = height / $camera.zoom;
        $viewport.factor = 1;
      } else if ("isPerspectiveCamera" in $camera) {
        const fov = $camera.fov * Math.PI / 180;
        const h = 2 * Math.tan(fov / 2) * distance;
        const w = h * (width / height);
        $viewport.width = w;
        $viewport.height = h;
        $viewport.factor = width / w;
      }
      return $viewport;
    });
  };
  useTask(() => {
    camera.current.getWorldPosition(position);
    if (!position.equals(lastPosition)) {
      const distance = position.distanceTo(origin);
      updateViewport(size.current, camera.current, distance);
      lastPosition.copy(position);
    }
  }, {
    autoInvalidate: false,
    stage: scheduler.createStage(Symbol("viewport-stage"), { before: renderStage })
  });
  watch([camera, size], ([$camera, $size]) => {
    const distance = $camera.getWorldPosition(position).distanceTo(origin);
    updateViewport($size, $camera, distance);
  });
  return viewport;
};

// node_modules/@threlte/extras/dist/utilities/meshBounds.js
var sphere = new Sphere();
var inverseMatrix = new Matrix4();
var ray = new Ray();
var v = new Vector3();
var meshBounds = function(raycaster, intersects) {
  if (this.geometry.boundingSphere === null) {
    this.geometry.computeBoundingSphere();
  }
  sphere.copy(this.geometry.boundingSphere ?? sphere);
  sphere.applyMatrix4(this.matrixWorld);
  if (!raycaster.ray.intersectsSphere(sphere)) {
    return;
  }
  inverseMatrix.copy(this.matrixWorld).invert();
  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
  if (this.geometry.boundingBox !== null && ray.intersectBox(this.geometry.boundingBox, v) === null) {
    return;
  }
  const distance = v.distanceTo(raycaster.ray.origin);
  const point = v.clone();
  intersects.push({
    distance,
    point,
    object: this
  });
};

// node_modules/@threlte/extras/dist/suspense/context.js
var suspenseContextIdentifier = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER");
var createSuspenseContext = (options) => {
  const promises = currentWritable(/* @__PURE__ */ new Set());
  const errors = currentWritable(/* @__PURE__ */ new Map());
  const finalized = writable(false);
  const checkFinalized = () => {
    if (promises.current.size === 0 && errors.current.size === 0)
      finalized.set(true);
  };
  const finalStore = writable((options == null ? void 0 : options.final) ?? false);
  const addPromise = (promise) => {
    promises.update((set2) => {
      set2.add(promise);
      return set2;
    });
  };
  const removePromise = (promise) => {
    promises.update((set2) => {
      set2.delete(promise);
      return set2;
    });
  };
  const addError = (promise, error) => {
    errors.update((map) => {
      map.set(promise, error);
      return map;
    });
  };
  const removeError = (promise) => {
    errors.update((map) => {
      map.delete(promise);
      return map;
    });
  };
  const suspended = derived2([promises, errors, finalStore, finalized], ([promises2, errors2, final, finalized2]) => {
    if (final && finalized2) {
      return false;
    } else if (errors2.size > 0) {
      return true;
    } else {
      return promises2.size > 0;
    }
  });
  const context = {
    suspend(promise) {
      addPromise(promise);
      promise.catch((error) => {
        addError(promise, error);
      }).finally(() => {
        removePromise(promise);
        checkFinalized();
      });
    },
    onComponentDestroy(promise) {
      removePromise(promise);
      removeError(promise);
      checkFinalized();
    },
    suspended
  };
  const errorsArray = derived2(errors, (errors2) => Array.from(errors2.values()));
  setContext(suspenseContextIdentifier, context);
  return {
    promises,
    suspended,
    errors: errorsArray,
    setFinal: (final) => finalStore.set(final ?? false)
  };
};

// node_modules/@threlte/extras/dist/suspense/useSuspense.js
var useSuspense = () => {
  const ctx = getContext(suspenseContextIdentifier);
  const promises = /* @__PURE__ */ new Set();
  const suspend = (promise) => {
    if (ctx) {
      ctx.suspend(promise);
      promises.add(promise);
    }
    return promise;
  };
  const state2 = {
    suspended: derived2((ctx == null ? void 0 : ctx.suspended) ?? readable(false), (suspended) => suspended)
  };
  onDestroy(() => {
    if (!ctx)
      return;
    for (const promise of promises) {
      ctx.onComponentDestroy(promise);
    }
    promises.clear();
  });
  return Object.assign(suspend, state2);
};

// node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte
mark_module_start();
AnimatedSpriteMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte";
var root_1 = add_locations(template(`<!> <!>`, 1), AnimatedSpriteMaterial[FILENAME], []);
function AnimatedSpriteMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnimatedSpriteMaterial);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  validate_prop_bindings($$props, ["is", "ref"], ["play", "pause"], AnimatedSpriteMaterial);
  let dataUrl = prop($$props, "dataUrl", 3, ""), animation = prop($$props, "animation", 3, ""), loop = prop($$props, "loop", 3, true), autoplay = prop($$props, "autoplay", 3, true), fps = prop($$props, "fps", 3, 10), filter = prop($$props, "filter", 3, "nearest"), alphaTest = prop($$props, "alphaTest", 3, 0.1), delay = prop($$props, "delay", 3, 0), transparent = prop($$props, "transparent", 3, true), flipX = prop($$props, "flipX", 3, false), startFrame = prop($$props, "startFrame", 3, 0), endFrame = prop($$props, "endFrame", 3, void 0), rows = prop($$props, "rows", 3, 1), columns = prop($$props, "columns", 3, void 0), totalFrames = prop($$props, "totalFrames", 3, 0), is = prop($$props, "is", 15), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "textureUrl",
      "dataUrl",
      "animation",
      "loop",
      "autoplay",
      "fps",
      "filter",
      "alphaTest",
      "delay",
      "transparent",
      "flipX",
      "startFrame",
      "endFrame",
      "rows",
      "columns",
      "totalFrames",
      "is",
      "ref",
      "onload",
      "onstart",
      "onend",
      "onloop"
    ],
    "props"
  );
  const parent = useParent();
  const supportedDirections = ["forward", "reverse"];
  const isSupportedDirection = (value) => {
    const isSupported = supportedDirections.includes(value);
    if (!isSupported) {
      console.warn(...log_if_contains_state("warn", `Unsupported sprite animation direction "${value}"`));
    }
    return isSupported;
  };
  let timerOffset = 0;
  let currentFrame = startFrame();
  let numFrames = 0;
  let flipOffset = flipX() ? -1 : 1;
  let frameWidth = 0;
  let frameHeight = 0;
  let texture = state(void 0);
  let json;
  let frameNames = [];
  let direction = "forward";
  let frameTag;
  let spritesheetSize = { w: 0, h: 0 };
  let fpsInterval = 0;
  let isMesh = state(false);
  user_pre_effect(() => {
    set(isMesh, proxy(strict_equals($parent(), void 0, false) && isInstanceOf($parent(), "Mesh"), null, isMesh));
  });
  user_pre_effect(() => {
    fpsInterval = 1e3 / fps();
  });
  is(is() ?? (get(isMesh) ? new MeshBasicMaterial() : new SpriteMaterial()));
  const suspend = useSuspense();
  const textureStore = suspend(useTexture($$props.textureUrl, {
    transform: (value) => {
      value.matrixAutoUpdate = false;
      value.generateMipmaps = false;
      value.premultiplyAlpha = false;
      value.wrapS = assign(value, "wrapT", RepeatWrapping, "node_modules/​@threlte/​extras/​dist/​components/​AnimatedSpriteMaterial/​AnimatedSpriteMaterial.svelte:42:22");
      value.magFilter = assign(value, "minFilter", strict_equals(filter(), "nearest") ? NearestFilter : LinearFilter, "node_modules/​@threlte/​extras/​dist/​components/​AnimatedSpriteMaterial/​AnimatedSpriteMaterial.svelte:43:26");
      return value;
    }
  }));
  const jsonStore = suspend(dataUrl() ? useLoader(FileLoader).load(dataUrl(), {
    transform: (file) => {
      if (strict_equals(typeof file, "string", false)) return;
      try {
        return JSON.parse(file);
      } catch {
        return;
      }
    }
  }) : asyncWritable(new Promise((resolve) => {
    const unsub = textureStore.subscribe((value) => {
      if (!value) return;
      unsub();
      resolve(createData(value));
    });
  })));
  const createData = (texture2) => {
    const { width, height } = texture2.image;
    const cols = columns() ?? totalFrames();
    numFrames = totalFrames();
    const frameWidth2 = width / cols;
    const frameHeight2 = height / rows();
    const data = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: width, h: height },
        scale: 1
      }
    };
    for (let i = 0; i < numFrames; i += 1) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const x = col * frameWidth2;
      const y = row * frameHeight2;
      data.frames[`${i}`] = {
        frame: { x, y, w: frameWidth2, h: frameHeight2 },
        spriteSourceSize: { x: 0, y: 0, w: frameWidth2, h: frameHeight2 },
        sourceSize: { w: frameWidth2, h: frameHeight2 }
      };
    }
    return data;
  };
  const setFrame = (frame) => {
    var _a, _b;
    const horizontalFrames = spritesheetSize.w / frameWidth;
    const verticalFrames = spritesheetSize.h / frameHeight;
    const frameOffsetX = 1 / horizontalFrames;
    const frameOffsetY = 1 / verticalFrames;
    const x = flipOffset > 0 ? frameOffsetX * (frame.x / frameWidth) : frameOffsetX * (frame.x / frameHeight) - get(texture).repeat.x;
    const y = Math.abs(1 - frameOffsetY) - frameOffsetY * (frame.y / frameHeight);
    (_a = get(texture)) == null ? void 0 : _a.offset.set(x, y);
    (_b = get(texture)) == null ? void 0 : _b.updateMatrix();
  };
  const setAnimation = (name) => {
    var _a;
    if (!json) return;
    frameTag = json == null ? void 0 : json.meta.frameTags.find((tag) => strict_equals(tag.name, name));
    direction = isSupportedDirection(frameTag == null ? void 0 : frameTag.direction) ? frameTag.direction : "forward";
    currentFrame = strict_equals(direction, "forward") ? (frameTag == null ? void 0 : frameTag.from) ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? numFrames - 1;
    setFrame(json.frames[frameNames[currentFrame]].frame);
    (_a = $$props.onstart) == null ? void 0 : _a.call($$props);
  };
  let playQueued = false;
  const play = async () => {
    playQueued = true;
    await Promise.all([textureStore, jsonStore]);
    if (!playQueued) return;
    timerOffset = performance.now() - delay();
    start();
  };
  const pause = () => {
    playQueued = false;
    stop();
  };
  const { start, stop } = useTask(
    () => {
      var _a, _b;
      if (!json) return;
      const now = performance.now();
      const diff = now - timerOffset;
      const name = frameNames[currentFrame];
      const { frame, duration } = json.frames[name];
      const interval = duration ?? fpsInterval;
      if (diff <= interval) return;
      timerOffset = now - diff % interval;
      const start2 = strict_equals(direction, "forward") ? (frameTag == null ? void 0 : frameTag.from) ?? startFrame() ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? endFrame() ?? numFrames - 1;
      const end = strict_equals(direction, "forward") ? (frameTag == null ? void 0 : frameTag.to) ?? endFrame() ?? numFrames - 1 : (frameTag == null ? void 0 : frameTag.from) ?? startFrame() ?? 0;
      setFrame(frame);
      switch (direction) {
        case "forward":
          currentFrame += 1;
          break;
        case "reverse":
          currentFrame -= 1;
          break;
        default:
          break;
      }
      if (strict_equals(direction, "forward") && currentFrame > end || strict_equals(direction, "reverse") && currentFrame < end) {
        currentFrame = start2;
        if (loop()) {
          (_a = $$props.onloop) == null ? void 0 : _a.call($$props);
        } else {
          pause();
          (_b = $$props.onend) == null ? void 0 : _b.call($$props);
        }
      }
    },
    { autoStart: false }
  );
  watch([textureStore, jsonStore], ([nextTexture, nextJson]) => {
    var _a;
    if (strict_equals(nextTexture, void 0) || strict_equals(nextJson, void 0)) return;
    set(texture, proxy(nextTexture.clone(), null, texture));
    json = nextJson;
    frameNames = Object.keys(json.frames);
    numFrames = frameNames.length;
    spritesheetSize = json.meta.size;
    const { sourceSize } = Object.values(json.frames)[0];
    frameWidth = sourceSize.w;
    frameHeight = sourceSize.h;
    get(texture).repeat.set(1 * flipOffset / (spritesheetSize.w / frameWidth), 1 / (spritesheetSize.h / frameHeight));
    setAnimation(animation());
    (_a = $$props.onload) == null ? void 0 : _a.call($$props);
    if (autoplay()) {
      play();
    }
  });
  user_pre_effect(() => {
    setAnimation(animation());
    if (autoplay()) {
      play();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_1();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, spread_props(
          {
            get is() {
              return is();
            },
            get map() {
              return get(texture);
            },
            toneMapped: false,
            side: DoubleSide,
            shadowSide: DoubleSide,
            get transparent() {
              return transparent();
            },
            get alphaTest() {
              return alphaTest();
            }
          },
          () => props,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
      var node_2 = sibling(node_1, 2);
      component(node_2, () => T.MeshDepthMaterial, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          attach: "customDepthMaterial",
          depthPacking: RGBADepthPacking,
          get map() {
            return get(texture);
          },
          get alphaTest() {
            return alphaTest();
          }
        });
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            add_owner_effect(ref, T);
            T(node_4, spread_props(
              {
                get is() {
                  return is();
                },
                get map() {
                  return get(texture);
                },
                toneMapped: false,
                get transparent() {
                  return transparent();
                },
                get alphaTest() {
                  return alphaTest();
                }
              },
              () => props,
              {
                get ref() {
                  return ref();
                },
                set ref($$value) {
                  ref($$value);
                }
              }
            ));
          }
          append($$anchor3, fragment_3);
        };
        if_block(
          node_3,
          ($$render) => {
            if (get(texture)) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (get(texture) && get(isMesh)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({
    get play() {
      return play;
    },
    get pause() {
      return pause;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  AnimatedSpriteMaterial = hmr(AnimatedSpriteMaterial, () => AnimatedSpriteMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimatedSpriteMaterial[HMR].source;
    set(AnimatedSpriteMaterial[HMR].source, module.default[HMR].original);
  });
}
var AnimatedSpriteMaterial_default = AnimatedSpriteMaterial;
mark_module_end(AnimatedSpriteMaterial);

// node_modules/@threlte/extras/dist/components/Edges/Edges.svelte
mark_module_start();
Edges[FILENAME] = "node_modules/@threlte/extras/dist/components/Edges/Edges.svelte";
var root_12 = add_locations(template(`<!> <!> <!>`, 1), Edges[FILENAME], []);
function Edges($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Edges);
  validate_prop_bindings($$props, ["ref"], [], Edges);
  let thresholdAngle = prop($$props, "thresholdAngle", 3, 1), color2 = prop($$props, "color", 3, "#ffffff"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "thresholdAngle",
      "color",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = fromStore(useParent());
  const geometry = derived(() => {
    if (!isInstanceOf(parent.current, "Mesh")) {
      throw new Error("Edges: component must be a child of a Mesh");
    }
    return parent.current.geometry;
  });
  ref(new LineSegments());
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props(
    {
      get is() {
        return ref();
      }
    },
    () => props,
    {
      children: wrap_snippet(Edges, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_12();
        var node_1 = first_child(fragment_1);
        var args = derived(() => [get(geometry), thresholdAngle()]);
        component(node_1, () => T.EdgesGeometry, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            get args() {
              return get(args);
            }
          });
        });
        var node_2 = sibling(node_1, 2);
        component(node_2, () => T.LineBasicMaterial, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            get color() {
              return color2();
            }
          });
        });
        var node_3 = sibling(node_2, 2);
        snippet(node_3, () => $$props.children ?? noop, () => ({ ref: ref() }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Edges = hmr(Edges, () => Edges[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Edges[HMR].source;
    set(Edges[HMR].source, module.default[HMR].original);
  });
}
var Edges_default = Edges;
mark_module_end(Edges);

// node_modules/@threlte/extras/dist/components/HTML/utils.js
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
var vec2 = new Vector2();
var defaultCalculatePosition = (obj, camera, size) => {
  const objectPos = v1.setFromMatrixPosition(obj.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
};
var isObjectBehindCamera = (el, camera) => {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el, camera, raycaster, occlude) => {
  const elPos = v1.setFromMatrixPosition(el.matrixWorld);
  const screenPos = v2.copy(v1);
  screenPos.project(camera);
  raycaster.setFromCamera(vec2.set(screenPos.x, screenPos.y), camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectScale = (el, camera) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return camera.zoom;
  } else if (isInstanceOf(camera, "PerspectiveCamera")) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var objectZIndex = (el, camera, zIndexRange) => {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const dist = objectPos.distanceTo(cameraPos);
  const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
  const B = zIndexRange[1] - A * camera.far;
  return Math.round(A * dist + B);
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (mat4, m, prepend = "") => {
  const { elements: e } = mat4;
  return `${prepend}matrix3d(
    ${epsilon(m[0] * e[0])},${epsilon(m[1] * e[1])},${epsilon(m[2] * e[2])},${epsilon(m[3] * e[3])},
    ${epsilon(m[4] * e[4])},${epsilon(m[5] * e[5])},${epsilon(m[6] * e[6])},${epsilon(m[7] * e[7])},
    ${epsilon(m[8] * e[8])},${epsilon(m[9] * e[9])},${epsilon(m[10] * e[10])},${epsilon(m[11] * e[11])},
    ${epsilon(m[12] * e[12])},${epsilon(m[13] * e[13])},${epsilon(m[14] * e[14])},${epsilon(m[15] * e[15])}
  )`;
};
var getCameraCSSMatrix = /* @__PURE__ */ ((multipliers) => {
  return (matrix) => getCSSMatrix(matrix, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = /* @__PURE__ */ ((scaleMultipliers) => {
  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);
var getViewportFactor = (camera, target, size) => {
  if (isInstanceOf(camera, "OrthographicCamera")) {
    return 1;
  }
  if (isInstanceOf(camera, "PerspectiveCamera")) {
    const { width, height } = size;
    const distance = camera.getWorldPosition(v1).distanceTo(target);
    const fov = camera.fov * Math.PI / 180;
    const h = 2 * Math.tan(fov / 2) * distance;
    const w = h * (width / height);
    return width / w;
  }
  throw new Error("getViewportFactor needs a Perspective or Orthographic Camera");
};

// node_modules/@threlte/extras/dist/components/HTML/shaders.js
var logVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`;
var logFragment = `
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
}`;
var spriteVertex = `
#include <common>
#include <logdepthbuf_pars_vertex>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;
  
  // This is somewhat arbitrary, but it seems to work well
  // Need to figure out how to derive this dynamically if it even matters
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale = vec2(
    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),
    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )
  );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  #include <logdepthbuf_vertex>
}`;

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
mark_module_start();
HTML[FILENAME] = "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte";
var canvasModified = false;
var activeOccludeInstances = 0;
var oldZIndex = "";
var oldPosition = "";
var oldPointerEvents = "";
var modifyCanvas = (canvas, zIndexRange) => {
  if (strict_equals(activeOccludeInstances, 1) && !canvasModified) {
    oldZIndex = canvas.style.zIndex;
    oldPosition = canvas.style.position;
    oldPointerEvents = canvas.style.pointerEvents;
    canvas.style.zIndex = `${Math.floor(zIndexRange / 2)}`;
    canvas.style.position = "absolute";
    canvas.style.pointerEvents = "none";
    canvasModified = true;
  } else if (strict_equals(activeOccludeInstances, 0) && canvasModified) {
    canvas.style.zIndex = oldZIndex;
    canvas.style.position = oldPosition;
    canvas.style.pointerEvents = oldPointerEvents;
    canvasModified = false;
  }
};
var root_3 = add_locations(template(`<!> <!>`, 1), HTML[FILENAME], []);
var root_11 = add_locations(template(`<div><div><div><!></div></div></div>`), HTML[FILENAME], [
  [
    243,
    4,
    [[253, 6, [[258, 8]]]]
  ]
]);
var root_122 = add_locations(template(`<div><!></div>`), HTML[FILENAME], [[267, 4]]);
var root = add_locations(template(`<!> <!>`, 1), HTML[FILENAME], []);
function HTML($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HTML);
  const $$stores = setup_stores();
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  validate_prop_bindings($$props, ["ref", "visible"], [], HTML);
  let eps = prop($$props, "eps", 3, 1e-3), center = prop($$props, "center", 3, false), fullscreen = prop($$props, "fullscreen", 3, false), sprite = prop($$props, "sprite", 3, false), transform = prop($$props, "transform", 3, false), occlude = prop($$props, "occlude", 3, false), zIndexRange = prop($$props, "zIndexRange", 19, () => [16777271, 0]), calculatePosition = prop($$props, "calculatePosition", 3, defaultCalculatePosition), as = prop($$props, "as", 3, "div"), pointerEvents = prop($$props, "pointerEvents", 3, "auto"), ref = prop($$props, "ref", 15), visible = prop($$props, "visible", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "eps",
      "center",
      "fullscreen",
      "portal",
      "distanceFactor",
      "sprite",
      "transform",
      "occlude",
      "castShadow",
      "receiveShadow",
      "material",
      "geometry",
      "zIndexRange",
      "calculatePosition",
      "as",
      "wrapperClass",
      "pointerEvents",
      "ref",
      "visible",
      "style",
      "children"
    ],
    "props"
  );
  visible(true);
  const { renderer, camera, scene, size } = useThrelte();
  const group = new Group();
  let element2 = document.createElement(as());
  let oldZoom = 0;
  let oldPosition2 = [0, 0];
  let transformOuterRef = state(void 0);
  let transformInnerRef = state(void 0);
  let isMeshSizeSet = false;
  const occlusionMesh = new Mesh();
  const raycaster = new Raycaster();
  let isRayCastOcclusion = derived(() => occlude() && strict_equals(occlude(), "blending", false) || Array.isArray(occlude()) && occlude().length > 0);
  let matrix = new Matrix4();
  let width = derived(() => $size().width);
  let height = derived(() => $size().height);
  let halfWidth = derived(() => get(width) / 2);
  let halfHeight = derived(() => get(height) / 2);
  let fov = derived(() => $camera().projectionMatrix.elements[5] * get(halfHeight));
  let viewportFactor = derived(() => getViewportFactor($camera(), new Vector3(), $size()));
  user_pre_effect(() => {
    if ($$props.wrapperClass) element2.className = $$props.wrapperClass;
  });
  user_pre_effect(() => {
    if (strict_equals(occlude(), "blending")) {
      activeOccludeInstances += 1;
      modifyCanvas(renderer.domElement, zIndexRange()[0]);
    }
    return () => {
      activeOccludeInstances -= 1;
      modifyCanvas(renderer.domElement, zIndexRange()[0]);
    };
  });
  useTask(() => {
    camera.current.updateMatrixWorld();
    group.updateWorldMatrix(true, false);
    const vec = transform() ? oldPosition2 : calculatePosition()(group, camera.current, $size());
    if (transform() || Math.abs(oldZoom - camera.current.zoom) > eps() || Math.abs(oldPosition2[0] - vec[0]) > eps() || Math.abs(oldPosition2[1] - vec[1]) > eps()) {
      const isBehindCamera = isObjectBehindCamera(group, camera.current);
      let raytraceTarget = false;
      if (get(isRayCastOcclusion)) {
        if (Array.isArray(occlude())) {
          raytraceTarget = occlude();
        } else if (strict_equals(occlude(), "blending", false)) {
          raytraceTarget = [scene];
        }
      }
      const previouslyVisible = visible();
      if (raytraceTarget) {
        const isvisible = isObjectVisible(group, camera.current, raycaster, raytraceTarget);
        visible(isvisible && !isBehindCamera);
      } else {
        visible(!isBehindCamera);
      }
      if (strict_equals(previouslyVisible, visible(), false)) {
        if ($$props.onvisibilitychange) {
          $$props.onvisibilitychange(visible());
        } else {
          element2.style.display = visible() ? "block" : "none";
        }
      }
      const halfRange = Math.floor(zIndexRange()[0] / 2);
      const zRange = occlude() ? get(isRayCastOcclusion) ? [
        zIndexRange()[0],
        //
        halfRange
      ] : [halfRange - 1, 0] : zIndexRange();
      element2.style.zIndex = `${objectZIndex(group, camera.current, zRange)}`;
      if (transform() && get(transformOuterRef) && get(transformInnerRef)) {
        const {
          isOrthographicCamera,
          top,
          left,
          bottom,
          right
        } = camera.current;
        const cameraMatrix = getCameraCSSMatrix(camera.current.matrixWorldInverse);
        const cameraTransform = isOrthographicCamera ? `scale(${get(fov)})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${get(fov)}px)`;
        if (sprite()) {
          matrix.copy(camera.current.matrixWorldInverse).transpose().copyPosition(matrix).scale(group.scale);
          matrix.elements[3] = assign(matrix.elements, 7, assign(matrix.elements, 11, 0, "node_modules/​@threlte/​extras/​dist/​components/​HTML/​HTML.svelte:120:58"), "node_modules/​@threlte/​extras/​dist/​components/​HTML/​HTML.svelte:120:37");
          matrix.elements[15] = 1;
        } else {
          matrix.copy(group.matrixWorld);
        }
        element2.style.width = `${get(width)}px`;
        element2.style.height = `${get(height)}px`;
        element2.style.perspective = isOrthographicCamera ? "" : `${get(fov)}px`;
        get(transformOuterRef).style.transform = `${cameraTransform}${cameraMatrix}translate(${get(halfWidth)}px,${get(halfHeight)}px)`;
        get(transformInnerRef).style.transform = getObjectCSSMatrix(matrix, 1 / (($$props.distanceFactor || 10) / 400));
      } else {
        const scale = strict_equals($$props.distanceFactor, void 0) ? 1 : objectScale(group, camera.current) * $$props.distanceFactor;
        element2.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;
      }
      oldPosition2 = vec;
      oldZoom = camera.current.zoom;
    }
    if (!get(isRayCastOcclusion) && !isMeshSizeSet) {
      if (transform() && get(transformOuterRef)) {
        const el = get(transformOuterRef).children[0];
        if ((el == null ? void 0 : el.clientWidth) && (el == null ? void 0 : el.clientHeight)) {
          const { isOrthographicCamera } = camera.current;
          if (isOrthographicCamera || $$props.geometry) {
            const { scale } = props;
            if (scale) {
              if (!Array.isArray(scale)) {
                occlusionMesh.scale.setScalar(1 / scale);
              } else {
                occlusionMesh.scale.set(1 / scale[0], 1 / scale[1], 1 / scale[2]);
              }
            }
          } else {
            const ratio = ($$props.distanceFactor ?? 10) / 400;
            const w = el.clientWidth * ratio;
            const h = el.clientHeight * ratio;
            occlusionMesh.scale.set(w, h, 1);
          }
          isMeshSizeSet = true;
        }
      } else {
        const el = element2.children[0];
        if ((el == null ? void 0 : el.clientWidth) && (el == null ? void 0 : el.clientHeight)) {
          const ratio = 1 / get(viewportFactor);
          const w = el.clientWidth * ratio;
          const h = el.clientHeight * ratio;
          occlusionMesh.scale.set(w, h, 1);
          isMeshSizeSet = true;
        }
        occlusionMesh.lookAt(camera.current.position);
      }
    }
  });
  let pos = derived(() => {
    scene.updateMatrixWorld();
    return calculatePosition()(group, $camera(), $size());
  });
  const portalAction = (el) => {
    const target = $$props.portal ?? renderer.domElement.parentElement;
    if (!target) {
      console.warn(...log_if_contains_state("warn", "<HTML>: target is undefined."));
      return;
    }
    target.append(el);
    return { destroy: () => el.remove() };
  };
  var fragment = root();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(HTML, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent_3 = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: occlusionMesh,
              get castShadow() {
                return $$props.castShadow;
              },
              get receiveShadow() {
                return $$props.receiveShadow;
              },
              children: wrap_snippet(HTML, ($$anchor4, $$slotProps2) => {
                var fragment_3 = root_3();
                var node_3 = first_child(fragment_3);
                {
                  var consequent = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    T(node_4, {
                      get is() {
                        return $$props.geometry;
                      }
                    });
                    append($$anchor5, fragment_4);
                  };
                  var alternate = ($$anchor5) => {
                    var fragment_5 = comment();
                    var node_5 = first_child(fragment_5);
                    component(node_5, () => T.PlaneGeometry, ($$anchor6, $$component) => {
                      $$component($$anchor6, {});
                    });
                    append($$anchor5, fragment_5);
                  };
                  if_block(node_3, ($$render) => {
                    if ($$props.geometry) $$render(consequent);
                    else $$render(alternate, false);
                  });
                }
                var node_6 = sibling(node_3, 2);
                {
                  var consequent_1 = ($$anchor5) => {
                    var fragment_6 = comment();
                    var node_7 = first_child(fragment_6);
                    T(node_7, {
                      get is() {
                        return $$props.material;
                      }
                    });
                    append($$anchor5, fragment_6);
                  };
                  var alternate_2 = ($$anchor5) => {
                    var fragment_7 = comment();
                    var node_8 = first_child(fragment_7);
                    {
                      var consequent_2 = ($$anchor6) => {
                        var fragment_8 = comment();
                        var node_9 = first_child(fragment_8);
                        component(node_9, () => T.ShaderMaterial, ($$anchor7, $$component) => {
                          $$component($$anchor7, {
                            side: DoubleSide,
                            vertexShader: spriteVertex,
                            fragmentShader: logFragment
                          });
                        });
                        append($$anchor6, fragment_8);
                      };
                      var alternate_1 = ($$anchor6) => {
                        var fragment_9 = comment();
                        var node_10 = first_child(fragment_9);
                        component(node_10, () => T.ShaderMaterial, ($$anchor7, $$component) => {
                          $$component($$anchor7, {
                            side: DoubleSide,
                            vertexShader: logVertex,
                            fragmentShader: logFragment
                          });
                        });
                        append($$anchor6, fragment_9);
                      };
                      if_block(
                        node_8,
                        ($$render) => {
                          if (!transform()) $$render(consequent_2);
                          else $$render(alternate_1, false);
                        },
                        true
                      );
                    }
                    append($$anchor5, fragment_7);
                  };
                  if_block(node_6, ($$render) => {
                    if ($$props.material) $$render(consequent_1);
                    else $$render(alternate_2, false);
                  });
                }
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          };
          if_block(node_1, ($$render) => {
            if (occlude() && !get(isRayCastOcclusion)) $$render(consequent_3);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  var node_11 = sibling(node, 2);
  validate_void_dynamic_element(as);
  validate_dynamic_element_tag(as);
  element(
    node_11,
    as,
    false,
    ($$element, $$anchor2) => {
      action($$element, ($$node) => portalAction == null ? void 0 : portalAction($$node));
      bind_this($$element, ($$value) => element2 = $$value, () => element2);
      set_style($$element, "position", "absolute");
      set_style($$element, "top", "0");
      set_style($$element, "left", "0");
      template_effect(() => {
        set_style($$element, "pointer-events", transform() ? "none" : void 0);
        set_style($$element, "overflow", transform() ? "hidden" : void 0);
        set_style($$element, "transform", transform() ? void 0 : `translate3d(${get(pos)[0]}px,${get(pos)[1]}px,0)`);
        set_style($$element, "transform-origin", transform() ? void 0 : "0 0");
      });
      var fragment_10 = comment();
      var node_12 = first_child(fragment_10);
      {
        var consequent_4 = ($$anchor3) => {
          var div = root_11();
          set_style(div, "position", "absolute");
          set_style(div, "top", "0");
          set_style(div, "left", "0");
          set_style(div, "transform-style", "preserve-3d");
          set_style(div, "pointer-events", "none");
          var div_1 = child(div);
          set_style(div_1, "position", "absolute");
          var div_2 = child(div_1);
          var node_13 = child(div_2);
          snippet(node_13, () => $$props.children ?? noop);
          reset(div_2);
          reset(div_1);
          bind_this(div_1, ($$value) => set(transformInnerRef, $$value), () => get(transformInnerRef));
          reset(div);
          bind_this(div, ($$value) => set(transformOuterRef, $$value), () => get(transformOuterRef));
          template_effect(() => {
            set_style(div, "width", `${get(width)}px`);
            set_style(div, "height", `${get(height)}px`);
            set_style(div_1, "pointer-events", pointerEvents());
            set_class(div_2, clsx($$props.class), "");
            set_attribute(div_2, "style", $$props.style);
          });
          append($$anchor3, div);
        };
        var alternate_3 = ($$anchor3) => {
          var div_3 = root_122();
          var node_14 = child(div_3);
          snippet(node_14, () => $$props.children ?? noop);
          reset(div_3);
          template_effect(() => {
            set_attribute(div_3, "style", $$props.style);
            set_class(div_3, clsx($$props.class), "");
            set_style(div_3, "position", "absolute");
            set_style(div_3, "transform", center() ? "translate3d(-50%,-50%,0)" : "none");
            set_style(div_3, "top", fullscreen() ? `${-get(height) / 2}px` : void 0);
            set_style(div_3, "left", fullscreen() ? `${-get(width) / 2}px` : void 0);
            set_style(div_3, "width", fullscreen() ? `${get(width) / 2}px` : void 0);
            set_style(div_3, "height", fullscreen() ? `${get(height)}px` : void 0);
          });
          append($$anchor3, div_3);
        };
        if_block(node_12, ($$render) => {
          if (transform()) $$render(consequent_4);
          else $$render(alternate_3, false);
        });
      }
      append($$anchor2, fragment_10);
    },
    void 0,
    [230, 0]
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HTML = hmr(HTML, () => HTML[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HTML[HMR].source;
    set(HTML[HMR].source, module.default[HMR].original);
  });
}
var HTML_default = HTML;
mark_module_end(HTML);

// node_modules/@threlte/extras/dist/components/HUD/HUD.svelte
mark_module_start();
HUD[FILENAME] = "node_modules/@threlte/extras/dist/components/HUD/HUD.svelte";
function HUD($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HUD);
  validate_prop_bindings($$props, ["ref"], [], HUD);
  const { scene } = createSceneContext();
  const { camera } = createCameraContext();
  const { renderStage, renderer, toneMapping } = useThrelte();
  let autoRender = prop($$props, "autoRender", 3, true), stage = prop($$props, "stage", 3, renderStage), ref = prop($$props, "ref", 15);
  const key2 = Symbol("threlte-hud-render-stage");
  user_pre_effect(() => {
    if (!autoRender()) {
      return;
    }
    stage().createTask(key2, () => {
      const { autoClear } = renderer;
      renderer.autoClear = false;
      renderer.toneMapping = $$props.toneMapping ?? toneMapping.current;
      renderer.clearDepth();
      renderer.render(scene, camera.current);
      renderer.autoClear = autoClear;
      renderer.toneMapping = toneMapping.current;
    });
    return () => stage().removeTask(key2);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, {
      is: scene,
      attach: false,
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(HUD, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: scene }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HUD = hmr(HUD, () => HUD[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HUD[HMR].source;
    set(HUD[HMR].source, module.default[HMR].original);
  });
}
var HUD_default = HUD;
mark_module_end(HUD);

// node_modules/@threlte/extras/dist/components/Float/Float.svelte
mark_module_start();
Float[FILENAME] = "node_modules/@threlte/extras/dist/components/Float/Float.svelte";
function Float($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Float);
  validate_prop_bindings($$props, ["ref"], [], Float);
  let speed = prop($$props, "speed", 3, 1), floatIntensity = prop($$props, "floatIntensity", 3, 1), floatingRange = prop($$props, "floatingRange", 19, () => [-0.1, 0.1]), rotationSpeed = prop($$props, "rotationSpeed", 3, 0), rotationIntensity = prop($$props, "rotationIntensity", 3, 0), seed = prop($$props, "seed", 19, () => Math.random() * 1e4), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "speed",
      "floatIntensity",
      "floatingRange",
      "rotationSpeed",
      "rotationIntensity",
      "seed",
      "ref",
      "children"
    ],
    "props"
  );
  const outerGroup = new Group();
  const group = new Group();
  let t = seed();
  const map = MathUtils.mapLinear;
  let fSpeed = derived(() => Array.isArray(speed()) ? speed() : [speed(), speed(), speed()]);
  let fIntensity = derived(() => Array.isArray(floatIntensity()) ? floatIntensity() : [
    floatIntensity(),
    floatIntensity(),
    floatIntensity()
  ]);
  let fRange = derived(() => strict_equals(floatingRange().length, 3) ? floatingRange() : [
    [0, 0],
    floatingRange(),
    [0, 0]
  ]);
  let rSpeed = derived(() => Array.isArray(rotationSpeed()) ? rotationSpeed() : [
    rotationSpeed(),
    rotationSpeed(),
    rotationSpeed()
  ]);
  let rIntensity = derived(() => Array.isArray(rotationIntensity()) ? rotationIntensity() : [
    rotationIntensity(),
    rotationIntensity(),
    rotationIntensity()
  ]);
  useTask((delta) => {
    t += delta;
    group.position.x = map(Math.sin(t / 4 * get(fSpeed)[0]) / 10, -0.1, 0.1, ...get(fRange)[0]) * get(fIntensity)[0];
    group.position.y = map(Math.sin(t / 4 * get(fSpeed)[1]) / 10, -0.1, 0.1, ...get(fRange)[1]) * get(fIntensity)[1];
    group.position.z = map(Math.sin(t / 4 * get(fSpeed)[2]) / 10, -0.1, 0.1, ...get(fRange)[2]) * get(fIntensity)[2];
    group.rotation.x = Math.cos(t / 4 * get(rSpeed)[0]) / 8 * get(rIntensity)[0];
    group.rotation.y = Math.sin(t / 4 * get(rSpeed)[1]) / 8 * get(rIntensity)[1];
    group.rotation.z = Math.sin(t / 4 * get(rSpeed)[2]) / 20 * get(rIntensity)[2];
    group.updateMatrix();
  });
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props({ is: outerGroup }, () => props, {
    children: wrap_snippet(Float, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, {
          is: group,
          matrixAutoUpdate: false,
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          children: wrap_snippet(Float, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: group }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Float = hmr(Float, () => Float[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Float[HMR].source;
    set(Float[HMR].source, module.default[HMR].original);
  });
}
var Float_default = Float;
mark_module_end(Float);

// node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte
mark_module_start();
GLTF[FILENAME] = "node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte";
function GLTF($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GLTF);
  validate_prop_bindings(
    $$props,
    [
      "gltf",
      "scene",
      "animations",
      "asset",
      "cameras",
      "scenes",
      "userData",
      "parser",
      "materials",
      "nodes"
    ],
    [],
    GLTF
  );
  let gltf = prop($$props, "gltf", 15), scene = prop($$props, "scene", 15), animations = prop($$props, "animations", 15), asset = prop($$props, "asset", 15), cameras = prop($$props, "cameras", 15), scenes = prop($$props, "scenes", 15), userData = prop($$props, "userData", 15), parser = prop($$props, "parser", 15), materials = prop($$props, "materials", 15), nodes = prop($$props, "nodes", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "url",
      "dracoLoader",
      "meshoptDecoder",
      "ktx2Loader",
      "gltf",
      "scene",
      "animations",
      "asset",
      "cameras",
      "scenes",
      "userData",
      "parser",
      "materials",
      "nodes",
      "onload",
      "onunload",
      "onerror",
      "children"
    ],
    "props"
  );
  const loader = useGltf({
    dracoLoader: $$props.dracoLoader,
    meshoptDecoder: $$props.meshoptDecoder,
    ktx2Loader: $$props.ktx2Loader
  });
  const onLoad2 = (data) => {
    var _a, _b;
    if (gltf()) (_a = $$props.onunload) == null ? void 0 : _a.call($$props);
    gltf(data);
    scene(data.scene);
    animations(data.animations);
    asset(data.asset);
    cameras(data.cameras);
    scenes(data.scenes);
    userData(data.userData);
    parser(data.parser);
    materials(data.materials);
    nodes(data.nodes);
    (_b = $$props.onload) == null ? void 0 : _b.call($$props, gltf());
  };
  const onError2 = (error) => {
    var _a;
    gltf(void 0);
    scene(void 0);
    animations(void 0);
    asset(void 0);
    cameras(void 0);
    scenes(void 0);
    userData(void 0);
    parser(void 0);
    nodes(void 0);
    materials(void 0);
    (_a = $$props.onerror) == null ? void 0 : _a.call($$props, error);
  };
  const suspend = useSuspense();
  const loadGltf = async (url) => {
    try {
      const model = await suspend(loader.load(url));
      onLoad2(model);
    } catch (error) {
      onError2(error);
    }
  };
  user_pre_effect(() => {
    loadGltf($$props.url);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      T(node_1, spread_props(
        {
          get is() {
            return scene();
          }
        },
        () => props,
        {
          children: wrap_snippet(GLTF, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: scene() }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }
      ));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scene()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GLTF = hmr(GLTF, () => GLTF[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GLTF[HMR].source;
    set(GLTF[HMR].source, module.default[HMR].original);
  });
}
var GLTF_default = GLTF;
mark_module_end(GLTF);

// node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte
mark_module_start();
Gizmo[FILENAME] = "node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte";
var root_4 = add_locations(template(`<!> <!>`, 1), Gizmo[FILENAME], []);
var root_7 = add_locations(template(`<!> <!>`, 1), Gizmo[FILENAME], []);
var root_10 = add_locations(template(`<!> <!>`, 1), Gizmo[FILENAME], []);
var root_2 = add_locations(template(`<!> <!> <!> <!> <!> <!> <!> <!> <!>`, 1), Gizmo[FILENAME], []);
function Gizmo($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, Gizmo);
  validate_prop_bindings($$props, [], [], Gizmo);
  let turnRate = prop($$props, "turnRate", 19, () => 2 * Math.PI), center = prop($$props, "center", 19, () => [0, 0, 0]), verticalPlacement = prop($$props, "verticalPlacement", 3, "bottom"), horizontalPlacement = prop($$props, "horizontalPlacement", 3, "right"), size = prop($$props, "size", 3, 128), xColor = prop($$props, "xColor", 3, 16725587), yColor = prop($$props, "yColor", 3, 9100032), zColor = prop($$props, "zColor", 3, 2920447), toneMapped = prop($$props, "toneMapped", 3, false), paddingX = prop($$props, "paddingX", 3, 0), paddingY = prop($$props, "paddingY", 3, 0);
  const centerVec = new Vector3();
  user_pre_effect(() => {
    centerVec.fromArray(center());
  });
  const {
    autoRenderTask,
    renderer,
    camera,
    invalidate
  } = useThrelte();
  user_pre_effect(() => {
    size();
    horizontalPlacement();
    verticalPlacement();
    toneMapped();
    paddingX();
    paddingY();
    invalidate();
  });
  const orthoCam = new OrthographicCamera(-1.25, 1.25, 1.25, -1.25, 0, 4);
  orthoCam.position.set(0, 0, 2);
  const root6 = new Scene();
  const viewport = new Vector4();
  useTask(
    ((_a = $$props.renderTask) == null ? void 0 : _a.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      const { autoClear, toneMapping } = renderer;
      renderer.autoClear = false;
      renderer.getViewport(viewport);
      renderer.toneMapping = toneMapped() ? renderer.toneMapping : 0;
      const x = strict_equals(horizontalPlacement(), "left") ? paddingX() : renderer.domElement.offsetWidth - size() - paddingX();
      const y = strict_equals(verticalPlacement(), "bottom") ? paddingY() : renderer.domElement.offsetHeight - size() - paddingY();
      renderer.setViewport(x, y, size(), size());
      renderer.render(root6, orthoCam);
      renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
      renderer.autoClear = autoClear;
      renderer.toneMapping = toneMapping;
    },
    {
      ...$$props.renderTask ?? { after: autoRenderTask },
      autoInvalidate: false
    }
  );
  const clickTarget = document.createElement("div");
  const renderTarget = renderer.domElement;
  const boundingRect = renderTarget.getBoundingClientRect();
  clickTarget.style.position = "absolute";
  user_pre_effect(() => {
    if (strict_equals(horizontalPlacement(), "right")) {
      clickTarget.style.right = "";
      clickTarget.style.left = `${boundingRect.right - size() - paddingX()}px`;
    } else {
      clickTarget.style.right = "";
      clickTarget.style.left = `${paddingX() + boundingRect.left}px`;
    }
    if (strict_equals(verticalPlacement(), "bottom")) {
      clickTarget.style.bottom = "";
      clickTarget.style.top = `${boundingRect.bottom - size() - paddingY()}px`;
    } else {
      clickTarget.style.bottom = "";
      clickTarget.style.top = `${paddingY() + boundingRect.top}px`;
    }
    clickTarget.style.height = `${size()}px`;
    clickTarget.style.width = `${size()}px`;
  });
  let posX = state(void 0);
  let posY = state(void 0);
  let posZ = state(void 0);
  let negX = state(void 0);
  let negY = state(void 0);
  let negZ = state(void 0);
  const targetPosition = new Vector3();
  const targetQuaternion = new Quaternion();
  const currentQuaternion = new Quaternion();
  const finalQuaternion = new Quaternion();
  let radius = 0;
  let animating = false;
  const mouse = new Vector2();
  const raycaster = new Raycaster();
  const quaternionsAreEqual = (a, b, threshold) => {
    const delta = Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z) + Math.abs(a.w - b.w);
    return delta < threshold;
  };
  const handleIntersection = (intersection) => {
    const object = intersection.object;
    const targetPos = object.userData.targetPosition;
    const targetEuler = object.userData.targetEuler;
    radius = camera.current.position.distanceTo(centerVec);
    targetPosition.set(...targetPos).multiplyScalar(radius).add(centerVec);
    targetQuaternion.setFromEuler(new Euler(...targetEuler));
    const dummy = new Object3D();
    dummy.position.copy(centerVec);
    dummy.lookAt(camera.current.position);
    currentQuaternion.copy(dummy.quaternion);
    dummy.lookAt(targetPosition);
    finalQuaternion.copy(dummy.quaternion);
    if (quaternionsAreEqual(finalQuaternion, currentQuaternion, 1e-4)) {
      return true;
    }
    animating = true;
    return false;
  };
  const handleClick = (event) => {
    if (animating) {
      return;
    }
    const rect = clickTarget.getBoundingClientRect();
    const offsetX = rect.left + (clickTarget.offsetWidth - size());
    const offsetY = rect.top + (clickTarget.offsetHeight - size());
    mouse.x = (event.clientX - offsetX) / (rect.right - offsetX) * 2 - 1;
    mouse.y = -((event.clientY - offsetY) / (rect.bottom - offsetY)) * 2 + 1;
    raycaster.setFromCamera(mouse, orthoCam);
    if (!get(posX) || !get(posY) || !get(posZ) || !get(negX) || !get(negY) || !get(negZ)) {
      return;
    }
    const intersects = raycaster.intersectObjects([
      get(posX),
      get(posY),
      get(posZ),
      get(negX),
      get(negY),
      get(negZ)
    ]);
    if (intersects.length > 0) {
      const alreadyReached = handleIntersection(intersects[0]);
      if (alreadyReached) {
        if (intersects.length > 1) {
          handleIntersection(intersects[1]);
        }
      }
    }
  };
  onMount(() => {
    var _a2;
    (_a2 = renderer.domElement.parentElement) == null ? void 0 : _a2.appendChild(clickTarget);
    clickTarget.addEventListener("click", handleClick);
    return () => {
      var _a3;
      (_a3 = renderer.domElement.parentElement) == null ? void 0 : _a3.removeChild(clickTarget);
      clickTarget.removeEventListener("click", handleClick);
    };
  });
  const point = new Vector3();
  let p = state(proxy([0, 0, 0]));
  useTask(
    ((_b = $$props.animationTask) == null ? void 0 : _b.key) ?? Symbol("threlte-extras-gizmo-animation"),
    (delta) => {
      point.set(0, 0, 1).applyQuaternion(camera.current.quaternion);
      if (strict_equals(point.x, get(p)[0], false) || strict_equals(point.y, get(p)[1], false) || strict_equals(point.z, get(p)[2], false)) {
        set(p, proxy([point.x, point.y, point.z], null, p));
        root6.quaternion.copy(camera.current.quaternion).invert();
        invalidate();
      }
      if (animating) {
        const step = delta * turnRate();
        currentQuaternion.rotateTowards(finalQuaternion, step);
        camera.current.position.set(0, 0, 1).applyQuaternion(currentQuaternion).multiplyScalar(radius).add(centerVec);
        camera.current.quaternion.rotateTowards(targetQuaternion, step);
        if (strict_equals(currentQuaternion.angleTo(finalQuaternion), 0)) {
          animating = false;
        }
        invalidate();
      }
    },
    {
      ...$$props.animationTask,
      autoInvalidate: false
    }
  );
  const findClosestPow2LargerThan = (x) => {
    if (x <= 0) {
      return 1;
    }
    let pow2 = 1;
    while (pow2 < x) {
      pow2 <<= 1;
    }
    return pow2;
  };
  let textureSize = derived(() => findClosestPow2LargerThan(size() * 0.3 * renderer.getPixelRatio()));
  const textures = {};
  const color2 = new Color();
  const getSpriteTexture = (size2, colorRepresentation, text = "") => {
    color2.set(colorRepresentation);
    const key2 = `${color2.getHexString()}-${text}`;
    if (textures[key2]) {
      textures[key2].dispose();
    }
    const canvas = document.createElement("canvas");
    canvas.width = size2;
    canvas.height = size2;
    const context = canvas.getContext("2d");
    context.beginPath();
    context.arc(size2 / 2, size2 / 2, size2 / 4, 0, 2 * Math.PI);
    context.closePath();
    context.fillStyle = color2.convertSRGBToLinear().getStyle();
    context.fill();
    if (text) {
      const textSize = Math.abs(size2 * (24 / 64));
      context.font = `${textSize}px Arial`;
      context.textAlign = "center";
      context.fillStyle = "#000000";
      const textY = size2 * (41 / 64);
      context.fillText(text, size2 / 2, textY);
    }
    const texture = new CanvasTexture(canvas);
    textures[key2] = texture;
    return texture;
  };
  const stemGeometry = new CapsuleGeometry(0.025, 0.78);
  stemGeometry.rotateZ(Math.PI / 2);
  let frontMostAxisIndex = derived(() => get(p).indexOf(Math.max(...get(p))));
  let usePolygonOffset = derived(() => get(p).some((v4) => v4 < 0));
  var fragment = comment();
  var node = first_child(fragment);
  T(node, {
    is: root6,
    attach: false,
    children: wrap_snippet(Gizmo, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_2();
      const polygonOffsetFactor = derived(() => -20);
      get(polygonOffsetFactor);
      var node_1 = first_child(fragment_1);
      component(node_1, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(posX), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.x": 1,
            "userData.targetPosition": [1, 0, 0],
            "userData.targetEuler": [0, Math.PI * 0.5, 0],
            get ref() {
              return get(posX);
            },
            set ref($$value) {
              set(posX, proxy($$value, null, posX));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              var map = derived(() => getSpriteTexture(get(textureSize), xColor(), "X"));
              var opacity = derived(() => get(p)[0] >= 0 ? 1 : 0.5);
              component(node_2, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map);
                  },
                  get opacity() {
                    return get(opacity);
                  }
                });
              });
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          });
        }
      });
      var node_3 = sibling(node_1, 2);
      var renderOrder = derived(() => strict_equals(get(frontMostAxisIndex), 0) ? -1 : 0);
      component(node_3, () => T.Mesh, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          "position.x": 0.39,
          get renderOrder() {
            return get(renderOrder);
          },
          children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
            var fragment_3 = root_4();
            var node_4 = first_child(fragment_3);
            T(node_4, { is: stemGeometry });
            var node_5 = sibling(node_4, 2);
            var opacity_1 = derived(() => get(p)[0] >= 0 ? 1 : 0.5);
            var polygonOffset = derived(() => get(usePolygonOffset) && strict_equals(get(frontMostAxisIndex), 0) && get(p)[0] < 0.75);
            component(node_5, () => T.MeshBasicMaterial, ($$anchor5, $$component2) => {
              $$component2($$anchor5, {
                transparent: true,
                get opacity() {
                  return get(opacity_1);
                },
                get color() {
                  return xColor();
                },
                get polygonOffset() {
                  return get(polygonOffset);
                },
                get polygonOffsetFactor() {
                  return get(polygonOffsetFactor);
                }
              });
            });
            append($$anchor4, fragment_3);
          }),
          $$slots: { default: true }
        });
      });
      var node_6 = sibling(node_3, 2);
      component(node_6, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(negX), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.x": -1,
            scale: 0.8,
            "userData.targetPosition": [-1, 0, 0],
            "userData.targetEuler": [0, -Math.PI * 0.5, 0],
            get ref() {
              return get(negX);
            },
            set ref($$value) {
              set(negX, proxy($$value, null, negX));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_4 = comment();
              var node_7 = first_child(fragment_4);
              var map_1 = derived(() => getSpriteTexture(get(textureSize), xColor()));
              var opacity_2 = derived(() => get(p)[0] >= 0 ? 0.5 : 1);
              component(node_7, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map_1);
                  },
                  get opacity() {
                    return get(opacity_2);
                  }
                });
              });
              append($$anchor4, fragment_4);
            }),
            $$slots: { default: true }
          });
        }
      });
      var node_8 = sibling(node_6, 2);
      component(node_8, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(posY), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.y": 1,
            "userData.targetPosition": [0, 1, 0],
            "userData.targetEuler": [-Math.PI * 0.5, 0, 0],
            get ref() {
              return get(posY);
            },
            set ref($$value) {
              set(posY, proxy($$value, null, posY));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_5 = comment();
              var node_9 = first_child(fragment_5);
              var map_2 = derived(() => getSpriteTexture(get(textureSize), yColor(), "Y"));
              var opacity_3 = derived(() => get(p)[1] >= 0 ? 1 : 0.5);
              component(node_9, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map_2);
                  },
                  get opacity() {
                    return get(opacity_3);
                  }
                });
              });
              append($$anchor4, fragment_5);
            }),
            $$slots: { default: true }
          });
        }
      });
      var node_10 = sibling(node_8, 2);
      var renderOrder_1 = derived(() => strict_equals(get(frontMostAxisIndex), 1) ? -1 : 0);
      component(node_10, () => T.Mesh, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          "position.y": 0.39,
          "rotation.z": Math.PI / 2,
          get renderOrder() {
            return get(renderOrder_1);
          },
          children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
            var fragment_6 = root_7();
            var node_11 = first_child(fragment_6);
            T(node_11, { is: stemGeometry });
            var node_12 = sibling(node_11, 2);
            var opacity_4 = derived(() => get(p)[1] >= 0 ? 1 : 0.5);
            var polygonOffset_1 = derived(() => get(usePolygonOffset) && strict_equals(get(frontMostAxisIndex), 1) && get(p)[1] < 0.75);
            component(node_12, () => T.MeshBasicMaterial, ($$anchor5, $$component2) => {
              $$component2($$anchor5, {
                transparent: true,
                get opacity() {
                  return get(opacity_4);
                },
                get color() {
                  return yColor();
                },
                get polygonOffset() {
                  return get(polygonOffset_1);
                },
                get polygonOffsetFactor() {
                  return get(polygonOffsetFactor);
                }
              });
            });
            append($$anchor4, fragment_6);
          }),
          $$slots: { default: true }
        });
      });
      var node_13 = sibling(node_10, 2);
      component(node_13, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(negY), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.y": -1,
            scale: 0.8,
            "userData.targetPosition": [0, -1, 0],
            "userData.targetEuler": [Math.PI * 0.5, 0, 0],
            get ref() {
              return get(negY);
            },
            set ref($$value) {
              set(negY, proxy($$value, null, negY));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_7 = comment();
              var node_14 = first_child(fragment_7);
              var map_3 = derived(() => getSpriteTexture(get(textureSize), yColor()));
              var opacity_5 = derived(() => get(p)[1] >= 0 ? 0.5 : 1);
              component(node_14, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map_3);
                  },
                  get opacity() {
                    return get(opacity_5);
                  }
                });
              });
              append($$anchor4, fragment_7);
            }),
            $$slots: { default: true }
          });
        }
      });
      var node_15 = sibling(node_13, 2);
      component(node_15, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(posZ), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.z": 1,
            "userData.targetPosition": [0, 0, 1],
            "userData.targetEuler": [0, 0, 0],
            get ref() {
              return get(posZ);
            },
            set ref($$value) {
              set(posZ, proxy($$value, null, posZ));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_8 = comment();
              var node_16 = first_child(fragment_8);
              var map_4 = derived(() => getSpriteTexture(get(textureSize), zColor(), "Z"));
              var opacity_6 = derived(() => get(p)[2] >= 0 ? 1 : 0.5);
              component(node_16, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map_4);
                  },
                  get opacity() {
                    return get(opacity_6);
                  }
                });
              });
              append($$anchor4, fragment_8);
            }),
            $$slots: { default: true }
          });
        }
      });
      var node_17 = sibling(node_15, 2);
      var renderOrder_2 = derived(() => strict_equals(get(frontMostAxisIndex), 2) ? -1 : 0);
      component(node_17, () => T.Mesh, ($$anchor3, $$component) => {
        $$component($$anchor3, {
          "position.z": 0.39,
          "rotation.y": -Math.PI / 2,
          get renderOrder() {
            return get(renderOrder_2);
          },
          children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
            var fragment_9 = root_10();
            var node_18 = first_child(fragment_9);
            T(node_18, { is: stemGeometry });
            var node_19 = sibling(node_18, 2);
            var opacity_7 = derived(() => get(p)[2] >= 0 ? 1 : 0.5);
            var polygonOffset_2 = derived(() => get(usePolygonOffset) && strict_equals(get(frontMostAxisIndex), 2) && get(p)[2] < 0.75);
            component(node_19, () => T.MeshBasicMaterial, ($$anchor5, $$component2) => {
              $$component2($$anchor5, {
                transparent: true,
                get opacity() {
                  return get(opacity_7);
                },
                get color() {
                  return zColor();
                },
                get polygonOffset() {
                  return get(polygonOffset_2);
                },
                get polygonOffsetFactor() {
                  return get(polygonOffsetFactor);
                }
              });
            });
            append($$anchor4, fragment_9);
          }),
          $$slots: { default: true }
        });
      });
      var node_20 = sibling(node_17, 2);
      component(node_20, () => T.Sprite, ($$anchor3, $$component) => {
        {
          add_owner_effect(() => get(negZ), $$component);
          $$component($$anchor3, {
            renderOrder: 1,
            "position.z": -1,
            scale: 0.8,
            "userData.targetPosition": [0, 0, -1],
            "userData.targetEuler": [0, Math.PI, 0],
            get ref() {
              return get(negZ);
            },
            set ref($$value) {
              set(negZ, proxy($$value, null, negZ));
            },
            children: wrap_snippet(Gizmo, ($$anchor4, $$slotProps2) => {
              var fragment_10 = comment();
              var node_21 = first_child(fragment_10);
              var map_5 = derived(() => getSpriteTexture(get(textureSize), zColor()));
              var opacity_8 = derived(() => get(p)[2] >= 0 ? 0.5 : 1);
              component(node_21, () => T.SpriteMaterial, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  get map() {
                    return get(map_5);
                  },
                  get opacity() {
                    return get(opacity_8);
                  }
                });
              });
              append($$anchor4, fragment_10);
            }),
            $$slots: { default: true }
          });
        }
      });
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Gizmo = hmr(Gizmo, () => Gizmo[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Gizmo[HMR].source;
    set(Gizmo[HMR].source, module.default[HMR].original);
  });
}
var Gizmo_default = Gizmo;
mark_module_end(Gizmo);

// node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte
mark_module_start();
ContactShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte";
var root_22 = add_locations(template(`<!> <!> <!>`, 1), ContactShadows[FILENAME], []);
function ContactShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ContactShadows);
  validate_prop_bindings($$props, ["ref"], ["refresh"], ContactShadows);
  let opacity = prop($$props, "opacity", 3, 1), width = prop($$props, "width", 3, 1), height = prop($$props, "height", 3, 1), blur = prop($$props, "blur", 3, 1), far = prop($$props, "far", 3, 10), smooth = prop($$props, "smooth", 3, true), resolution = prop($$props, "resolution", 3, 512), frames = prop($$props, "frames", 3, Infinity), scale = prop($$props, "scale", 3, 10), color2 = prop($$props, "color", 3, "#000000"), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "width",
      "height",
      "blur",
      "far",
      "smooth",
      "resolution",
      "frames",
      "scale",
      "color",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const { scene, renderer } = useThrelte();
  const group = new Group();
  const scaledWidth = derived(() => width() * (Array.isArray(scale()) ? scale()[0] : scale() || 1));
  const scaledHeight = derived(() => height() * (Array.isArray(scale()) ? scale()[1] : scale() || 1));
  const renderTarget = derived(() => {
    const rt = new WebGLRenderTarget(resolution(), resolution());
    rt.texture.generateMipmaps = false;
    rt.texture.colorSpace = renderer.outputColorSpace;
    return rt;
  });
  const renderTargetBlur = derived(() => {
    const rt = new WebGLRenderTarget(resolution(), resolution());
    rt.texture.generateMipmaps = false;
    return rt;
  });
  const planeGeometry = derived(() => new PlaneGeometry(get(scaledWidth), get(scaledHeight)).rotateX(Math.PI / 2));
  const blurPlane = derived(() => new Mesh(get(planeGeometry)));
  const depthMaterial = derived(() => {
    const dm = new MeshDepthMaterial({ depthTest: false, depthWrite: false });
    dm.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        uColor: {
          value: new Color(color2()).convertSRGBToLinear()
        }
      };
      shader.fragmentShader = `uniform vec3 uColor;
${shader.fragmentShader}`;
      shader.fragmentShader = shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );");
      shader.fragmentShader = shader.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    };
    return dm;
  });
  const horizontalBlurMaterial = new ShaderMaterial({ ...HorizontalBlurShader, depthTest: false });
  const verticalBlurMaterial = new ShaderMaterial({ ...VerticalBlurShader, depthTest: false });
  const shadowCamera = derived(() => new OrthographicCamera(-get(scaledWidth) / 2, get(scaledWidth) / 2, get(scaledHeight) / 2, -get(scaledHeight) / 2, 0, far()));
  user_pre_effect(() => get(shadowCamera).updateProjectionMatrix());
  const shadowMaterial = derived(() => new MeshBasicMaterial({
    map: get(renderTarget).texture,
    transparent: true,
    opacity: opacity(),
    depthWrite: depthWrite()
  }));
  const blurShadows = (blur2) => {
    get(blurPlane).visible = true;
    get(blurPlane).material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = get(renderTarget).texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTargetBlur));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = get(renderTargetBlur).texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(get(blurPlane), get(shadowCamera));
    get(blurPlane).visible = false;
  };
  const renderShadows = () => {
    const initialBackground = scene.background;
    scene.background = null;
    const initialOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = get(depthMaterial);
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget(get(renderTarget));
    renderer.render(scene, get(shadowCamera));
    scene.overrideMaterial = initialOverrideMaterial;
    blurShadows(blur());
    if (smooth()) blurShadows(blur() * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    renderer.setClearAlpha(initialClearAlpha);
  };
  const refresh = () => {
    renderShadows();
  };
  const task = useTask(
    () => {
      renderShadows();
    },
    { autoStart: false }
  );
  let count = 0;
  const countTask = useTask(
    () => {
      renderShadows();
      count += 1;
      if (count >= frames()) countTask.stop();
    },
    { autoStart: false }
  );
  user_pre_effect(() => {
    if (strict_equals(frames(), Number.POSITIVE_INFINITY)) {
      task.start();
    } else if (count < frames()) {
      countTask.start();
    }
  });
  onDestroy(() => {
    get(renderTarget).dispose();
    get(renderTargetBlur).dispose();
    get(planeGeometry).dispose();
    get(depthMaterial).dispose();
    horizontalBlurMaterial.dispose();
    verticalBlurMaterial.dispose();
    get(shadowMaterial).dispose();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(ContactShadows, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        component(node_1, () => T.Group, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            "rotation.x": Math.PI / 2,
            children: wrap_snippet(ContactShadows, ($$anchor4, $$slotProps2) => {
              var fragment_2 = root_22();
              var node_2 = first_child(fragment_2);
              component(node_2, () => T.Mesh, ($$anchor5, $$component2) => {
                $$component2($$anchor5, {
                  "scale.y": -1,
                  "rotation.x": -Math.PI / 2,
                  get material() {
                    return get(shadowMaterial);
                  },
                  get geometry() {
                    return get(planeGeometry);
                  }
                });
              });
              var node_3 = sibling(node_2, 2);
              T(node_3, {
                get is() {
                  return get(shadowCamera);
                },
                manual: true
              });
              var node_4 = sibling(node_3, 2);
              snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group }));
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          });
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get refresh() {
      return refresh;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  ContactShadows = hmr(ContactShadows, () => ContactShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ContactShadows[HMR].source;
    set(ContactShadows[HMR].source, module.default[HMR].original);
  });
}
var ContactShadows_default = ContactShadows;
mark_module_end(ContactShadows);

// node_modules/@threlte/extras/dist/lib/revision.js
var revision2 = Number.parseInt(REVISION.replace("dev", ""));

// node_modules/@threlte/extras/dist/components/Environment/GroundProjectedSkybox.svelte
mark_module_start();
GroundProjectedSkybox[FILENAME] = "node_modules/@threlte/extras/dist/components/Environment/GroundProjectedSkybox.svelte";
function GroundProjectedSkybox($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["envMap"]);
  push($$props, false, GroundProjectedSkybox);
  let envMap = prop($$props, "envMap", 8);
  const url = revision2 > 160 ? "three/examples/jsm/objects/GroundedSkybox.js" : "three/examples/jsm/objects/GroundProjectedSkybox.js";
  const module = import(
    /* @vite-ignore */
    url
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      await_block(node_1, () => module, null, ($$anchor3, result) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        var is = derived_safe_equal(() => revision2 > 160 ? get(result).GroundedSkybox : get(result).GroundProjectedSkybox);
        var args = derived_safe_equal(() => [envMap()]);
        T(node_2, spread_props(
          {
            get is() {
              return get(is);
            },
            get args() {
              return get(args);
            }
          },
          () => $$restProps
        ));
        append($$anchor3, fragment_2);
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (envMap()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GroundProjectedSkybox = hmr(GroundProjectedSkybox, () => GroundProjectedSkybox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GroundProjectedSkybox[HMR].source;
    set(GroundProjectedSkybox[HMR].source, module.default[HMR].original);
  });
}
var GroundProjectedSkybox_default = GroundProjectedSkybox;
mark_module_end(GroundProjectedSkybox);

// node_modules/@threlte/extras/dist/components/Environment/Environment.svelte
mark_module_start();
Environment[FILENAME] = "node_modules/@threlte/extras/dist/components/Environment/Environment.svelte";
function Environment($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Environment);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const isCubeMap = mutable_state();
  const envPath = mutable_state();
  let path = prop($$props, "path", 8, "");
  let files = prop($$props, "files", 8);
  let isBackground = prop($$props, "isBackground", 8, void 0);
  let groundProjection = prop($$props, "groundProjection", 12, void 0);
  let format = prop($$props, "format", 8, void 0);
  let colorSpace = prop($$props, "colorSpace", 8, void 0);
  const { scene: globalScene, invalidate } = useThrelte();
  const parent = useParent();
  let scene = mutable_state(globalScene);
  if (isInstanceOf($parent(), "Scene")) set(scene, $parent());
  let previousSceneEnvironment = get(scene).environment;
  let previousSceneBackground = get(scene).background;
  let previousEnvPath = mutable_state(get(envPath));
  let previousEnvMap = mutable_state();
  let previousFormat = mutable_state();
  const pickLoader = () => {
    const inferredFormat = format() || equals((Array.isArray(files()) ? files()[0] : files()).split(".").pop(), "hdr") ? "hdr" : "ldr";
    if (get(isCubeMap) && equals(inferredFormat, "ldr")) return CubeTextureLoader;
    if (!get(isCubeMap) && equals(inferredFormat, "ldr")) return TextureLoader;
    if (get(isCubeMap) && equals(inferredFormat, "hdr")) return HDRCubeTextureLoader;
    if (!get(isCubeMap) && equals(inferredFormat, "hdr")) return RGBELoader;
    return TextureLoader;
  };
  const { remember } = useCache();
  const suspend = useSuspense();
  const loadEnvironment = async () => {
    var _a;
    const LoaderType = pickLoader();
    const loader = new LoaderType();
    (_a = loader.setDataType) == null ? void 0 : _a.call(loader, FloatType);
    const filesKey = Array.isArray(files()) ? files().join(",") : files();
    const cacheKey = [LoaderType, path(), filesKey];
    const texture = await remember(
      async () => {
        return suspend(new Promise((resolve, reject) => {
          loader.setPath(path()).load(files(), (texture2) => {
            resolve(texture2);
          });
        }));
      },
      cacheKey
    );
    texture.mapping = get(isCubeMap) ? CubeReflectionMapping : EquirectangularReflectionMapping;
    texture.colorSpace = colorSpace() ?? get(isCubeMap) ? LinearSRGBColorSpace : SRGBColorSpace;
    set(previousEnvMap, texture);
    mutate(scene, get(scene).environment = get(previousEnvMap));
    if (isBackground()) mutate(scene, get(scene).background = get(previousEnvMap));
    invalidate();
    set(previousFormat, format() || void 0);
    set(previousEnvPath, get(envPath));
  };
  onDestroy(() => {
    mutate(scene, get(scene).environment = previousSceneEnvironment);
    mutate(scene, get(scene).background = previousSceneBackground);
    if (get(previousEnvMap)) get(previousEnvMap).dispose();
    groundProjection(void 0);
    invalidate();
  });
  legacy_pre_effect(() => deep_read_state(files()), () => {
    set(isCubeMap, Array.isArray(files()));
  });
  legacy_pre_effect(
    () => (deep_read_state(path()), deep_read_state(files())),
    () => {
      set(envPath, `${path()}${files()}`);
    }
  );
  legacy_pre_effect(
    () => (get(envPath), get(previousEnvPath), deep_read_state(format()), get(previousFormat), get(previousEnvMap), deep_read_state(groundProjection()), deep_read_state(isBackground()), get(scene)),
    () => {
      if (equals(get(envPath), get(previousEnvPath), false) || equals(format(), get(previousFormat), false)) {
        if (get(previousEnvMap)) {
          get(previousEnvMap).dispose();
        }
        loadEnvironment();
        groundProjection(groundProjection());
      }
      if (!isBackground() && get(scene).background) {
        mutate(scene, get(scene).background = null);
        invalidate();
      }
      if (isBackground() && !get(scene).background && get(previousEnvMap)) {
        mutate(scene, get(scene).background = get(previousEnvMap));
        invalidate();
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      GroundProjectedSkybox_default(node_1, spread_props(groundProjection, {
        get envMap() {
          return get(previousEnvMap);
        }
      }));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (groundProjection()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Environment = hmr(Environment, () => Environment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Environment[HMR].source;
    set(Environment[HMR].source, module.default[HMR].original);
  });
}
var Environment_default = Environment;
mark_module_end(Environment);

// node_modules/@threlte/extras/dist/components/ImageMaterial/shaders.js
var vertexShader = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
);
var fragmentShader = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
);

// node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte
mark_module_start();
ImageMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte";
function ImageMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ImageMaterial);
  const $$stores = setup_stores();
  const $textureStore = () => (validate_store(textureStore, "textureStore"), store_get(textureStore, "$textureStore", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  validate_prop_bindings($$props, ["ref"], [], ImageMaterial);
  let color2 = prop($$props, "color", 3, "white"), zoom = prop($$props, "zoom", 3, 1), radius = prop($$props, "radius", 3, 0), alphaThreshold = prop($$props, "alphaThreshold", 3, 0), alphaSmoothing = prop($$props, "alphaSmoothing", 3, 0.1), brightness = prop($$props, "brightness", 3, 0), contrast = prop($$props, "contrast", 3, 0), hue = prop($$props, "hue", 3, 0), saturation = prop($$props, "saturation", 3, 0), lightness = prop($$props, "lightness", 3, 0), negative = prop($$props, "negative", 3, false), opacity = prop($$props, "opacity", 3, 1), toneMapped = prop($$props, "toneMapped", 3, true), transparent = prop($$props, "transparent", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "zoom",
      "radius",
      "alphaThreshold",
      "alphaSmoothing",
      "brightness",
      "contrast",
      "hue",
      "saturation",
      "lightness",
      "negative",
      "opacity",
      "toneMapped",
      "transparent",
      "texture",
      "monochromeColor",
      "monochromeStrength",
      "colorProcessingTexture",
      "side",
      "url",
      "ref",
      "children"
    ],
    "props"
  );
  const material = new ShaderMaterial();
  const suspend = useSuspense();
  let textureStore = asyncWritable(Promise.resolve(void 0));
  user_pre_effect(() => {
    textureStore = suspend($$props.url ? useTexture($$props.url) : asyncWritable(Promise.resolve($$props.texture)));
  });
  let { size } = useThrelte();
  const parent = useParent();
  const uniforms = {
    color: { value: new Color(color2()) },
    scale: { value: new Vector2() },
    imageBounds: { value: new Vector2(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: zoom() },
    radius: { value: radius() },
    alphaThreshold: { value: alphaThreshold() },
    alphaSmoothing: { value: alphaSmoothing() },
    brightness: { value: brightness() },
    contrast: { value: contrast() },
    monochromeColor: { value: new Color($$props.monochromeColor) },
    monochromeStrength: { value: $$props.monochromeStrength ?? 0 },
    negative: { value: negative() ? 1 : 0 },
    opacity: { value: opacity() },
    hsl: { value: new Vector3(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  user_pre_effect(() => {
    uniforms.color.value.set(color2());
  });
  user_pre_effect(() => {
    var _a, _b;
    uniforms.imageBounds.value.set(((_a = $textureStore()) == null ? void 0 : _a.image.width) ?? 0, ((_b = $textureStore()) == null ? void 0 : _b.image.height) ?? 0);
  });
  user_pre_effect(() => {
    uniforms.resolution.value = Math.max($size().width, $size().height);
  });
  user_pre_effect(() => {
    uniforms.zoom.value = zoom();
  });
  user_pre_effect(() => {
    uniforms.radius.value = radius();
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    uniforms.alphaThreshold.value = alphaThreshold();
  });
  user_pre_effect(() => {
    uniforms.alphaSmoothing.value = alphaSmoothing();
  });
  user_pre_effect(() => {
    uniforms.brightness.value = brightness();
  });
  user_pre_effect(() => {
    uniforms.contrast.value = contrast();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.x = hue();
  });
  user_pre_effect(() => {
    uniforms.hsl.value.z = lightness();
  });
  user_pre_effect(() => {
    uniforms.negative.value = negative() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.map.value = $textureStore() ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProccessingTexture.value = $$props.colorProcessingTexture ?? null;
  });
  user_pre_effect(() => {
    uniforms.colorProcessingTextureOverride.value = $$props.colorProcessingTexture ? 1 : 0;
  });
  user_pre_effect(() => {
    if (strict_equals($$props.monochromeColor, void 0, false)) {
      uniforms.monochromeColor.value.set($$props.monochromeColor);
      uniforms.monochromeStrength.value = $$props.monochromeStrength ?? 1;
    } else {
      uniforms.monochromeStrength.value = 0;
    }
  });
  user_pre_effect(() => {
    let colorProcessingEnabled = 0;
    const monochromeCheck = ($$props.monochromeColor ? 1 : 0) * (strict_equals($$props.monochromeStrength, void 0) ? 1 : $$props.monochromeStrength);
    for (const value of [
      brightness(),
      contrast(),
      hue(),
      saturation(),
      lightness(),
      monochromeCheck,
      $$props.colorProcessingTexture ? 1 : 0
    ]) {
      if (strict_equals(value, 0, false)) {
        colorProcessingEnabled = 1;
        break;
      }
    }
    uniforms.colorProcessingEnabled.value = colorProcessingEnabled;
  });
  useTask(() => {
    const mesh = $parent();
    if (!isInstanceOf(mesh, "Mesh")) return;
    uniforms.scale.value.set(mesh.scale.x, mesh.scale.y);
    const geometry = mesh.geometry;
    if (strict_equals(geometry, void 0, false) && "parameters" in geometry) {
      const { width, height } = geometry.parameters;
      uniforms.scale.value.set(uniforms.scale.value.x * width, uniforms.scale.value.y * height);
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: material,
        uniforms,
        get toneMapped() {
          return toneMapped();
        },
        get transparent() {
          return transparent();
        },
        get side() {
          return $$props.side;
        },
        vertexShader,
        fragmentShader
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(ImageMaterial, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ImageMaterial = hmr(ImageMaterial, () => ImageMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageMaterial[HMR].source;
    set(ImageMaterial[HMR].source, module.default[HMR].original);
  });
}
var ImageMaterial_default = ImageMaterial;
mark_module_end(ImageMaterial);

// node_modules/@threlte/extras/dist/components/Grid/gridShaders.js
var vertexShader2 = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
);
var fragmentShader2 = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>
	}
`
);

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
mark_module_start();
Grid[FILENAME] = "node_modules/@threlte/extras/dist/components/Grid/Grid.svelte";
var root_13 = add_locations(template(`<!> <!>`, 1), Grid[FILENAME], []);
function Grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Grid);
  validate_prop_bindings($$props, ["ref"], [], Grid);
  let cellColor = prop($$props, "cellColor", 3, "#000000"), sectionColor = prop($$props, "sectionColor", 3, "#0000ee"), cellSize = prop($$props, "cellSize", 3, 1), backgroundColor = prop($$props, "backgroundColor", 3, "#dadada"), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0), sectionSize = prop($$props, "sectionSize", 3, 10), plane = prop($$props, "plane", 3, "xz"), gridSize = prop($$props, "gridSize", 19, () => [20, 20]), followCamera = prop($$props, "followCamera", 3, false), infiniteGrid = prop($$props, "infiniteGrid", 3, false), fadeDistance = prop($$props, "fadeDistance", 3, 100), fadeStrength = prop($$props, "fadeStrength", 3, 1), cellThickness = prop($$props, "cellThickness", 3, 1), sectionThickness = prop($$props, "sectionThickness", 3, 2), side = prop($$props, "side", 3, DoubleSide), type = prop($$props, "type", 3, "grid"), axis = prop($$props, "axis", 3, "x"), maxRadius = prop($$props, "maxRadius", 3, 0), cellDividers = prop($$props, "cellDividers", 3, 6), sectionDividers = prop($$props, "sectionDividers", 3, 2), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cellColor",
      "sectionColor",
      "cellSize",
      "backgroundColor",
      "backgroundOpacity",
      "sectionSize",
      "plane",
      "gridSize",
      "followCamera",
      "infiniteGrid",
      "fadeDistance",
      "fadeStrength",
      "cellThickness",
      "sectionThickness",
      "side",
      "type",
      "axis",
      "maxRadius",
      "cellDividers",
      "sectionDividers",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh();
  const { invalidate, camera } = useThrelte();
  const gridPlane = new Plane();
  const upVector = new Vector3(0, 1, 0);
  const zeroVector = new Vector3(0, 0, 0);
  const axisToInt = { x: 0, y: 1, z: 2 };
  const planeToAxes = { xz: "xzy", xy: "xyz", zy: "zyx" };
  const gridType = { grid: 0, lines: 1, circular: 2, polar: 3 };
  const uniforms = {
    cellSize: { value: cellSize() },
    sectionSize: { value: sectionSize() },
    cellColor: { value: new Color(cellColor()) },
    sectionColor: { value: new Color(sectionColor()) },
    backgroundColor: { value: new Color(backgroundColor()) },
    backgroundOpacity: { value: backgroundOpacity() },
    fadeDistance: { value: fadeDistance() },
    fadeStrength: { value: fadeStrength() },
    cellThickness: { value: cellThickness() },
    sectionThickness: { value: sectionThickness() },
    infiniteGrid: { value: infiniteGrid() },
    followCamera: { value: followCamera() },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: gridType.grid },
    lineGridCoord: { value: axisToInt[axis()] },
    circleGridMaxRadius: { value: maxRadius() },
    polarCellDividers: { value: cellDividers() },
    polarSectionDividers: { value: sectionDividers() },
    worldCamProjPosition: { value: new Vector3() },
    worldPlanePosition: { value: new Vector3() }
  };
  user_pre_effect(() => {
    const axes = planeToAxes[plane()];
    const c0 = axes.charAt(0);
    const c1 = axes.charAt(1);
    const c2 = axes.charAt(2);
    uniforms.coord0.value = axisToInt[c0];
    uniforms.coord1.value = axisToInt[c1];
    uniforms.coord2.value = axisToInt[c2];
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellSize.value = cellSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionSize.value = sectionSize();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellColor.value.set(cellColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionColor.value.set(sectionColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundColor.value.set(backgroundColor());
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.backgroundOpacity.value = backgroundOpacity();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeDistance.value = fadeDistance();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.fadeStrength.value = fadeStrength();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.cellThickness.value = cellThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.sectionThickness.value = sectionThickness();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.followCamera.value = followCamera();
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.infiniteGrid.value = infiniteGrid();
    invalidate();
  });
  user_pre_effect(() => {
    switch (type()) {
      case "grid": {
        uniforms.gridType.value = gridType.grid;
        break;
      }
      case "lines": {
        uniforms.gridType.value = gridType.lines;
        uniforms.lineGridCoord.value = axisToInt[axis()];
        break;
      }
      case "circular": {
        uniforms.gridType.value = gridType.circular;
        uniforms.circleGridMaxRadius.value = maxRadius();
        break;
      }
      case "polar": {
        uniforms.gridType.value = gridType.polar;
        uniforms.circleGridMaxRadius.value = maxRadius();
        uniforms.polarCellDividers.value = cellDividers();
        uniforms.polarSectionDividers.value = sectionDividers();
        break;
      }
    }
    invalidate();
  });
  useTask(
    () => {
      gridPlane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(mesh.matrixWorld);
      const material = mesh.material;
      const worldCamProjPosition = material.uniforms.worldCamProjPosition;
      const worldPlanePosition = material.uniforms.worldPlanePosition;
      gridPlane.projectPoint(camera.current.position, worldCamProjPosition.value);
      worldPlanePosition.value.set(0, 0, 0).applyMatrix4(mesh.matrixWorld);
    },
    { autoInvalidate: false }
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: mesh, frustumCulled: false }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Grid, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_13();
        var node_1 = first_child(fragment_1);
        component(node_1, () => T.ShaderMaterial, ($$anchor3, $$component) => {
          $$component($$anchor3, {
            fragmentShader: fragmentShader2,
            vertexShader: vertexShader2,
            uniforms,
            transparent: true,
            get side() {
              return side();
            }
          });
        });
        var node_2 = sibling(node_1, 2);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children, () => ({ ref: mesh }));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var fragment_3 = comment();
            var node_4 = first_child(fragment_3);
            var args = derived(() => equals(typeof gridSize(), "number") ? [gridSize(), gridSize()] : gridSize());
            component(node_4, () => T.PlaneGeometry, ($$anchor4, $$component) => {
              $$component($$anchor4, {
                get args() {
                  return get(args);
                }
              });
            });
            append($$anchor3, fragment_3);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Grid = hmr(Grid, () => Grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Grid[HMR].source;
    set(Grid[HMR].source, module.default[HMR].original);
  });
}
var Grid_default = Grid;
mark_module_end(Grid);

// node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte
mark_module_start();
RoundedBoxGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte";
function RoundedBoxGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RoundedBoxGeometry);
  validate_prop_bindings($$props, ["ref"], [], RoundedBoxGeometry);
  let args = prop($$props, "args", 19, () => []), radius = prop($$props, "radius", 3, 0.05), smoothness = prop($$props, "smoothness", 3, 4), creaseAngle = prop($$props, "creaseAngle", 3, 0.4), steps = prop($$props, "steps", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "args",
      "radius",
      "smoothness",
      "creaseAngle",
      "steps",
      "ref",
      "children"
    ],
    "props"
  );
  const eps = 1e-5;
  const createShape = (width2, height2, radius0) => {
    const shape2 = new Shape();
    const radius2 = radius0 - eps;
    shape2.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
    shape2.absarc(eps, height2 - radius2 * 2, eps, Math.PI, Math.PI / 2, true);
    shape2.absarc(width2 - radius2 * 2, height2 - radius2 * 2, eps, Math.PI / 2, 0, true);
    shape2.absarc(width2 - radius2 * 2, eps, eps, 0, -Math.PI / 2, true);
    return shape2;
  };
  let width = derived(() => args()[0] ?? 1);
  let height = derived(() => args()[1] ?? 1);
  let depth = derived(() => args()[2] ?? 1);
  let shape = derived(() => createShape(get(width), get(height), radius()));
  let params = derived(() => ({
    depth: get(depth) - radius() * 2,
    bevelEnabled: true,
    bevelSegments: smoothness() * 2,
    steps: steps(),
    bevelSize: radius() - eps,
    bevelThickness: radius(),
    curveSegments: smoothness()
  }));
  let geometry = derived(() => new ExtrudeGeometry(get(shape), get(params)));
  user_pre_effect(() => {
    get(geometry).center();
    toCreasedNormals(get(geometry), creaseAngle());
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        get is() {
          return get(geometry);
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(RoundedBoxGeometry, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: get(geometry) }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RoundedBoxGeometry = hmr(RoundedBoxGeometry, () => RoundedBoxGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RoundedBoxGeometry[HMR].source;
    set(RoundedBoxGeometry[HMR].source, module.default[HMR].original);
  });
}
var RoundedBoxGeometry_default = RoundedBoxGeometry;
mark_module_end(RoundedBoxGeometry);

// node_modules/@threlte/extras/dist/components/controls/useControlsContext.js
var useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0),
    trackballControls: writable(void 0)
  });
};

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
mark_module_start();
TransformControls_1[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte";
var root2 = add_locations(template(`<!> <!>`, 1), TransformControls_1[FILENAME], []);
function TransformControls_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TransformControls_1);
  const $$stores = setup_stores();
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  validate_prop_bindings($$props, ["controls", "group"], [], TransformControls_1);
  let autoPauseOrbitControls = prop($$props, "autoPauseOrbitControls", 3, true), autoPauseTrackballControls = prop($$props, "autoPauseTrackballControls", 3, true), controls = prop($$props, "controls", 15), group = prop($$props, "group", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoPauseOrbitControls",
      "autoPauseTrackballControls",
      "object",
      "controls",
      "group",
      "children"
    ],
    "props"
  );
  const { camera, renderer, invalidate, scene } = useThrelte();
  const { orbitControls, trackballControls } = useControlsContext();
  const isDragging = currentWritable(false);
  const useAutoPauseOrbitControls = writable(autoPauseOrbitControls() ?? true);
  user_pre_effect(() => useAutoPauseOrbitControls.set(autoPauseOrbitControls() ?? true));
  const useAutoPauseTrackballControls = writable(autoPauseTrackballControls() ?? true);
  user_pre_effect(() => useAutoPauseTrackballControls.set(autoPauseTrackballControls() ?? true));
  watch(
    [
      orbitControls,
      isDragging,
      useAutoPauseOrbitControls
    ],
    ([
      orbitControls2,
      isDragging2,
      useAutoPauseOrbitControls2
    ]) => {
      if (!orbitControls2 || !orbitControls2.enabled && isDragging2) return;
      orbitControls2.enabled = !(isDragging2 && useAutoPauseOrbitControls2);
      return () => {
        orbitControls2.enabled = true;
      };
    }
  );
  watch(
    [
      trackballControls,
      isDragging,
      useAutoPauseTrackballControls
    ],
    ([
      trackballControls2,
      isDragging2,
      useAutoPausetrackballControls
    ]) => {
      if (!trackballControls2 || !trackballControls2.enabled && isDragging2) return;
      trackballControls2.enabled = !(isDragging2 && useAutoPausetrackballControls);
      return () => {
        trackballControls2.enabled = true;
      };
    }
  );
  const attachGroup = new Group();
  let transformControls = derived(() => new TransformControls($camera(), renderer.domElement.parentElement));
  user_pre_effect(() => {
    var _a;
    (_a = get(transformControls)) == null ? void 0 : _a.attach($$props.object ?? attachGroup);
    return () => {
      var _a2;
      return (_a2 = get(transformControls)) == null ? void 0 : _a2.detach();
    };
  });
  const transformOnlyPropNames = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible",
    "onmouseDown",
    "onmouseUp",
    "onobjectChange"
  ];
  let transformProps = state(proxy({}));
  let objectProps = state(proxy({}));
  user_pre_effect(() => {
    set(transformProps, proxy({}, null, transformProps));
    set(objectProps, proxy({}, null, objectProps));
    Object.keys(props).forEach((key2) => {
      user_pre_effect(() => {
        if (transformOnlyPropNames.includes(key2)) {
          get(transformProps)[key2] = props[key2];
        } else {
          get(objectProps)[key2] = props[key2];
        }
      });
    });
  });
  const onchange = (event) => {
    var _a;
    invalidate();
    if (get(transformControls).dragging && !isDragging.current) {
      isDragging.set(true);
    } else if (!get(transformControls).dragging && isDragging.current) {
      isDragging.set(false);
    }
    (_a = $$props.onchange) == null ? void 0 : _a.call($$props, event);
  };
  var fragment = root2();
  var node = first_child(fragment);
  {
    add_owner_effect(controls, T);
    T(node, spread_props(
      {
        get is() {
          return get(transformControls);
        },
        onchange
      },
      () => get(transformProps),
      {
        attach: ({ ref }) => {
          const helper = ref.getHelper();
          scene.add(helper);
          return () => {
            scene.remove(helper);
          };
        },
        dispose: false,
        oncreate: (ref) => {
          return () => ref.dispose();
        },
        get ref() {
          return controls();
        },
        set ref($$value) {
          controls($$value);
        }
      }
    ));
  }
  var node_1 = sibling(node, 2);
  {
    add_owner_effect(group, T);
    T(node_1, spread_props({ is: attachGroup }, () => get(objectProps), {
      get ref() {
        return group();
      },
      set ref($$value) {
        group($$value);
      },
      children: wrap_snippet(TransformControls_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children, () => ({ ref: attachGroup }));
            append($$anchor3, fragment_2);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TransformControls_1 = hmr(TransformControls_1, () => TransformControls_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TransformControls_1[HMR].source;
    set(TransformControls_1[HMR].source, module.default[HMR].original);
  });
}
var TransformControls_default = TransformControls_1;
mark_module_end(TransformControls_1);

// node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte
mark_module_start();
OrbitControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte";
function OrbitControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, OrbitControls2);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  validate_prop_bindings($$props, ["ref"], [], OrbitControls2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = useParent();
  const { renderer, invalidate } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const controls = new OrbitControls($parent(), renderer.domElement.parentElement);
  const { start, stop } = useTask(() => controls.update(), { autoStart: false, autoInvalidate: false });
  user_pre_effect(() => {
    if ($$props.autoRotate || $$props.enableDamping) {
      start();
    } else {
      stop();
    }
  });
  const { orbitControls } = useControlsContext();
  orbitControls.set(controls);
  onDestroy(() => orbitControls.set(void 0));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: controls,
        onchange: (event) => {
          var _a;
          invalidate();
          (_a = $$props.onchange) == null ? void 0 : _a.call($$props, event);
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(OrbitControls2, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OrbitControls2 = hmr(OrbitControls2, () => OrbitControls2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OrbitControls2[HMR].source;
    set(OrbitControls2[HMR].source, module.default[HMR].original);
  });
}
var OrbitControls_default = OrbitControls2;
mark_module_end(OrbitControls2);

// node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte
mark_module_start();
TrackballControls2[FILENAME] = "node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte";
function TrackballControls2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TrackballControls2);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  validate_prop_bindings($$props, ["ref"], [], TrackballControls2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const parent = useParent();
  const { renderer, invalidate } = useThrelte();
  if (!isInstanceOf($parent(), "Camera")) {
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  }
  const controls = new TrackballControls($parent(), renderer.domElement.parentElement);
  useTask(() => controls.update(), { autoInvalidate: false });
  const { trackballControls } = useControlsContext();
  trackballControls.set(controls);
  onDestroy(() => trackballControls.set(void 0));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: controls }, () => props, {
      onchange: (event) => {
        var _a;
        invalidate();
        (_a = $$props.onchange) == null ? void 0 : _a.call($$props, event);
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(TrackballControls2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: controls }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TrackballControls2 = hmr(TrackballControls2, () => TrackballControls2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackballControls2[HMR].source;
    set(TrackballControls2[HMR].source, module.default[HMR].original);
  });
}
var TrackballControls_default = TrackballControls2;
mark_module_end(TrackballControls2);

// node_modules/@threlte/extras/dist/components/Instancing/api.js
var getContextId = (instancedMeshId) => `threlte-instanced-mesh-${instancedMeshId}`;
var createApi = (instancedMesh, instancedMeshId) => {
  const api = {
    instancedMesh: currentWritable(instancedMesh),
    addInstance(instance) {
      api.instances.update((arr) => {
        arr.push(instance);
        return arr;
      });
    },
    removeInstance(instance) {
      api.instances.update((arr) => {
        const index = arr.indexOf(instance);
        if (index > -1)
          arr.splice(index, 1);
        return arr;
      });
    },
    instances: currentWritable([])
  };
  setContext(getContextId(instancedMeshId), api);
  return api;
};
var useApi = (instancedMeshId) => {
  const context = getContext(getContextId(instancedMeshId));
  if (!context)
    throw new Error(`No <InstancedMesh> component found for id ${instancedMeshId}`);
  return context;
};

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
mark_module_start();
Api[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Api.svelte";
var root3 = add_locations(template(`<!> <!> <!>`, 1), Api[FILENAME], []);
function Api($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Api);
  const $$stores = setup_stores();
  const $instances = () => (validate_store(instances, "instances"), store_get(instances, "$instances", $$stores));
  validate_prop_bindings($$props, [], [], Api);
  let instancedMesh = prop($$props, "instancedMesh", 7);
  const { instances } = createApi(instancedMesh(), $$props.id);
  const tempMatrix = new Matrix4();
  const matrices = new Float32Array($$props.limit * 16);
  for (let i = 0; i < $$props.limit; i++) tempMatrix.identity().toArray(matrices, i * 16);
  const colors = new Float32Array($$props.limit * 3).fill(1);
  const parentMatrix = new Matrix4();
  const instanceMatrix = new Matrix4();
  const translation = new Vector3();
  const rotation = new Quaternion();
  const scale = new Vector3();
  let initialUpdateDone = false;
  useTask(() => {
    instancedMesh().updateMatrix();
    if ($$props.update || !initialUpdateDone) {
      instancedMesh().updateMatrixWorld();
      parentMatrix.copy(instancedMesh().matrixWorld).invert();
      if (instancedMesh().instanceColor) {
        instancedMesh().instanceColor.needsUpdate = true;
      }
      instancedMesh().instanceMatrix.needsUpdate = true;
      for (let i = 0, l = instances.current.length; i < l; i++) {
        const instance = instances.current[i];
        instance.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);
        instanceMatrix.toArray(matrices, i * 16);
        instance.color.toArray(colors, i * 3);
      }
      initialUpdateDone = true;
    }
  });
  user_pre_effect(() => {
    const updateRange = Math.min($$props.limit, strict_equals($$props.range, void 0, false) ? $$props.range : $$props.limit, $instances().length);
    instancedMesh().count = updateRange;
    if (revision >= 159) {
      instancedMesh().instanceMatrix.clearUpdateRanges();
      instancedMesh().instanceMatrix.addUpdateRange(0, updateRange * 16);
    } else {
      instancedMesh().instanceMatrix.updateRange.count = updateRange * 16;
    }
    if (instancedMesh().instanceColor) {
      if (revision >= 159) {
        instancedMesh().instanceColor.clearUpdateRanges();
        instancedMesh().instanceColor.addUpdateRange(0, updateRange * 3);
      } else {
        instancedMesh().instanceColor.updateRange.count = updateRange * 3;
      }
    }
  });
  var fragment = root3();
  var node = first_child(fragment);
  var count = derived(() => matrices.length / 16);
  component(node, () => T.InstancedBufferAttribute, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      attach: "instanceMatrix",
      get count() {
        return get(count);
      },
      array: matrices,
      itemSize: 16,
      usage: DynamicDrawUsage
    });
  });
  var node_1 = sibling(node, 2);
  var count_1 = derived(() => colors.length / 3);
  component(node_1, () => T.InstancedBufferAttribute, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      attach: "instanceColor",
      get count() {
        return get(count_1);
      },
      array: colors,
      itemSize: 3,
      usage: DynamicDrawUsage
    });
  });
  var node_2 = sibling(node_1, 2);
  snippet(node_2, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Api = hmr(Api, () => Api[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Api[HMR].source;
    set(Api[HMR].source, module.default[HMR].original);
  });
}
var Api_default = Api;
mark_module_end(Api);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
mark_module_start();
InstancedMesh_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte";
function InstancedMesh_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMesh_1);
  validate_prop_bindings($$props, ["ref"], [], InstancedMesh_1);
  let id = prop($$props, "id", 3, "default"), limit = prop($$props, "limit", 3, 1e3), range = prop($$props, "range", 3, 1e3), update = prop($$props, "update", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "limit",
      "range",
      "update",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new InstancedMesh(null, null, 0);
  const args = [null, null, 0];
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: mesh,
        raycast: () => null,
        matrixAutoUpdate: false,
        args
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(InstancedMesh_1, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          Api_default(node_1, {
            instancedMesh: mesh,
            get id() {
              return id();
            },
            get limit() {
              return limit();
            },
            get range() {
              return range();
            },
            get update() {
              return update();
            },
            children: wrap_snippet(InstancedMesh_1, ($$anchor3, $$slotProps2) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              snippet(node_2, () => $$props.children ?? noop, () => ({ ref: mesh }));
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          });
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedMesh_1 = hmr(InstancedMesh_1, () => InstancedMesh_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedMesh_1[HMR].source;
    set(InstancedMesh_1[HMR].source, module.default[HMR].original);
  });
}
var InstancedMesh_default = InstancedMesh_1;
mark_module_end(InstancedMesh_1);

// node_modules/@threlte/extras/dist/components/Instancing/PositionMesh.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var PositionMesh = class extends Group {
  constructor(instancedMesh, instances) {
    super();
    __publicField(this, "color");
    __publicField(this, "instancedMesh");
    __publicField(this, "instances");
    this.color = new Color("white");
    this.instancedMesh = instancedMesh;
    this.instances = instances;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _a;
    return (_a = this.instancedMesh.current) == null ? void 0 : _a.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    var _a;
    const parent = this.instancedMesh.current;
    if (parent === void 0)
      return;
    if (parent.geometry === void 0 || parent.material === void 0)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    const instanceId = this.instances.current.indexOf(this);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (isInstanceOf(parent.material, "Material")) {
      _mesh.material.side = parent.material.side;
    } else {
      _mesh.material.side = ((_a = parent.material[0]) == null ? void 0 : _a.side) ?? FrontSide;
    }
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
      const intersect = _instanceIntersects[i];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@threlte/extras/dist/components/Instancing/useInstanceId.js
var key = Symbol("threlte-instance-id");
var createInstanceIdContext = (uuid) => {
  setContext(key, uuid);
};
var useInstanceId = () => {
  return getContext(key) ?? "default";
};

// node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte
mark_module_start();
Instance[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte";
function Instance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Instance);
  validate_prop_bindings($$props, ["ref"], [], Instance);
  let id = prop($$props, "id", 19, useInstanceId), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children"
    ],
    "props"
  );
  const {
    addInstance,
    removeInstance,
    instancedMesh,
    instances
  } = useApi(id());
  const mesh = new PositionMesh(instancedMesh, instances);
  addInstance(mesh);
  onDestroy(() => {
    removeInstance(mesh);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: mesh }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Instance, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Instance = hmr(Instance, () => Instance[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Instance[HMR].source;
    set(Instance[HMR].source, module.default[HMR].original);
  });
}
var Instance_default = Instance;
mark_module_end(Instance);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte
mark_module_start();
InnerInstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte";
function InnerInstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InnerInstancedMeshes);
  validate_prop_bindings($$props, [], [], InnerInstancedMeshes);
  let index = prop($$props, "index", 19, () => $$props.meshes.length - 1), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "meshes",
      "index",
      "children"
    ],
    "props"
  );
  const mesh = $$props.meshes[index()];
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      InstancedMesh_default(node_1, spread_props(
        {
          get geometry() {
            return mesh.geometry;
          },
          get material() {
            return mesh.material;
          },
          get id() {
            return mesh.uuid;
          }
        },
        () => props,
        {
          children: wrap_snippet(InnerInstancedMeshes, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            var index_1 = derived(() => index() - 1);
            InnerInstancedMeshes_default(node_2, spread_props(
              {
                get meshes() {
                  return $$props.meshes;
                },
                get index() {
                  return get(index_1);
                }
              },
              () => props,
              {
                children: wrap_snippet(InnerInstancedMeshes, ($$anchor4, $$slotProps2) => {
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  snippet(node_3, () => $$props.children ?? noop);
                  append($$anchor4, fragment_3);
                }),
                $$slots: { default: true }
              }
            ));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }
      ));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_4 = comment();
      var node_4 = first_child(fragment_4);
      snippet(node_4, () => $$props.children ?? noop);
      append($$anchor2, fragment_4);
    };
    if_block(node, ($$render) => {
      if (index() > -1) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InnerInstancedMeshes = hmr(InnerInstancedMeshes, () => InnerInstancedMeshes[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InnerInstancedMeshes[HMR].source;
    set(InnerInstancedMeshes[HMR].source, module.default[HMR].original);
  });
}
var InnerInstancedMeshes_default = InnerInstancedMeshes;
mark_module_end(InnerInstancedMeshes);

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte
mark_module_start();
InstancedMeshes[FILENAME] = "node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte";
function InstancedMeshes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedMeshes);
  validate_prop_bindings($$props, [], [], InstancedMeshes);
  let props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "meshes",
      "children"
    ],
    "props"
  );
  const getInstance = (id) => {
    return (...args) => {
      createInstanceIdContext(id);
      return Instance_default(...args);
    };
  };
  const getInstanceComponentsArray = (meshes) => {
    return meshes.filter((mesh) => mesh.isMesh).map((mesh) => getInstance(mesh.uuid));
  };
  const getInstanceComponentsObject = (meshes) => {
    return Object.entries(meshes).reduce(
      (acc, [id, mesh]) => {
        if (!mesh.isMesh) return acc;
        acc[id] = getInstance(mesh.uuid);
        return acc;
      },
      {}
    );
  };
  let components = derived(() => Array.isArray($$props.meshes) ? getInstanceComponentsArray($$props.meshes) : getInstanceComponentsObject($$props.meshes));
  let meshesArray = derived(() => Array.isArray($$props.meshes) ? $$props.meshes : Object.values($$props.meshes));
  let filteredMeshesArray = derived(() => get(meshesArray).filter((mesh) => mesh.isMesh));
  var fragment = comment();
  var node = first_child(fragment);
  InnerInstancedMeshes_default(node, spread_props(
    {
      get meshes() {
        return get(filteredMeshesArray);
      }
    },
    () => props,
    {
      children: wrap_snippet(InstancedMeshes, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ components: get(components) }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedMeshes = hmr(InstancedMeshes, () => InstancedMeshes[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedMeshes[HMR].source;
    set(InstancedMeshes[HMR].source, module.default[HMR].original);
  });
}
var InstancedMeshes_default = InstancedMeshes;
mark_module_end(InstancedMeshes);

// node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte
mark_module_start();
SoftShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte";
function SoftShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SoftShadows);
  validate_prop_bindings($$props, [], [], SoftShadows);
  const { renderer, camera, scene } = useThrelte();
  let size = prop($$props, "size", 3, 25), focus = prop($$props, "focus", 3, 0), samples = prop($$props, "samples", 3, 10);
  const original = ShaderChunk.shadowmap_pars_fragment;
  let pcss = derived(() => `
		#define PENUMBRA_FILTER_SIZE float(${size()})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${focus()});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${samples()}; i ++) {
				offset = (vogelDiskSample(j, ${samples()}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${samples()}; i++) {
				vogelSample = vogelDiskSample(j, ${samples()}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${size()}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${samples()}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`);
  const recompile = () => {
    scene.traverse((o) => {
      var _a, _b;
      const object = o;
      if (object.material) {
        renderer == null ? void 0 : renderer.properties.remove(object.material);
        (_b = (_a = object.material).dispose) == null ? void 0 : _b.call(_a);
      }
    });
    if (renderer == null ? void 0 : renderer.info.programs) renderer.info.programs.length = 0;
    renderer == null ? void 0 : renderer.compile(scene, camera.current);
  };
  user_pre_effect(() => {
    ShaderChunk.shadowmap_pars_fragment = original.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
${get(pcss)}`).replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    recompile();
  });
  onDestroy(() => {
    ShaderChunk.shadowmap_pars_fragment = original;
    recompile();
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SoftShadows = hmr(SoftShadows, () => SoftShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SoftShadows[HMR].source;
    set(SoftShadows[HMR].source, module.default[HMR].original);
  });
}
var SoftShadows_default = SoftShadows;
mark_module_end(SoftShadows);

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte
mark_module_start();
MeshLineGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte";
function MeshLineGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineGeometry);
  validate_prop_bindings($$props, ["ref"], [], MeshLineGeometry);
  let points = prop($$props, "points", 19, () => []), shape = prop($$props, "shape", 3, "none"), shapeFunction = prop($$props, "shapeFunction", 7, () => 1), ref = prop($$props, "ref", 15);
  let pointCount = points().length;
  const { invalidate } = useThrelte();
  const positions = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const previous = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const next = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const counters = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const side = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const width = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const uv = new BufferAttribute(new Float32Array(pointCount * 4), 2);
  const indices = new BufferAttribute(new Uint16Array(pointCount * 6), 1);
  if (strict_equals(shape(), "taper")) {
    shapeFunction((p) => 1 * Math.pow(4 * p * (1 - p), 1));
  }
  for (let i = 0, i2 = 0, i3 = 0, i4 = 0; i < pointCount; i += 1, i2 += 2, i3 += 4, i4 += 6) {
    counters.setX(i2, i / points().length);
    counters.setX(i2 + 1, i / points().length);
    side.setX(i2, 1);
    side.setX(i2 + 1, -1);
    const w = strict_equals(shape(), "none") ? 1 : shapeFunction()(i / (pointCount - 1));
    width.setX(i2, w);
    width.setX(i2 + 1, w);
    uv.setXYZW(i2, i / (pointCount - 1), 0, i / (pointCount - 1), 1);
    if (i < pointCount - 1) {
      const n = i * 2;
      indices.setX(i4 + 0, n + 0);
      indices.setX(i4 + 1, n + 1);
      indices.setX(i4 + 2, n + 2);
      indices.setX(i4 + 3, n + 2);
      indices.setX(i4 + 4, n + 1);
      indices.setX(i4 + 5, n + 3);
    }
  }
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("previous", previous);
  geometry.setAttribute("next", next);
  geometry.setAttribute("counters", counters);
  geometry.setAttribute("side", side);
  geometry.setAttribute("width", width);
  geometry.setAttribute("uv", uv);
  geometry.setIndex(indices);
  const setPoints = (points2) => {
    if (strict_equals(points2.length, 0)) return;
    if (strict_equals(points2.length, pointCount, false)) return;
    let positionIndex = 0;
    let previousIndex = 0;
    let nextIndex = 0;
    const p1 = points2[0];
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    for (let i = 0; i < pointCount; i++) {
      const p = points2[i];
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      if (i < pointCount - 1) {
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
      }
      if (i > 0 && i + 1 <= pointCount) {
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
      }
    }
    const p2 = points2[pointCount - 1];
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    positions.needsUpdate = true;
    previous.needsUpdate = true;
    next.needsUpdate = true;
    geometry.computeBoundingSphere();
    invalidate();
  };
  user_pre_effect(() => setPoints(points()));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: geometry }, () => $$props.props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(MeshLineGeometry, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: geometry }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshLineGeometry = hmr(MeshLineGeometry, () => MeshLineGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshLineGeometry[HMR].source;
    set(MeshLineGeometry[HMR].source, module.default[HMR].original);
  });
}
var MeshLineGeometry_default = MeshLineGeometry;
mark_module_end(MeshLineGeometry);

// node_modules/@threlte/extras/dist/components/MeshLine/fragment.js
var fragmentShader3 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

vec4 CustomLinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

void main()	{
	#include <logdepthbuf_fragment>
	#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = CustomLinearTosRGB(c);
}
`;

// node_modules/@threlte/extras/dist/components/MeshLine/vertex.js
var vertexShader3 = `
    #include <common>
    ${ShaderChunk.logdepthbuf_pars_vertex}
    ${ShaderChunk.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${ShaderChunk.logdepthbuf_vertex}
        ${ShaderChunk.fog_vertex}
    }
`;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte
mark_module_start();
MeshLineMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte";
function MeshLineMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshLineMaterial);
  const $$stores = setup_stores();
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  validate_prop_bindings($$props, ["ref"], [], MeshLineMaterial);
  let opacity = prop($$props, "opacity", 3, 1), color2 = prop($$props, "color", 3, "#ffffff"), dashOffset = prop($$props, "dashOffset", 3, 0), dashArray = prop($$props, "dashArray", 3, 0), dashRatio = prop($$props, "dashRatio", 3, 0), attenuate = prop($$props, "attenuate", 3, true), width = prop($$props, "width", 3, 1), scaleDown = prop($$props, "scaleDown", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "opacity",
      "color",
      "dashOffset",
      "dashArray",
      "dashRatio",
      "attenuate",
      "width",
      "scaleDown",
      "alphaMap",
      "ref",
      "children"
    ],
    "props"
  );
  let { invalidate, size } = useThrelte();
  const uniforms = {
    lineWidth: { value: width() },
    color: { value: new Color(color2()) },
    opacity: { value: opacity() },
    resolution: { value: new Vector2(1, 1) },
    sizeAttenuation: { value: attenuate() ? 1 : 0 },
    dashArray: { value: dashArray() },
    dashOffset: { value: dashOffset() },
    dashRatio: { value: dashRatio() },
    useDash: { value: dashArray() > 0 ? 1 : 0 },
    scaleDown: { value: scaleDown() / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: $$props.alphaMap },
    useAlphaMap: { value: $$props.alphaMap ? 1 : 0 }
  };
  const material = new ShaderMaterial({ uniforms });
  user_pre_effect(() => {
    uniforms.resolution.value.set($size().width, $size().height);
    invalidate();
  });
  user_pre_effect(() => {
    uniforms.dashRatio.value = dashRatio();
    uniforms.dashArray.value = dashArray();
    uniforms.dashOffset.value = dashOffset();
    uniforms.lineWidth.value = width();
    uniforms.opacity.value = opacity();
    uniforms.color.value.set(color2());
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: material, fragmentShader: fragmentShader3, vertexShader: vertexShader3 }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(MeshLineMaterial, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshLineMaterial = hmr(MeshLineMaterial, () => MeshLineMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshLineMaterial[HMR].source;
    set(MeshLineMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshLineMaterial_default = MeshLineMaterial;
mark_module_end(MeshLineMaterial);

// node_modules/@threlte/extras/dist/components/Sky/Sky.svelte
mark_module_start();
Sky_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Sky/Sky.svelte";
function Sky_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Sky_1);
  validate_prop_bindings($$props, ["ref"], [], Sky_1);
  let scale = prop($$props, "scale", 3, 1e3), turbidity = prop($$props, "turbidity", 3, 10), rayleigh = prop($$props, "rayleigh", 3, 3), mieCoefficient = prop($$props, "mieCoefficient", 3, 5e-3), mieDirectionalG = prop($$props, "mieDirectionalG", 3, 0.7), elevation = prop($$props, "elevation", 3, 2), azimuth = prop($$props, "azimuth", 3, 180), setEnvironment = prop($$props, "setEnvironment", 3, true), cubeMapSize = prop($$props, "cubeMapSize", 3, 128), webGLRenderTargetOptions = prop($$props, "webGLRenderTargetOptions", 19, () => ({})), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "scale",
      "turbidity",
      "rayleigh",
      "mieCoefficient",
      "mieDirectionalG",
      "elevation",
      "azimuth",
      "setEnvironment",
      "cubeMapSize",
      "webGLRenderTargetOptions",
      "ref",
      "children"
    ],
    "props"
  );
  const sky = new Sky();
  const sunPosition = new Vector3();
  const { uniforms } = sky.material;
  const { renderer, scene, invalidate } = useThrelte();
  let renderTarget = state(void 0);
  let cubeCamera;
  const init2 = () => {
    set(renderTarget, proxy(
      new WebGLCubeRenderTarget(cubeMapSize(), {
        type: HalfFloatType,
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter,
        ...webGLRenderTargetOptions()
      }),
      null,
      renderTarget
    ));
    cubeCamera = new CubeCamera(1, 1.1, get(renderTarget));
  };
  const originalEnvironment = scene.environment;
  user_pre_effect(() => {
    if (setEnvironment() && get(renderTarget)) {
      scene.environment = get(renderTarget).texture;
      invalidate();
    } else if (!setEnvironment()) {
      scene.environment = originalEnvironment;
      invalidate();
    }
  });
  const { start: scheduleUpdate, stop } = useTask(
    () => {
      sky.scale.setScalar(scale());
      uniforms.turbidity.value = turbidity();
      uniforms.rayleigh.value = rayleigh();
      uniforms.mieCoefficient.value = mieCoefficient();
      uniforms.mieDirectionalG.value = mieDirectionalG();
      const phi = MathUtils.degToRad(90 - elevation());
      const theta = MathUtils.degToRad(azimuth());
      sunPosition.setFromSphericalCoords(1, phi, theta);
      uniforms.sunPosition.value.copy(sunPosition);
      if (setEnvironment()) {
        if (!get(renderTarget) || !cubeCamera) init2();
        cubeCamera == null ? void 0 : cubeCamera.update(renderer, sky);
      }
      invalidate();
      stop();
    },
    { autoStart: false, autoInvalidate: false }
  );
  user_pre_effect(() => {
    scale();
    turbidity();
    rayleigh();
    mieCoefficient();
    mieDirectionalG();
    elevation();
    azimuth();
    scheduleUpdate();
  });
  onDestroy(() => {
    var _a;
    sky.material.dispose();
    scene.environment = originalEnvironment;
    try {
      (_a = get(renderTarget)) == null ? void 0 : _a.dispose();
    } catch (error) {
      console.warn(...log_if_contains_state("warn", "Could not dispose renderTarget:", error));
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: sky }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Sky_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({
          ref: sky,
          sunPosition,
          renderTarget: get(renderTarget)
        }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Sky_1 = hmr(Sky_1, () => Sky_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Sky_1[HMR].source;
    set(Sky_1[HMR].source, module.default[HMR].original);
  });
}
var Sky_default = Sky_1;
mark_module_end(Sky_1);

// node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte
mark_module_start();
InjectPlugin[FILENAME] = "node_modules/@threlte/extras/dist/components/InjectPlugin/InjectPlugin.svelte";
function InjectPlugin($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InjectPlugin);
  validate_prop_bindings($$props, [], [], InjectPlugin);
  injectPlugin($$props.name, $$props.plugin);
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InjectPlugin = hmr(InjectPlugin, () => InjectPlugin[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InjectPlugin[HMR].source;
    set(InjectPlugin[HMR].source, module.default[HMR].original);
  });
}
var InjectPlugin_default = InjectPlugin;
mark_module_end(InjectPlugin);

// node_modules/@threlte/extras/dist/components/Align/Align.svelte
mark_module_start();
Align[FILENAME] = "node_modules/@threlte/extras/dist/components/Align/Align.svelte";
function Align($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Align);
  validate_prop_bindings($$props, ["ref"], ["align"], Align);
  const { renderStage } = useThrelte();
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), z = prop($$props, "z", 3, 0), precise = prop($$props, "precise", 3, false), auto = prop($$props, "auto", 3, false), ref = prop($$props, "ref", 15), stage = prop($$props, "stage", 19, () => useStage("<Align>", { before: renderStage })), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "z",
      "precise",
      "auto",
      "ref",
      "onalign",
      "children",
      "stage"
    ],
    "props"
  );
  const group = new Group();
  const innerGroup = new Group();
  const outerGroup = new Group();
  const calculate = () => {
    var _a;
    if (strict_equals(x(), false) && strict_equals(y(), false) && strict_equals(z(), false)) return;
    outerGroup.matrixWorld.identity();
    const box3 = new Box3().setFromObject(innerGroup, precise());
    const align2 = new Vector3();
    const sphere2 = new Sphere();
    const width = box3.max.x - box3.min.x;
    const height = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    box3.getCenter(align2);
    box3.getBoundingSphere(sphere2);
    const vAlign = (y() || 0) * height / 2;
    const hAlign = (x() || 0) * width / 2;
    const dAlign = (z() || 0) * depth / 2;
    outerGroup.position.set(strict_equals(x(), false) ? 0 : -align2.x + hAlign, strict_equals(y(), false) ? 0 : -align2.y + vAlign, strict_equals(z(), false) ? 0 : -align2.z + dAlign);
    (_a = $$props.onalign) == null ? void 0 : _a.call($$props, {
      boundingBox: box3,
      center: outerGroup.position.clone(),
      boundingSphere: sphere2,
      container: group,
      depth,
      depthAlignment: dAlign,
      height,
      verticalAlignment: vAlign,
      width,
      horizontalAlignment: hAlign
    });
  };
  const { start: scheduleAligning, stop } = useTask(
    () => {
      calculate();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const align = scheduleAligning;
  observe(() => [x(), y(), z(), precise()], scheduleAligning);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleAligning();
      return () => {
        if (auto()) scheduleAligning();
      };
    });
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Align, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: outerGroup,
          children: wrap_snippet(Align, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: innerGroup,
              children: wrap_snippet(Align, ($$anchor4, $$slotProps3) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                InjectPlugin_default(node_3, {
                  name: "align",
                  plugin,
                  children: wrap_snippet(Align, ($$anchor5, $$slotProps4) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    snippet(node_4, () => $$props.children ?? noop, () => ({ align: scheduleAligning, ref: group }));
                    append($$anchor5, fragment_4);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get align() {
      return align;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Align = hmr(Align, () => Align[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Align[HMR].source;
    set(Align[HMR].source, module.default[HMR].original);
  });
}
var Align_default = Align;
mark_module_end(Align);

// node_modules/@threlte/extras/dist/components/CSM/useMaterials.js
var useMaterials = () => {
  let setupCallback = void 0;
  const allMaterials = /* @__PURE__ */ new Set();
  const isSupportedMaterial = (material) => {
    return isInstanceOf(material, "MeshStandardMaterial") || isInstanceOf(material, "MeshPhongMaterial");
  };
  const addMaterial = (material) => {
    if (allMaterials.has(material))
      return;
    allMaterials.add(material);
    setupCallback == null ? void 0 : setupCallback(material);
  };
  const extractMaterials = (ref) => {
    if (isSupportedMaterial(ref)) {
      addMaterial(ref);
    } else if (isInstanceOf(ref, "Mesh")) {
      if (Array.isArray(ref.material)) {
        ref.material.forEach((material) => {
          if (isSupportedMaterial(material)) {
            addMaterial(material);
          }
        });
      } else {
        if (isSupportedMaterial(ref.material)) {
          addMaterial(ref.material);
        }
      }
    }
  };
  const onNewMaterial = (callback) => {
    setupCallback = callback;
  };
  injectPlugin("csm", (args) => {
    onMount(() => {
      extractMaterials(args.ref);
    });
  });
  onDestroy(() => setupCallback = void 0);
  return { onNewMaterial, allMaterials };
};

// node_modules/@threlte/extras/dist/components/CSM/CSM.svelte
mark_module_start();
CSM_1[FILENAME] = "node_modules/@threlte/extras/dist/components/CSM/CSM.svelte";
var root4 = add_locations(template(`<!> <!>`, 1), CSM_1[FILENAME], []);
function CSM_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, CSM_1);
  const $$stores = setup_stores();
  const $csmStore = () => (validate_store(csmStore, "csmStore"), store_get(csmStore, "$csmStore", $$stores));
  const $defaultCamera = () => (validate_store(defaultCamera, "defaultCamera"), store_get(defaultCamera, "$defaultCamera", $$stores));
  let enabled = prop($$props, "enabled", 8, true);
  let args = prop($$props, "args", 24, () => ({}));
  let camera = prop($$props, "camera", 8, void 0);
  let configure = prop($$props, "configure", 8, void 0);
  let lightIntensity = prop($$props, "lightIntensity", 8, void 0);
  let lightColor = prop($$props, "lightColor", 8, void 0);
  let lightDirection = prop($$props, "lightDirection", 24, () => [1, -1, 1]);
  const enabledStore = writable(enabled());
  const { camera: defaultCamera, scene, size } = useThrelte();
  const csmStore = currentWritable(void 0);
  useTask(() => {
    var _a;
    return (_a = $csmStore()) == null ? void 0 : _a.update();
  }, { autoInvalidate: false });
  const { onNewMaterial, allMaterials } = useMaterials();
  const disposeCsm = () => {
    var _a, _b;
    (_a = $csmStore()) == null ? void 0 : _a.remove();
    (_b = $csmStore()) == null ? void 0 : _b.dispose();
    store_set(csmStore, void 0);
  };
  watch([size, csmStore], ([_, csm]) => {
    if (!csm) return;
    csm.updateFrustums();
  });
  const cameraStore = writable(camera());
  watch([defaultCamera, cameraStore, csmStore], ([defaultCamera2, camera2, csm]) => {
    if (!csm) return;
    csm.camera = camera2 ?? defaultCamera2;
    if (strict_equals(args().maxFar, void 0, false)) csm.maxFar = args().maxFar;
    if (strict_equals(args().mode, void 0, false)) csm.mode = args().mode;
    csm.updateFrustums();
  });
  watch(enabledStore, (enabled2) => {
    var _a;
    if (enabled2) {
      const csm = new CSM({
        camera: camera() ?? $defaultCamera(),
        parent: scene,
        ...args()
      });
      (_a = configure()) == null ? void 0 : _a(csm);
      for (const material of allMaterials) {
        csm.setupMaterial(material);
      }
      onNewMaterial((material) => csm.setupMaterial(material));
      csmStore.set(csm);
    } else {
      onNewMaterial(void 0);
      disposeCsm();
    }
  });
  const lightIntensityStore = writable(lightIntensity());
  const lightColorStore = writable(lightColor());
  watch(
    [
      csmStore,
      lightIntensityStore,
      lightColorStore
    ],
    ([csm, intensity, color2]) => {
      csm == null ? void 0 : csm.lights.forEach((light) => {
        if (strict_equals(intensity, void 0, false)) {
          light.intensity = intensity / Math.PI;
        }
        if (strict_equals(color2, void 0, false)) {
          light.color.set(color2);
        }
      });
    }
  );
  const lightDirectionStore = writable(lightDirection());
  watch([csmStore, lightDirectionStore], ([csm, direction]) => {
    csm == null ? void 0 : csm.lightDirection.set(...direction).normalize();
  });
  onDestroy(disposeCsm);
  legacy_pre_effect(() => deep_read_state(enabled()), () => {
    enabledStore.set(enabled());
  });
  legacy_pre_effect(() => deep_read_state(camera()), () => {
    cameraStore.set(camera());
  });
  legacy_pre_effect(() => deep_read_state(lightIntensity()), () => {
    lightIntensityStore.set(lightIntensity());
  });
  legacy_pre_effect(() => deep_read_state(lightColor()), () => {
    lightColorStore.set(lightColor());
  });
  legacy_pre_effect(() => deep_read_state(lightDirection()), () => {
    lightDirectionStore.set(lightDirection());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root4();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      slot(node_2, $$props, "disabled", {}, null);
      append($$anchor2, fragment_1);
    };
    if_block(node_1, ($$render) => {
      if (!enabled()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CSM_1 = hmr(CSM_1, () => CSM_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CSM_1[HMR].source;
    set(CSM_1[HMR].source, module.default[HMR].original);
  });
}
var CSM_default = CSM_1;
mark_module_end(CSM_1);

// node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte
mark_module_start();
Billboard[FILENAME] = "node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte";
function Billboard($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Billboard);
  const $$stores = setup_stores();
  const $camera = () => (validate_store(camera, "camera"), store_get(camera, "$camera", $$stores));
  validate_prop_bindings($$props, ["ref"], [], Billboard);
  let follow = prop($$props, "follow", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "follow",
      "ref",
      "children"
    ],
    "props"
  );
  const inner = new Group();
  const localRef = new Group();
  const { camera, renderStage } = useThrelte();
  const q = new Quaternion();
  let followObject = derived(() => strict_equals(follow(), true) ? $camera() : strict_equals(follow(), false) ? void 0 : follow());
  const stage = useStage("<Billboard>", { before: renderStage });
  const { start, stop } = useTask(
    () => {
      var _a;
      localRef.updateMatrix();
      localRef.updateWorldMatrix(false, false);
      localRef.getWorldQuaternion(q);
      (_a = get(followObject)) == null ? void 0 : _a.getWorldQuaternion(inner.quaternion).premultiply(q.invert());
    },
    { autoStart: false, stage }
  );
  user_pre_effect(() => {
    if (follow()) {
      start();
    } else {
      stop();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: localRef }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Billboard, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: inner,
          children: wrap_snippet(Billboard, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.children ?? noop, () => ({ ref: localRef }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Billboard = hmr(Billboard, () => Billboard[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Billboard[HMR].source;
    set(Billboard[HMR].source, module.default[HMR].original);
  });
}
var Billboard_default = Billboard;
mark_module_end(Billboard);

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/fragment.js
var fragmentShader4 = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/vertex.js
var vertexShader4 = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte
mark_module_start();
FakeGlowMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte";
function FakeGlowMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, FakeGlowMaterial);
  validate_prop_bindings($$props, ["ref"], [], FakeGlowMaterial);
  let falloff = prop($$props, "falloff", 3, 0.1), glowInternalRadius = prop($$props, "glowInternalRadius", 3, 6), glowColor = prop($$props, "glowColor", 3, "green"), glowSharpness = prop($$props, "glowSharpness", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "falloff",
      "glowInternalRadius",
      "glowColor",
      "glowSharpness",
      "ref",
      "children"
    ],
    "props"
  );
  const uniforms = {
    falloff: { value: falloff() },
    glowInternalRadius: { value: glowInternalRadius() },
    glowColor: { value: new Color(glowColor()) },
    glowSharpness: { value: glowSharpness() }
  };
  const material = new ShaderMaterial({
    uniforms,
    fragmentShader: fragmentShader4,
    vertexShader: vertexShader4,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false
  });
  const { invalidate } = useThrelte();
  user_pre_effect(() => {
    material.uniforms.falloff.value = falloff();
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowInternalRadius.value = glowInternalRadius();
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowColor.value.set(glowColor());
    invalidate();
  });
  user_pre_effect(() => {
    material.uniforms.glowSharpness.value = glowSharpness();
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: material }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(FakeGlowMaterial, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: material }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FakeGlowMaterial = hmr(FakeGlowMaterial, () => FakeGlowMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FakeGlowMaterial[HMR].source;
    set(FakeGlowMaterial[HMR].source, module.default[HMR].original);
  });
}
var FakeGlowMaterial_default = FakeGlowMaterial;
mark_module_end(FakeGlowMaterial);

// node_modules/@threlte/extras/dist/components/Stars/fragment.js
var fragmentShader5 = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/Stars/vertex.js
var vertexShader5 = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;

// node_modules/@threlte/extras/dist/components/Stars/Stars.svelte
mark_module_start();
Stars[FILENAME] = "node_modules/@threlte/extras/dist/components/Stars/Stars.svelte";
var root_14 = add_locations(template(`<!> <!> <!>`, 1), Stars[FILENAME], []);
function Stars($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Stars);
  validate_prop_bindings($$props, ["ref"], [], Stars);
  let count = prop($$props, "count", 3, 5e3), radius = prop($$props, "radius", 3, 50), depth = prop($$props, "depth", 3, 50), factor = prop($$props, "factor", 3, 6), saturation = prop($$props, "saturation", 3, 1), lightness = prop($$props, "lightness", 3, 0.8), speed = prop($$props, "speed", 3, 1), fade = prop($$props, "fade", 3, true), opacity = prop($$props, "opacity", 3, 1), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "count",
      "radius",
      "depth",
      "factor",
      "saturation",
      "lightness",
      "speed",
      "fade",
      "opacity",
      "ref",
      "children"
    ],
    "props"
  );
  const points = new Points();
  const vec3 = new Vector3();
  const spherical = new Spherical();
  const color2 = new Color();
  const generateStar = (r) => {
    return vec3.setFromSpherical(spherical.set(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  };
  let positions = new BufferAttribute(new Float32Array(count() * 3), 3);
  let colors = new BufferAttribute(new Float32Array(count() * 3), 3);
  let sizes = new BufferAttribute(new Float32Array(count()), 1);
  user_pre_effect(() => {
    positions = new BufferAttribute(new Float32Array(count() * 3), 3);
    colors = new BufferAttribute(new Float32Array(count() * 3), 3);
    sizes = new BufferAttribute(new Float32Array(count()), 1);
  });
  user_pre_effect(() => {
    const increment = depth() / count();
    let r = radius() + depth();
    for (let i = 0; i < count(); i += 1) {
      r -= increment * Math.random();
      const position2 = generateStar(r);
      positions.setXYZ(i, position2.x, position2.y, position2.z);
      color2.setHSL(i / count(), saturation(), lightness());
      colors.setXYZ(i, color2.r, color2.g, color2.b);
      sizes.setX(i, (0.5 + 0.5 * Math.random()) * factor());
    }
  });
  const { stop, start } = useTask(
    (dt) => {
      uniforms.time.value += dt * speed();
    },
    { autoStart: false }
  );
  user_pre_effect(() => strict_equals(speed(), 0) ? stop() : start());
  const uniforms = {
    time: { value: 0 },
    fade: { value: 1 },
    opacity: { value: 1 }
  };
  const material = new ShaderMaterial({ uniforms, vertexShader: vertexShader5, fragmentShader: fragmentShader5 });
  user_pre_effect(() => {
    uniforms.fade.value = fade() ? 1 : 0;
  });
  user_pre_effect(() => {
    uniforms.opacity.value = opacity();
  });
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("color", colors);
  geometry.setAttribute("size", sizes);
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: points }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Stars, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_14();
        var node_1 = first_child(fragment_1);
        T(node_1, { is: geometry });
        var node_2 = sibling(node_1, 2);
        T(node_2, {
          is: material,
          blending: AdditiveBlending,
          depthWrite: false,
          transparent: true,
          vertexColors: true
        });
        var node_3 = sibling(node_2, 2);
        snippet(node_3, () => $$props.children ?? noop, () => ({ ref: points }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Stars = hmr(Stars, () => Stars[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Stars[HMR].source;
    set(Stars[HMR].source, module.default[HMR].original);
  });
}
var Stars_default = Stars;
mark_module_end(Stars);

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/fragment.js
var fragmentShader6 = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${shaderStructs}
${shaderIntersectFunction}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/vertex.js
var vertexShader6 = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte
mark_module_start();
MeshRefractionMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte";
function MeshRefractionMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshRefractionMaterial);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  const $size = () => (validate_store(size, "size"), store_get(size, "$size", $$stores));
  validate_prop_bindings($$props, ["ref"], [], MeshRefractionMaterial);
  let bounces = prop($$props, "bounces", 3, 2), ior = prop($$props, "ior", 3, 2.4), fresnel = prop($$props, "fresnel", 3, 0), aberrationStrength = prop($$props, "aberrationStrength", 3, 0), color2 = prop($$props, "color", 3, "white"), fastChroma = prop($$props, "fastChroma", 3, true), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "envMap",
      "bounces",
      "ior",
      "fresnel",
      "aberrationStrength",
      "color",
      "fastChroma",
      "ref"
    ],
    "props"
  );
  const uniforms = {
    envMap: { value: null },
    bounces: { value: 2 },
    ior: { value: 2.4 },
    correctMips: { value: true },
    aberrationStrength: { value: 0.01 },
    fresnel: { value: 0 },
    bvh: { value: new MeshBVHUniformStruct() },
    color: { value: new Color("white") },
    resolution: { value: new Vector2() },
    viewMatrixInverse: { value: new Matrix4() },
    projectionMatrixInverse: { value: new Matrix4() }
  };
  const material = new ShaderMaterial({ fragmentShader: fragmentShader6, vertexShader: vertexShader6, uniforms });
  const { size, invalidate, camera } = useThrelte();
  const parent = useParent();
  let defines = {};
  const updateDefines = (envMap, aberrationStrength2, fastChroma2) => {
    var _a;
    const isCubeMap = isInstanceOf(envMap, "CubeTexture");
    const w = (isCubeMap ? (_a = envMap.image[0]) == null ? void 0 : _a.width : envMap == null ? void 0 : envMap.image.width) ?? 1024;
    const cubeSize = w / 4;
    const lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, lodMax);
    const width = 3 * Math.max(_cubeSize, 16 * 7);
    const height = 4 * _cubeSize;
    if (isCubeMap) defines.ENVMAP_TYPE_CUBEM = "";
    defines.CUBEUV_TEXEL_WIDTH = `${1 / width}`;
    defines.CUBEUV_TEXEL_HEIGHT = `${1 / height}`;
    defines.CUBEUV_MAX_MIP = `${lodMax}.0`;
    if (aberrationStrength2 > 0) defines.CHROMATIC_ABERRATIONS = "";
    if (fastChroma2) defines.FAST_CHROMA = "";
  };
  user_pre_effect(() => {
    updateDefines($$props.envMap, aberrationStrength(), fastChroma());
  });
  onMount(() => {
    var _a;
    if ($parent() && $parent() instanceof Mesh && $parent().geometry) {
      uniforms.bvh.value = new MeshBVHUniformStruct();
      uniforms.bvh.value.updateFrom(new MeshBVH((_a = $parent()) == null ? void 0 : _a.geometry.clone().toNonIndexed(), { strategy: SAH }));
    }
  });
  useTask(
    () => {
      uniforms.viewMatrixInverse.value = camera.current.matrixWorld;
      uniforms.projectionMatrixInverse.value = camera.current.projectionMatrixInverse;
    },
    { autoInvalidate: false }
  );
  const colorObj = new Color(color2());
  user_pre_effect(() => {
    colorObj.set(color2());
    invalidate();
  });
  var fragment = comment();
  var node = first_child(fragment);
  var uniforms_resolution_value = derived(() => [$size().width, $size().height]);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: material,
        get "uniforms.envMap.value"() {
          return $$props.envMap;
        },
        get "uniforms.bounces.value"() {
          return bounces();
        },
        get "uniforms.ior.value"() {
          return ior();
        },
        get "uniforms.fresnel.value"() {
          return fresnel();
        },
        get "uniforms.aberrationStrength.value"() {
          return aberrationStrength();
        },
        "uniforms.color.value": colorObj,
        get "uniforms.resolution.value"() {
          return get(uniforms_resolution_value);
        },
        defines
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshRefractionMaterial = hmr(MeshRefractionMaterial, () => MeshRefractionMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshRefractionMaterial[HMR].source;
    set(MeshRefractionMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshRefractionMaterial_default = MeshRefractionMaterial;
mark_module_end(MeshRefractionMaterial);

// node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte
mark_module_start();
Text3DGeometry[FILENAME] = "node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte";
function Text3DGeometry($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text3DGeometry);
  const $$stores = setup_stores();
  const $loadedFont = () => (validate_store(get(loadedFont), "loadedFont"), store_get(get(loadedFont), "$loadedFont", $$stores));
  validate_prop_bindings($$props, ["ref"], [], Text3DGeometry);
  let font = prop($$props, "font", 3, "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "text",
      "font",
      "size",
      "depth",
      "curveSegments",
      "bevelEnabled",
      "bevelThickness",
      "bevelSize",
      "bevelOffset",
      "bevelSegments",
      "smooth",
      "extrudePath",
      "steps",
      "UVGenerator",
      "ref",
      "children"
    ],
    "props"
  );
  const suspend = useSuspense();
  let loadedFont = derived(() => suspend(strict_equals(typeof font(), "string") ? useLoader(FontLoader).load(font()) : asyncWritable(new Promise((resolve) => resolve(font())))));
  let baseGeometry = derived(() => {
    if (!$loadedFont()) return;
    return new TextGeometry($$props.text, {
      font: $loadedFont(),
      size: $$props.size,
      depth: $$props.depth,
      curveSegments: $$props.curveSegments,
      bevelEnabled: $$props.bevelEnabled,
      bevelThickness: $$props.bevelThickness,
      bevelSize: $$props.bevelSize,
      bevelOffset: $$props.bevelOffset,
      bevelSegments: $$props.bevelSegments,
      extrudePath: $$props.extrudePath,
      steps: $$props.steps,
      UVGenerator: $$props.UVGenerator
    });
  });
  let creasedGeometry = derived(() => {
    if (!get(baseGeometry)) return;
    if (strict_equals($$props.smooth, 0)) return get(baseGeometry);
    return toCreasedNormals(get(baseGeometry), $$props.smooth);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, T);
        T(node_1, spread_props(
          {
            get is() {
              return get(creasedGeometry);
            }
          },
          () => props,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            },
            children: wrap_snippet(Text3DGeometry, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              snippet(node_2, () => $$props.children ?? noop, () => ({ ref: get(creasedGeometry) }));
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }
        ));
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (get(creasedGeometry)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text3DGeometry = hmr(Text3DGeometry, () => Text3DGeometry[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text3DGeometry[HMR].source;
    set(Text3DGeometry[HMR].source, module.default[HMR].original);
  });
}
var Text3DGeometry_default = Text3DGeometry;
mark_module_end(Text3DGeometry);

// node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte
mark_module_start();
PerfMonitor[FILENAME] = "node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte";
function PerfMonitor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PerfMonitor);
  validate_prop_bindings($$props, [], [], PerfMonitor);
  let domElement = prop($$props, "domElement", 19, () => document.body), logsPerSecond = prop($$props, "logsPerSecond", 3, 10), showGraph = prop($$props, "showGraph", 3, true), memory = prop($$props, "memory", 3, true), enabled = prop($$props, "enabled", 3, true), visible = prop($$props, "visible", 3, true), actionToCallUI = prop($$props, "actionToCallUI", 3, ""), guiVisible = prop($$props, "guiVisible", 3, false), backgroundOpacity = prop($$props, "backgroundOpacity", 3, 0.7), scale = prop($$props, "scale", 3, 1), anchorX = prop($$props, "anchorX", 3, "left"), anchorY = prop($$props, "anchorY", 3, "top");
  const { renderer, renderStage, mainStage } = useThrelte();
  let perf;
  user_pre_effect(() => {
    domElement();
    perf == null ? void 0 : perf.dispose();
    perf = new ThreePerf({ domElement: domElement(), renderer });
  });
  user_pre_effect(() => {
    perf.logsPerSecond = logsPerSecond();
    perf.showGraph = showGraph();
    perf.memory = memory();
    perf.enabled = enabled();
    perf.visible = visible();
    perf.actionToCallUI = actionToCallUI();
    perf.guiVisible = guiVisible();
    perf.backgroundOpacity = backgroundOpacity();
    perf.scale = scale();
    perf.anchorX = anchorX();
    perf.anchorY = anchorY();
  });
  useTask(
    () => {
      perf.begin();
    },
    {
      stage: useStage("monitor-begin", { before: mainStage })
    }
  );
  useTask(
    () => {
      perf.end();
    },
    {
      stage: useStage("monitor-end", { after: renderStage })
    }
  );
  onDestroy(() => {
    if (perf) perf.dispose();
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PerfMonitor = hmr(PerfMonitor, () => PerfMonitor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PerfMonitor[HMR].source;
    set(PerfMonitor[HMR].source, module.default[HMR].original);
  });
}
var PerfMonitor_default = PerfMonitor;
mark_module_end(PerfMonitor);

// node_modules/@threlte/extras/dist/components/Outlines/shaders.js
var vertexShader7 = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`;
var fragmentShader7 = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
}
`;

// node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte
mark_module_start();
Outlines[FILENAME] = "node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte";
var root_23 = add_locations(template(`<!> <!>`, 1), Outlines[FILENAME], []);
var root_15 = add_locations(template(`<!> <!>`, 1), Outlines[FILENAME], []);
function Outlines($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Outlines);
  validate_prop_bindings($$props, ["ref"], [], Outlines);
  let color2 = prop($$props, "color", 3, "black"), screenspace = prop($$props, "screenspace", 3, false), opacity = prop($$props, "opacity", 3, 1), transparent = prop($$props, "transparent", 3, false), thickness = prop($$props, "thickness", 3, 0.05), toneMapped = prop($$props, "toneMapped", 3, true), angle = prop($$props, "angle", 19, () => Math.PI), polygonOffset = prop($$props, "polygonOffset", 3, false), polygonOffsetFactor = prop($$props, "polygonOffsetFactor", 3, 0), renderOrder = prop($$props, "renderOrder", 3, 0), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "color",
      "screenspace",
      "opacity",
      "transparent",
      "thickness",
      "toneMapped",
      "angle",
      "polygonOffset",
      "polygonOffsetFactor",
      "renderOrder",
      "children",
      "ref"
    ],
    "props"
  );
  const { renderer } = useThrelte();
  const uniforms = {
    screenspace: { value: screenspace() },
    color: { value: new Color(color2()) },
    opacity: { value: opacity() },
    thickness: { value: thickness() },
    size: { value: new Vector2() }
  };
  const group = new Group();
  const material = new ShaderMaterial({
    side: BackSide,
    uniforms,
    vertexShader: vertexShader7,
    fragmentShader: fragmentShader7
  });
  const parent = useParent();
  let parentMesh = fromStore(parent);
  let geometry = derived(() => {
    if (!isInstanceOf(parentMesh.current, "Mesh")) return void 0;
    return toCreasedNormals(parentMesh.current.geometry, angle());
  });
  let mesh = derived(() => {
    if (!isInstanceOf(parentMesh.current, "Mesh")) return;
    if (isInstanceOf(parentMesh.current, "SkinnedMesh")) {
      const nextMesh = new SkinnedMesh();
      nextMesh.bind(parentMesh.current.skeleton, parentMesh.current.bindMatrix);
      return nextMesh;
    } else if (isInstanceOf(parentMesh.current, "InstancedMesh")) {
      const nextMesh = new InstancedMesh(void 0, void 0, parentMesh.current.count);
      nextMesh.instanceMatrix = parentMesh.current.instanceMatrix;
      return nextMesh;
    }
    return new Mesh();
  });
  user_pre_effect(() => {
    if (get(mesh)) get(mesh).renderOrder = renderOrder();
  });
  user_pre_effect(() => {
    material.transparent = transparent();
  });
  user_pre_effect(() => {
    material.toneMapped = toneMapped();
  });
  user_pre_effect(() => {
    material.polygonOffset = polygonOffset();
  });
  user_pre_effect(() => {
    material.polygonOffsetFactor = polygonOffsetFactor();
  });
  user_pre_effect(() => {
    material.uniforms.screenspace.value = screenspace();
  });
  user_pre_effect(() => {
    material.uniforms.color.value.set(color2());
  });
  user_pre_effect(() => {
    material.uniforms.opacity.value = opacity();
  });
  user_pre_effect(() => {
    material.uniforms.thickness.value = thickness();
  });
  user_pre_effect(() => {
    renderer.getDrawingBufferSize(material.uniforms.size.value);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: group }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Outlines, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_15();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          get is() {
            return get(mesh);
          },
          children: wrap_snippet(Outlines, ($$anchor3, $$slotProps2) => {
            var fragment_2 = root_23();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              get is() {
                return get(geometry);
              }
            });
            var node_3 = sibling(node_2, 2);
            T(node_3, { is: material });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        var node_4 = sibling(node_1, 2);
        snippet(node_4, () => $$props.children ?? noop, () => ({ ref: group }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Outlines = hmr(Outlines, () => Outlines[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Outlines[HMR].source;
    set(Outlines[HMR].source, module.default[HMR].original);
  });
}
var Outlines_default = Outlines;
mark_module_end(Outlines);

// node_modules/@threlte/extras/dist/components/Mask/Mask.svelte
mark_module_start();
Mask[FILENAME] = "node_modules/@threlte/extras/dist/components/Mask/Mask.svelte";
function Mask($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mask);
  validate_prop_bindings($$props, ["ref"], [], Mask);
  let id = prop($$props, "id", 3, 1), colorWrite = prop($$props, "colorWrite", 3, false), depthWrite = prop($$props, "depthWrite", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "colorWrite",
      "depthWrite",
      "ref",
      "children"
    ],
    "props"
  );
  const mesh = new Mesh();
  user_effect(() => {
    const { material } = mesh;
    if (Array.isArray(material)) return;
    material.colorWrite = colorWrite();
    material.depthWrite = depthWrite();
    material.stencilWrite = true;
    material.stencilRef = id();
    material.stencilFunc = AlwaysStencilFunc;
    material.stencilFail = ReplaceStencilOp;
    material.stencilZFail = ReplaceStencilOp;
    material.stencilZPass = ReplaceStencilOp;
  });
  var fragment = comment();
  var node = first_child(fragment);
  var renderOrder = derived(() => -id());
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: mesh,
        get renderOrder() {
          return get(renderOrder);
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(Mask, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: mesh }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mask = hmr(Mask, () => Mask[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mask[HMR].source;
    set(Mask[HMR].source, module.default[HMR].original);
  });
}
var Mask_default = Mask;
mark_module_end(Mask);

// node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte
mark_module_start();
BakeShadows[FILENAME] = "node_modules/@threlte/extras/dist/components/BakeShadows/BakeShadows.svelte";
function BakeShadows($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BakeShadows);
  validate_prop_bindings($$props, [], [], BakeShadows);
  const suspended = fromStore(useSuspense().suspended);
  const { renderer } = useThrelte();
  user_effect(() => {
    if (!suspended.current) {
      renderer.shadowMap.autoUpdate = false;
      renderer.shadowMap.needsUpdate = true;
    }
    return () => {
      renderer.shadowMap.autoUpdate = true;
      renderer.shadowMap.needsUpdate = true;
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BakeShadows = hmr(BakeShadows, () => BakeShadows[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BakeShadows[HMR].source;
    set(BakeShadows[HMR].source, module.default[HMR].original);
  });
}
var BakeShadows_default = BakeShadows;
mark_module_end(BakeShadows);

// node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte
mark_module_start();
Detailed[FILENAME] = "node_modules/@threlte/extras/dist/components/Detailed/Detailed.svelte";
function Detailed($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Detailed);
  validate_prop_bindings($$props, ["ref"], [], Detailed);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "children"
    ],
    "props"
  );
  const lod = new LOD();
  injectPlugin("detailed", (args) => {
    const parent = useParent();
    if (strict_equals(parent.current, lod, false)) return;
    let previousRef;
    let previousDistance = args.props.distance;
    let previousHysteresis = args.props.hysteresis;
    const ref2 = derived(() => isInstanceOf(args.ref, "Object3D") ? args.ref : void 0);
    const distance = derived(() => args.props.distance ?? 0);
    const hysteresis = derived(() => args.props.hysteresis ?? 0);
    const addLevel = (ref3, distance2, hysteresis2) => {
      lod.addLevel(ref3, distance2, hysteresis2);
    };
    const removeLevel = (ref3) => {
      const i = lod.levels.findIndex((l) => strict_equals(l.object, ref3));
      if (i > -1) {
        lod.levels.splice(i, 1);
      }
    };
    const mutateLevel = (ref3, distance2, hysteresis2) => {
      untrack(() => {
        const level = lod.levels.find((l) => strict_equals(l.object, ref3));
        if (!level) return;
        level.distance = distance2;
        level.hysteresis = hysteresis2;
      });
    };
    observe.pre(
      () => [
        get(ref2),
        get(distance),
        get(hysteresis)
      ],
      ([ref3, distance2, hysteresis2]) => {
        if (strict_equals(ref3, previousRef, false)) {
          if (previousRef) removeLevel(previousRef);
          if (ref3) addLevel(ref3, distance2, hysteresis2);
          previousRef = ref3;
        }
        if (ref3 && (strict_equals(distance2, previousDistance, false) || strict_equals(hysteresis2, previousHysteresis, false))) {
          mutateLevel(ref3, distance2, hysteresis2);
          previousDistance = distance2;
          previousHysteresis = hysteresis2;
        }
      }
    );
    onDestroy(() => {
      if (get(ref2)) removeLevel(get(ref2));
    });
    return { pluginProps: ["distance", "hysteresis"] };
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: lod }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Detailed, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: lod }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Detailed = hmr(Detailed, () => Detailed[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Detailed[HMR].source;
    set(Detailed[HMR].source, module.default[HMR].original);
  });
}
var Detailed_default = Detailed;
mark_module_end(Detailed);

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/fragment.js
var fragmentShader8 = `void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	discard;
}
`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/vertex.js
var vertexShader8 = `void main() {}`;

// node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte
mark_module_start();
MeshDiscardMaterial[FILENAME] = "node_modules/@threlte/extras/dist/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte";
function MeshDiscardMaterial($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MeshDiscardMaterial);
  validate_prop_bindings($$props, ["ref"], [], MeshDiscardMaterial);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "ref"
    ],
    "props"
  );
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => T.ShaderMaterial, ($$anchor2, $$component) => {
    {
      add_owner_effect(ref, $$component);
      $$component($$anchor2, spread_props({ fragmentShader: fragmentShader8, vertexShader: vertexShader8 }, () => props, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(MeshDiscardMaterial, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, ref);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MeshDiscardMaterial = hmr(MeshDiscardMaterial, () => MeshDiscardMaterial[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeshDiscardMaterial[HMR].source;
    set(MeshDiscardMaterial[HMR].source, module.default[HMR].original);
  });
}
var MeshDiscardMaterial_default = MeshDiscardMaterial;
mark_module_end(MeshDiscardMaterial);

// node_modules/@threlte/extras/dist/components/Resize/Resize.svelte
mark_module_start();
Resize[FILENAME] = "node_modules/@threlte/extras/dist/components/Resize/Resize.svelte";
var _box = new Box3();
function Resize($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Resize);
  validate_prop_bindings($$props, ["ref"], ["resize"], Resize);
  const { renderStage } = useThrelte();
  let auto = prop($$props, "auto", 3, false), box = prop($$props, "box", 3, _box), stage = prop($$props, "stage", 19, () => useStage("<Resize>", { before: renderStage })), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "axis",
      "auto",
      "box",
      "precise",
      "onresize",
      "stage",
      "ref",
      "children"
    ],
    "props"
  );
  ref(new Group());
  const inner = new Group();
  const outer = new Group();
  const doResize = () => {
    var _a;
    outer.matrixWorld.identity();
    const { max, min } = box().setFromObject(inner, $$props.precise);
    const width = max.x - min.x;
    const height = max.y - min.y;
    const depth = max.z - min.z;
    const denominator = strict_equals($$props.axis, "x") ? width : strict_equals($$props.axis, "y") ? height : strict_equals($$props.axis, "z") ? depth : Math.max(width, height, depth);
    outer.scale.setScalar(1 / denominator);
    (_a = $$props.onresize) == null ? void 0 : _a.call($$props);
  };
  const { start: scheduleResizing, stop } = useTask(
    () => {
      doResize();
      stop();
    },
    { autoStart: false, stage: stage() }
  );
  const resize = scheduleResizing;
  observe(() => [$$props.axis, $$props.precise], scheduleResizing);
  const plugin = (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    observe.pre(() => [args.ref], () => {
      if (auto()) scheduleResizing();
      return () => {
        if (auto()) scheduleResizing();
      };
    });
  };
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props(
    {
      get is() {
        return ref();
      }
    },
    () => props,
    {
      children: wrap_snippet(Resize, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        T(node_1, {
          is: outer,
          children: wrap_snippet(Resize, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            T(node_2, {
              is: inner,
              children: wrap_snippet(Resize, ($$anchor4, $$slotProps3) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                InjectPlugin_default(node_3, {
                  name: "resize",
                  plugin,
                  children: wrap_snippet(Resize, ($$anchor5, $$slotProps4) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    snippet(node_4, () => $$props.children ?? noop, () => ({ ref: ref(), resize: scheduleResizing }));
                    append($$anchor5, fragment_4);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            });
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({
    get resize() {
      return resize;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Resize = hmr(Resize, () => Resize[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Resize[HMR].source;
    set(Resize[HMR].source, module.default[HMR].original);
  });
}
var Resize_default = Resize;
mark_module_end(Resize);

// node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte
mark_module_start();
CubeCamera_1[FILENAME] = "node_modules/@threlte/extras/dist/components/CubeCamera/CubeCamera.svelte";
var root_16 = add_locations(template(`<!> <!>`, 1), CubeCamera_1[FILENAME], []);
function CubeCamera_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CubeCamera_1);
  const $$stores = setup_stores();
  const $started = () => (validate_store(started, "started"), store_get(started, "$started", $$stores));
  validate_prop_bindings($$props, ["ref"], ["renderTarget", "camera", "restart"], CubeCamera_1);
  let background = prop($$props, "background", 3, "auto"), far = prop($$props, "far", 3, 1e3), fog = prop($$props, "fog", 3, "auto"), frames = prop($$props, "frames", 3, Infinity), near = prop($$props, "near", 3, 0.1), resolution = prop($$props, "resolution", 3, 256), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "background",
      "far",
      "fog",
      "frames",
      "near",
      "onrenderstart",
      "onrenderstop",
      "resolution",
      "children",
      "ref"
    ],
    "props"
  );
  ref(new Group());
  const renderTarget = new WebGLCubeRenderTarget(resolution());
  observe.pre(() => [resolution()], () => {
    renderTarget.setSize(resolution(), resolution());
  });
  onDestroy(() => {
    renderTarget.dispose();
  });
  const camera = new CubeCamera(near(), far(), renderTarget);
  observe.pre(() => [near(), far()], () => {
    camera.children.forEach((child2) => {
      if (isInstanceOf(child2, "PerspectiveCamera")) {
        child2.far = far();
        child2.near = near();
        child2.updateProjectionMatrix();
      }
    });
  });
  const { renderer, scene } = useThrelte();
  const inner = new Group();
  let count = 0;
  const { start, stop, started } = useTask(
    () => {
      var _a;
      if (count < frames()) {
        inner.visible = false;
        const originalFog = scene.fog;
        const originalBackground = scene.background;
        scene.background = strict_equals(background(), "auto") ? originalBackground : background();
        scene.fog = strict_equals(fog(), "auto") ? originalFog : fog();
        camera.update(renderer, scene);
        scene.background = originalBackground;
        scene.fog = originalFog;
        inner.visible = true;
        count += 1;
      } else {
        stop();
        (_a = $$props.onrenderstop) == null ? void 0 : _a.call($$props);
      }
    },
    { autoStart: false }
  );
  const restart = () => {
    var _a, _b;
    if ($started()) {
      stop();
      (_a = $$props.onrenderstop) == null ? void 0 : _a.call($$props);
    }
    count = 0;
    start();
    (_b = $$props.onrenderstart) == null ? void 0 : _b.call($$props);
  };
  observe.pre(
    () => [
      background(),
      far(),
      near(),
      fog(),
      frames(),
      resolution()
    ],
    restart
  );
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props(
    {
      get is() {
        return ref();
      }
    },
    () => props,
    {
      children: wrap_snippet(CubeCamera_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_16();
        var node_1 = first_child(fragment_1);
        T(node_1, { is: camera });
        var node_2 = sibling(node_1, 2);
        T(node_2, {
          is: inner,
          children: wrap_snippet(CubeCamera_1, ($$anchor3, $$slotProps2) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children ?? noop, () => ({
              camera,
              ref: ref(),
              renderTarget,
              restart
            }));
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        });
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  append($$anchor, fragment);
  return pop({
    get renderTarget() {
      return renderTarget;
    },
    get camera() {
      return camera;
    },
    get restart() {
      return restart;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  CubeCamera_1 = hmr(CubeCamera_1, () => CubeCamera_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CubeCamera_1[HMR].source;
    set(CubeCamera_1[HMR].source, module.default[HMR].original);
  });
}
var CubeCamera_default = CubeCamera_1;
mark_module_end(CubeCamera_1);

// node_modules/@threlte/extras/dist/components/GradientTexture/common.js
var applyGradient = (context, gradient) => {
  context.save();
  let lastFillStyle = context.fillStyle;
  context.fillStyle = gradient;
  context.fillRect(0, 0, context.canvas.width, context.canvas.height);
  context.fillStyle = lastFillStyle;
  context.restore();
};
var color = new Color();
var addStops = (gradient, stops = []) => {
  for (const stop of stops) {
    gradient.addColorStop(stop.offset, color.set(stop.color).getStyle());
  }
  return gradient;
};

// node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte
mark_module_start();
LinearGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/linear/LinearGradientTexture.svelte";
function LinearGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinearGradientTexture);
  validate_prop_bindings($$props, ["ref"], [], LinearGradientTexture);
  let width = prop($$props, "width", 3, 1024), height = prop($$props, "height", 3, 1024), startX = prop($$props, "startX", 3, 0), startY = prop($$props, "startY", 3, 0), endX = prop($$props, "endX", 3, 0), endY = prop($$props, "endY", 19, height), stops = prop($$props, "stops", 19, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "startX",
      "startY",
      "endX",
      "endY",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  const texture = new CanvasTexture(canvas);
  user_pre_effect(() => {
    canvas.width = width();
  });
  user_pre_effect(() => {
    canvas.height = height();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  const gradient = derived(() => {
    const gradient2 = context == null ? void 0 : context.createLinearGradient(startX(), startY(), endX(), endY());
    if (strict_equals(gradient2, void 0, false)) {
      addStops(gradient2, stops());
    }
    return gradient2;
  });
  const { invalidate } = useThrelte();
  user_effect(() => {
    if (strict_equals(get(gradient), void 0, false) && strict_equals(context, null, false)) {
      applyGradient(context, get(gradient));
      texture.needsUpdate = true;
      invalidate();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props(
      {
        is: texture,
        get attach() {
          return attach();
        }
      },
      () => props,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        children: wrap_snippet(LinearGradientTexture, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture }));
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinearGradientTexture = hmr(LinearGradientTexture, () => LinearGradientTexture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinearGradientTexture[HMR].source;
    set(LinearGradientTexture[HMR].source, module.default[HMR].original);
  });
}
var LinearGradientTexture_default = LinearGradientTexture;
mark_module_end(LinearGradientTexture);

// node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte
mark_module_start();
RadialGradientTexture[FILENAME] = "node_modules/@threlte/extras/dist/components/GradientTexture/radial/RadialGradientTexture.svelte";
function RadialGradientTexture($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RadialGradientTexture);
  validate_prop_bindings($$props, ["ref"], [], RadialGradientTexture);
  let width = prop($$props, "width", 3, 1024), height = prop($$props, "height", 3, 1024), innerRadius = prop($$props, "innerRadius", 3, 0), outerRadius = prop($$props, "outerRadius", 3, "auto"), stops = prop($$props, "stops", 19, () => [
    { offset: 0, color: "black" },
    { offset: 1, color: "white" }
  ]), attach = prop($$props, "attach", 3, "map"), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "innerRadius",
      "outerRadius",
      "stops",
      "attach",
      "children",
      "ref"
    ],
    "props"
  );
  const canvas = new OffscreenCanvas(0, 0);
  const context = canvas.getContext("2d");
  const texture = new CanvasTexture(canvas);
  user_pre_effect(() => {
    canvas.width = width();
  });
  user_pre_effect(() => {
    canvas.height = height();
  });
  observe(() => [$$props.wrapS, $$props.wrapT], () => {
    texture.needsUpdate = true;
    invalidate();
  });
  let canvasCenterX = derived(() => 0.5 * width());
  let canvasCenterY = derived(() => 0.5 * height());
  const gradient = derived(() => {
    const gradient2 = context == null ? void 0 : context.createRadialGradient(get(canvasCenterX), get(canvasCenterY), innerRadius(), get(canvasCenterX), get(canvasCenterY), strict_equals(outerRadius(), "auto") ? Math.hypot(get(canvasCenterX), get(canvasCenterY)) : outerRadius());
    if (strict_equals(gradient2, void 0, false)) {
      addStops(gradient2, stops());
    }
    return gradient2;
  });
  const { invalidate } = useThrelte();
  user_effect(() => {
    if (strict_equals(get(gradient), void 0, false) && strict_equals(context, null, false)) {
      applyGradient(context, get(gradient));
      texture.needsUpdate = true;
      invalidate();
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: texture }, () => props, {
      get attach() {
        return attach();
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(RadialGradientTexture, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: texture }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RadialGradientTexture = hmr(RadialGradientTexture, () => RadialGradientTexture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RadialGradientTexture[HMR].source;
    set(RadialGradientTexture[HMR].source, module.default[HMR].original);
  });
}
var RadialGradientTexture_default = RadialGradientTexture;
mark_module_end(RadialGradientTexture);

// node_modules/@threlte/extras/dist/suspense/Suspense.svelte
mark_module_start();
Suspense[FILENAME] = "node_modules/@threlte/extras/dist/suspense/Suspense.svelte";
var root5 = add_locations(template(`<!> <!>`, 1), Suspense[FILENAME], []);
function Suspense($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Suspense);
  const $$stores = setup_stores();
  const $suspended = () => (validate_store(suspended, "suspended"), store_get(suspended, "$suspended", $$stores));
  const $errors = () => (validate_store(errors, "errors"), store_get(errors, "$errors", $$stores));
  validate_prop_bindings($$props, [], [], Suspense);
  let final = prop($$props, "final", 3, false);
  const { suspended, errors, setFinal } = createSuspenseContext({ final: final() });
  user_effect(() => setFinal(final()));
  user_effect(() => {
    var _a;
    if (!$suspended()) (_a = $$props.onload) == null ? void 0 : _a.call($$props);
  });
  user_effect(() => {
    var _a;
    if ($suspended()) (_a = $$props.onsuspend) == null ? void 0 : _a.call($$props);
  });
  user_effect(() => {
    var _a;
    if ($errors().length > 0) (_a = $$props.onerror) == null ? void 0 : _a.call($$props, $errors());
  });
  const group = new Group();
  const parentObject3D = useParentObject3D();
  watch([parentObject3D, suspended, errors], ([parent, suspended2, errors2]) => {
    if (!parent) return;
    if (suspended2 || errors2.length) {
      parent.remove(group);
      return;
    }
    parent.add(group);
    return () => {
      parent.remove(group);
    };
  });
  var fragment = root5();
  var node = first_child(fragment);
  T(node, {
    is: group,
    attach: false,
    children: wrap_snippet(Suspense, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop, () => ({
        suspended: $suspended(),
        errors: $errors()
      }));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      snippet(node_3, () => $$props.error ?? noop, () => ({ errors: $errors() }));
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_4 = first_child(fragment_3);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          snippet(node_5, () => $$props.fallback ?? noop);
          append($$anchor3, fragment_4);
        };
        if_block(
          node_4,
          ($$render) => {
            if ($suspended()) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment_3);
    };
    if_block(node_2, ($$render) => {
      if ($errors().length) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Suspense = hmr(Suspense, () => Suspense[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Suspense[HMR].source;
    set(Suspense[HMR].source, module.default[HMR].original);
  });
}
var Suspense_default = Suspense;
mark_module_end(Suspense);

// node_modules/@threlte/extras/dist/suspense/onReveal.js
var onReveal = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  let cleanup;
  const mounted = writable(false);
  onMount(() => {
    if (!ctx)
      cleanup = callback();
    mounted.set(true);
  });
  if (!ctx) {
    onDestroy(() => cleanup == null ? void 0 : cleanup());
    return;
  }
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && !suspended)
      cleanup = callback();
    return () => cleanup == null ? void 0 : cleanup();
  });
};

// node_modules/@threlte/extras/dist/suspense/onSuspend.js
var onSuspend = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  if (!ctx)
    return;
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
  });
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/components/portals/usePortalContext.js
var createPortalContext = () => {
  const ctx = {
    portals: currentWritable(/* @__PURE__ */ new Map()),
    addPortal(object, id) {
      ctx.portals.update((portals) => {
        if (portals.has(id)) {
          console.warn(`Portal with id ${id} already exists. Skipping portal creation.`);
        } else {
          portals.set(id, object);
        }
        return portals;
      });
    },
    removePortal(id) {
      ctx.portals.update((portals) => {
        if (!portals.has(id)) {
          console.warn(`Portal with id ${id} does not exist. Skipping portal removal.`);
        } else {
          portals.delete(id);
        }
        return portals;
      });
    },
    getPortal(id) {
      return derived2(ctx.portals, (portals) => portals.get(id));
    },
    hasPortal(id) {
      return ctx.portals.current.has(id);
    }
  };
  return ctx;
};
var usePortalContext = () => {
  return useThrelteUserContext("threlte-portals", createPortalContext());
};

// node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte
mark_module_start();
Portal[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  const $$stores = setup_stores();
  const $portal = () => (validate_store(get(portal), "portal"), store_get(get(portal), "$portal", $$stores));
  const $target = () => (validate_store(target, "target"), store_get(target, "$target", $$stores));
  validate_prop_bindings($$props, [], [], Portal);
  let id = prop($$props, "id", 3, "default");
  const { getPortal } = usePortalContext();
  const children = writable([]);
  const target = writable();
  let portal = derived(() => getPortal(id()));
  user_pre_effect(() => target.set($$props.object ?? $portal()));
  watch([children, target], ([children2, target2]) => {
    if (strict_equals(target2, void 0)) return;
    for (const child2 of children2) {
      if (target2.children.includes(child2)) continue;
      target2.add(child2);
    }
    return () => {
      for (const child2 of children2) {
        if (target2.children.includes(child2)) {
          target2.remove(child2);
        }
      }
    };
  });
  const proxy2 = new Object3D();
  proxy2.add = (child2) => {
    children.update((array) => {
      array.push(child2);
      return array;
    });
    return child2;
  };
  proxy2.remove = (child2) => {
    children.update((array) => {
      array.splice(array.indexOf(child2), 1);
      return array;
    });
    return child2;
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      T(node_1, {
        is: proxy2,
        attach: false,
        children: wrap_snippet(Portal, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($target()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var Portal_default = Portal;
mark_module_end(Portal);

// node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte
mark_module_start();
PortalTarget[FILENAME] = "node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte";
function PortalTarget($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PortalTarget);
  const $$stores = setup_stores();
  const $parent = () => (validate_store(parent, "parent"), store_get(parent, "$parent", $$stores));
  validate_prop_bindings($$props, [], [], PortalTarget);
  let id = prop($$props, "id", 3, "default");
  const parent = useParent();
  if (!$parent()) {
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  }
  const { addPortal, removePortal } = usePortalContext();
  watch(parent, (parent2) => {
    if (!parent2 || !isInstanceOf(parent2, "Object3D")) return;
    addPortal(parent2, id());
    return () => {
      removePortal(id());
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PortalTarget = hmr(PortalTarget, () => PortalTarget[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PortalTarget[HMR].source;
    set(PortalTarget[HMR].source, module.default[HMR].original);
  });
}
var PortalTarget_default = PortalTarget;
mark_module_end(PortalTarget);

// node_modules/@threlte/extras/dist/components/Text/Text.svelte
mark_module_start();
Text_1[FILENAME] = "node_modules/@threlte/extras/dist/components/Text/Text.svelte";
function Text_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text_1);
  validate_prop_bindings($$props, ["ref"], [], Text_1);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "font",
      "characters",
      "sdfGlyphSize",
      "ref",
      "onsync",
      "children"
    ],
    "props"
  );
  const text = new Text();
  const { invalidate } = useThrelte();
  const onUpdate = async () => {
    await tick();
    text.sync(() => {
      var _a;
      invalidate();
      (_a = $$props.onsync) == null ? void 0 : _a.call($$props);
    });
  };
  user_pre_effect(() => {
    props;
    onUpdate();
  });
  const suspend = useSuspense();
  user_pre_effect(() => {
    suspend(new Promise((res) => preloadFont(
      {
        font: $$props.font,
        characters: $$props.characters,
        sdfGlyphSize: $$props.sdfGlyphSize
      },
      res
    )));
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: text }, () => props, {
      get font() {
        return $$props.font;
      },
      get characters() {
        return $$props.characters;
      },
      get sdfGlyphSize() {
        return $$props.sdfGlyphSize;
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Text_1, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: text }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text_1 = hmr(Text_1, () => Text_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text_1[HMR].source;
    set(Text_1[HMR].source, module.default[HMR].original);
  });
}
var Text_default = Text_1;
mark_module_end(Text_1);

// node_modules/@threlte/extras/dist/audio/useThrelteAudio.js
var audioListeners = /* @__PURE__ */ new Map();
var audioCtx = {
  audioListeners,
  addAudioListener: (listener, id = "default") => {
    if (audioListeners.has(id)) {
      console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
      return;
    }
    audioListeners.set(id, listener);
  },
  removeAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    audioListeners.delete(id);
  },
  getAudioListener: (id = "default") => {
    if (!audioListeners.has(id)) {
      console.warn(`No AudioListener with the id "${id}" found, aborting.`);
      return;
    }
    return audioListeners.get(id);
  }
};
function useThrelteAudio() {
  return useThrelteUserContext("threlte-audio", audioCtx);
}

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
mark_module_start();
AudioListener2[FILENAME] = "node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte";
function AudioListener2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AudioListener2);
  validate_prop_bindings($$props, ["ref"], ["audioContext", "resumeContext"], AudioListener2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "masterVolume",
      "ref",
      "children"
    ],
    "props"
  );
  const listener = new AudioListener();
  const audioContext = listener.context;
  const resumeContext = () => listener.context.resume();
  user_pre_effect(() => {
    if (strict_equals($$props.masterVolume, void 0, false)) {
      listener.setMasterVolume($$props.masterVolume);
    }
  });
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(listener, $$props.id);
  onDestroy(() => {
    removeAudioListener($$props.id);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: listener }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(AudioListener2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: listener }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get audioContext() {
      return audioContext;
    },
    get resumeContext() {
      return resumeContext;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  AudioListener2 = hmr(AudioListener2, () => AudioListener2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AudioListener2[HMR].source;
    set(AudioListener2[HMR].source, module.default[HMR].original);
  });
}
var AudioListener_default = AudioListener2;
mark_module_end(AudioListener2);

// node_modules/@threlte/extras/dist/audio/utils/useAudio.js
var useAudio = (audio, props = {}) => {
  const loaded = currentWritable(false);
  const autoplay = currentWritable(false);
  const shouldPlay = currentWritable(false);
  let audioDestroyed = false;
  const loader = useLoader(AudioLoader);
  const setSrc = async (source) => {
    var _a, _b, _c;
    loaded.set(false);
    try {
      if (typeof source === "string") {
        const audioBuffer = await loader.load(source, {
          onProgress(event) {
            var _a2;
            (_a2 = props.onprogress) == null ? void 0 : _a2.call(props, event);
          }
        });
        audio.setBuffer(audioBuffer);
      } else if (source instanceof AudioBuffer) {
        audio.setBuffer(source);
      } else if (source instanceof HTMLMediaElement) {
        audio.setMediaElementSource(source);
      } else if (source instanceof AudioBufferSourceNode) {
        audio.setNodeSource(source);
      } else if (source instanceof MediaStream) {
        audio.setMediaStreamSource(source);
      }
      loaded.set(true);
      audio.buffer ? (_a = props.onload) == null ? void 0 : _a.call(props, audio.buffer) : (_b = props.onload) == null ? void 0 : _b.call(props);
    } catch (error) {
      (_c = props.onerror) == null ? void 0 : _c.call(props, error);
    }
  };
  const setVolume = (volume) => {
    audio.setVolume(volume ?? 1);
  };
  const setPlaybackRate = (playbackRate) => {
    audio.setPlaybackRate(playbackRate ?? 1);
  };
  const play = async (delay) => {
    if (!loaded.current) {
      shouldPlay.set(true);
      return;
    }
    if (audio.context.state !== "running") {
      await audio.context.resume();
      if (audioDestroyed) {
        return;
      }
    }
    return audio.play(delay);
  };
  const pause = () => {
    return audio.pause();
  };
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setAutoPlay = (value) => {
    autoplay.set(value ?? false);
  };
  const setDetune = (value) => {
    if (audio.source && audio.detune) {
      audio.setDetune(value ?? 0);
    }
  };
  const setLoop = (value) => {
    audio.setLoop(value ?? false);
  };
  watch([loaded, autoplay, shouldPlay], ([loaded2, autoplay2, shouldPlay2]) => {
    if (!loaded2) {
      if (audio.isPlaying)
        stop();
      return;
    }
    if (autoplay2 || shouldPlay2) {
      play();
    }
  });
  onDestroy(() => {
    try {
      audioDestroyed = true;
      stop();
    } catch (error) {
      console.warn("Error while destroying audio", error);
    }
  });
  return {
    setVolume,
    setSrc,
    setPlaybackRate,
    setAutoPlay,
    setDetune,
    setLoop,
    play,
    pause,
    stop
  };
};

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
mark_module_start();
Audio2[FILENAME] = "node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte";
function Audio2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Audio2);
  validate_prop_bindings($$props, ["ref"], ["pause", "play", "stop"], Audio2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new Audio(listener);
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSrc($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: audio }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Audio2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Audio2 = hmr(Audio2, () => Audio2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Audio2[HMR].source;
    set(Audio2[HMR].source, module.default[HMR].original);
  });
}
var Audio_default = Audio2;
mark_module_end(Audio2);

// node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte
mark_module_start();
PositionalAudio2[FILENAME] = "node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte";
function PositionalAudio2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PositionalAudio2);
  validate_prop_bindings($$props, ["ref"], ["pause", "play", "stop"], PositionalAudio2);
  let ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "id",
      "volume",
      "playbackRate",
      "autoplay",
      "detune",
      "loop",
      "directionalCone",
      "refDistance",
      "rolloffFactor",
      "distanceModel",
      "maxDistance",
      "ref",
      "children"
    ],
    "props"
  );
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener($$props.id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${$$props.id} found.`);
  }
  const audio = new PositionalAudio(listener);
  user_effect(() => {
    if (strict_equals($$props.refDistance, void 0, false)) audio.setRefDistance($$props.refDistance);
    if (strict_equals($$props.rolloffFactor, void 0, false)) audio.setRolloffFactor($$props.rolloffFactor);
    if (strict_equals($$props.distanceModel, void 0, false)) audio.setDistanceModel($$props.distanceModel);
    if (strict_equals($$props.maxDistance, void 0, false)) audio.setMaxDistance($$props.maxDistance);
    if (strict_equals($$props.directionalCone, void 0, false)) {
      audio.setDirectionalCone($$props.directionalCone.coneInnerAngle, $$props.directionalCone.coneOuterAngle, $$props.directionalCone.coneOuterGain);
    }
  });
  const {
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc: setSource,
    setVolume,
    ...useAudioProps
  } = useAudio(audio, props);
  const pause = useAudioProps.pause;
  const play = useAudioProps.play;
  const stop = useAudioProps.stop;
  user_effect(() => setAutoPlay($$props.autoplay));
  user_effect(() => void setSource($$props.src));
  user_effect(() => setVolume($$props.volume));
  user_effect(() => setPlaybackRate($$props.playbackRate));
  user_effect(() => setLoop($$props.loop));
  user_effect(() => setDetune($$props.detune));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, T);
    T(node, spread_props({ is: audio }, () => props, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(PositionalAudio2, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop, () => ({ ref: audio }));
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
  }
  append($$anchor, fragment);
  return pop({
    get pause() {
      return pause;
    },
    get play() {
      return play;
    },
    get stop() {
      return stop;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  PositionalAudio2 = hmr(PositionalAudio2, () => PositionalAudio2[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PositionalAudio2[HMR].source;
    set(PositionalAudio2[HMR].source, module.default[HMR].original);
  });
}
var PositionalAudio_default = PositionalAudio2;
mark_module_end(PositionalAudio2);

// node_modules/@threlte/extras/dist/audio/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const { getAudioListener } = useThrelteAudio();
  if (typeof callbackOrId === "function") {
    const listener2 = getAudioListener(id);
    if (!listener2)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener: listener2,
      context: listener2.context
    });
  }
  const listener = getAudioListener(callbackOrId);
  if (!listener)
    throw new Error("No AudioListener found.");
  return {
    listener,
    context: listener.context
  };
}

// node_modules/@threlte/extras/dist/interactivity/defaults.js
var getDefaultComputeFunction = (target) => {
  const { camera } = useThrelte();
  let width = target.current.clientWidth;
  let height = target.current.clientHeight;
  const resizeObserver = new ResizeObserver(([entry]) => {
    width = entry.contentRect.width;
    height = entry.contentRect.height;
  });
  watch(target, (target2) => {
    if (target2)
      resizeObserver.observe(target2);
    return () => {
      if (target2)
        resizeObserver.unobserve(target2);
    };
  });
  return (event, state2) => {
    state2.pointer.update((pointer) => {
      pointer.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
      return pointer;
    });
    state2.raycaster.setFromCamera(state2.pointer.current, camera.current);
  };
};

// node_modules/@threlte/extras/dist/interactivity/context.js
var contextKey = Symbol("interactivity-context");
var getInteractivityContext = () => {
  return getContext(contextKey);
};
var setInteractivityContext = (options) => {
  var _a;
  const target = currentWritable((options == null ? void 0 : options.target) ?? ((_a = useThrelte().renderer.domElement) == null ? void 0 : _a.parentElement));
  const context = {
    enabled: currentWritable((options == null ? void 0 : options.enabled) ?? true),
    pointer: currentWritable(new Vector2()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target,
    handlers: /* @__PURE__ */ new WeakMap(),
    compute: (options == null ? void 0 : options.compute) ?? getDefaultComputeFunction(target),
    filter: options == null ? void 0 : options.filter,
    addInteractiveObject: (object, events) => {
      if (context.interactiveObjects.indexOf(object) > -1) {
        return;
      }
      context.handlers.set(object, events);
      context.interactiveObjects.push(object);
    },
    removeInteractiveObject: (object) => {
      const index = context.interactiveObjects.indexOf(object);
      context.interactiveObjects.splice(index, 1);
      context.handlers.delete(object);
    }
  };
  setContext(contextKey, context);
  return context;
};
var useInteractivity = () => {
  const context = getInteractivityContext();
  if (!context) {
    throw new Error("No interactivity context found. Did you forget to implement interactivity()?");
  }
  return context;
};

// node_modules/@threlte/extras/dist/interactivity/plugin.svelte.js
var interactivityEventNames = [
  "onclick",
  "oncontextmenu",
  "ondblclick",
  "onwheel",
  "onpointerup",
  "onpointerdown",
  "onpointerover",
  "onpointerout",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointermissed"
];
var injectInteractivityPlugin = () => {
  injectPlugin("interactivity", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const hasEventHandlers = Object.entries(args.props).some(([key2, value]) => {
      return strict_equals(value, void 0, false) && interactivityEventNames.includes(key2);
    });
    if (!hasEventHandlers) return;
    const { addInteractiveObject, removeInteractiveObject } = useInteractivity();
    observe.pre(() => [args.ref], ([ref]) => {
      addInteractiveObject(ref, args.props);
      return () => {
        removeInteractiveObject(ref);
      };
    });
    return { pluginProps: interactivityEventNames };
  });
};

// node_modules/@threlte/extras/dist/interactivity/setupInteractivity.js
function getIntersectionId(event) {
  return `${(event.eventObject || event.object).uuid}/${event.index}${event.instanceId}`;
}
var DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true]
];
var setupInteractivity = (context) => {
  const { handlers } = useInteractivity();
  const calculateDistance = (event) => {
    const dx = event.offsetX - context.initialClick[0];
    const dy = event.offsetY - context.initialClick[1];
    return Math.round(Math.hypot(dx, dy));
  };
  const cancelPointer = (intersections) => {
    var _a, _b;
    for (const hoveredObj of context.hovered.values()) {
      if (intersections.length === 0 || !intersections.some((hit) => {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId;
      })) {
        const { eventObject } = hoveredObj;
        context.hovered.delete(getIntersectionId(hoveredObj));
        const events = handlers.get(eventObject);
        if (events) {
          const data = { ...hoveredObj, intersections };
          (_a = events.onpointerout) == null ? void 0 : _a.call(events, data);
          (_b = events.onpointerleave) == null ? void 0 : _b.call(events, data);
        }
      }
    }
  };
  const getHits = () => {
    if (!context.enabled.current)
      return [];
    const intersections = [];
    const hits = context.raycaster.intersectObjects(context.interactiveObjects, true);
    const filtered = context.filter === void 0 ? hits : context.filter(hits, context);
    for (const hit of filtered) {
      let eventObject = hit.object;
      while (eventObject) {
        if (handlers.has(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  const pointerMissed = (event, objects) => {
    var _a, _b;
    for (const object of objects) {
      (_b = (_a = handlers.get(object)) == null ? void 0 : _a.onpointermissed) == null ? void 0 : _b.call(_a, event);
    }
  };
  const getEventHandler = (name) => {
    if (name === "pointerleave" || name === "pointercancel") {
      return () => {
        context.pointerOverTarget.set(false);
        cancelPointer([]);
      };
    }
    if (name === "pointerenter") {
      return () => {
        context.pointerOverTarget.set(true);
      };
    }
    return (event) => {
      var _a, _b, _c, _d;
      const isPointerMove = name === "pointermove";
      const isClickEvent = name === "click" || name === "contextmenu" || name === "dblclick";
      context.compute(event, context);
      const hits = getHits();
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "pointerdown") {
        context.initialClick = [event.offsetX, event.offsetY];
        context.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && hits.length === 0) {
        if (delta <= 2) {
          pointerMissed(event, context.interactiveObjects);
        }
      }
      if (isPointerMove)
        cancelPointer(hits);
      let stopped = false;
      dispatchEvents: for (const hit of hits) {
        const intersectionEvent = {
          stopped,
          ...hit,
          intersections: hits,
          stopPropagation() {
            stopped = true;
            intersectionEvent.stopped = true;
            if (context.hovered.size > 0 && Array.from(context.hovered.values()).some((i) => i.eventObject === hit.eventObject)) {
              const higher = hits.slice(0, hits.indexOf(hit));
              cancelPointer([...higher, hit]);
            }
          },
          camera: context.raycaster.camera,
          delta,
          nativeEvent: event,
          pointer: context.pointer.current,
          ray: context.raycaster.ray
        };
        const events = handlers.get(hit.eventObject);
        if (!events)
          return;
        if (isPointerMove) {
          if (events.onpointerover || events.onpointerenter || events.onpointerout || events.onpointerleave) {
            const id = getIntersectionId(intersectionEvent);
            const hoveredItem = context.hovered.get(id);
            if (!hoveredItem) {
              context.hovered.set(id, intersectionEvent);
              (_a = events.onpointerover) == null ? void 0 : _a.call(events, intersectionEvent);
              (_b = events.onpointerenter) == null ? void 0 : _b.call(events, intersectionEvent);
            } else if (hoveredItem.stopped) {
              intersectionEvent.stopPropagation();
            }
          }
          (_c = events.onpointermove) == null ? void 0 : _c.call(events, intersectionEvent);
        } else {
          if (events[`on${name}`]) {
            if (!isClickEvent || context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
              (_d = events[`on${name}`]) == null ? void 0 : _d.call(events, intersectionEvent);
            }
          } else {
            if (isClickEvent && context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
            }
          }
        }
        if (stopped)
          break dispatchEvents;
      }
    };
  };
  const disconnect = (target) => {
    DOM_EVENTS.forEach(([eventName]) => {
      target.removeEventListener(eventName, getEventHandler(eventName));
    });
  };
  const connect = (target) => {
    DOM_EVENTS.forEach(([eventName, passive]) => {
      target.addEventListener(eventName, getEventHandler(eventName), { passive });
    });
  };
  watch(context.target, (target) => {
    if (target)
      connect(target);
    return () => {
      if (target)
        disconnect(target);
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/index.js
var interactivity = (options) => {
  const context = setInteractivityContext(options);
  injectInteractivityPlugin();
  setupInteractivity(context);
  return context;
};

// node_modules/@threlte/extras/dist/layers/plugin.svelte.js
var injectLayersPlugin = () => {
  injectPlugin("layers", (args) => {
    if (!isInstanceOf(args.ref, "Object3D")) return;
    const ctx = getContext("threlte-layers-context");
    const mergedLayers = derived(() => args.props.layers ?? (ctx == null ? void 0 : ctx.layers));
    const mergedCtx = derived(() => get(mergedLayers) ? { layers: get(mergedLayers) } : void 0);
    setContext("threlte-layers-context", get(mergedCtx));
    const applyLayers = (ref, layers2) => {
      if (strict_equals(layers2, "all")) {
        ref.layers.enableAll();
      } else if (strict_equals(layers2, "none")) {
        ref.layers.disableAll();
      } else if (Array.isArray(layers2)) {
        for (let index = 0; index < 32; index += 1) {
          const layerIndex = index;
          const enabled = layers2.includes(layerIndex);
          if (enabled) {
            ref.layers.enable(index);
          } else {
            ref.layers.disable(index);
          }
        }
      } else if (strict_equals(layers2, void 0, false)) {
        ref.layers.set(layers2);
      }
    };
    observe.pre(() => [args.ref, get(mergedLayers)], ([ref, layers2]) => {
      if (!isInstanceOf(ref, "Object3D")) return;
      applyLayers(ref, layers2);
    });
    return { pluginProps: ["layers"] };
  });
};

// node_modules/@threlte/extras/dist/layers/index.js
var layers = (options) => {
  setContext("threlte-layers-context", {
    layers: (options == null ? void 0 : options.defaultLayers) ?? 0
  });
  injectLayersPlugin();
};

// node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte
mark_module_start();
SpriteInstance[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte";
function SpriteInstance($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SpriteInstance);
  validate_prop_bindings($$props, [], [], SpriteInstance);
  let id = prop($$props, "id", 3, 0), position2 = prop($$props, "position", 19, () => [0, 0, 0]), scale = prop($$props, "scale", 19, () => [1, 1]);
  const { updatePosition, sprite } = getContext("instanced-sprite-ctx");
  user_pre_effect(() => {
    if (strict_equals(position2(), void 0, false)) updatePosition(id(), position2(), scale());
  });
  user_pre_effect(() => {
    if (strict_equals($$props.animationName, void 0, false)) sprite.animation.setAt(id(), $$props.animationName);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.playmode, void 0, false)) sprite.playmode.setAt(id(), $$props.playmode);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0, false)) sprite.billboarding.setAt(id(), $$props.billboarding);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.offset, void 0, false)) sprite.offset.setAt(id(), $$props.offset);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.loop, void 0, false)) sprite.loop.setAt(id(), $$props.loop);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipX, void 0, false)) sprite.flipX.setAt(id(), $$props.flipX);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.flipY, void 0, false)) sprite.flipY.setAt(id(), $$props.flipY);
  });
  user_pre_effect(() => {
    if (strict_equals($$props.frameId, void 0, false)) sprite.frame.setAt(id(), $$props.frameId, $$props.animationName);
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SpriteInstance = hmr(SpriteInstance, () => SpriteInstance[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SpriteInstance[HMR].source;
    set(SpriteInstance[HMR].source, module.default[HMR].original);
  });
}
var SpriteInstance_default = SpriteInstance;
mark_module_end(SpriteInstance);

// node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte
mark_module_start();
InstancedSprite[FILENAME] = "node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte";
function InstancedSprite($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InstancedSprite);
  validate_prop_bindings($$props, ["ref"], [], InstancedSprite);
  let autoUpdate = prop($$props, "autoUpdate", 3, true), baseMaterial = prop($$props, "baseMaterial", 3, MeshBasicMaterial), fps = prop($$props, "fps", 3, 15), playmode = prop($$props, "playmode", 3, "FORWARD"), count = prop($$props, "count", 3, 1e3), alphaTest = prop($$props, "alphaTest", 3, 0.1), transparent = prop($$props, "transparent", 3, true), randomPlaybackOffset = prop($$props, "randomPlaybackOffset", 3, false), ref = prop($$props, "ref", 15), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoUpdate",
      "baseMaterial",
      "fps",
      "billboarding",
      "playmode",
      "count",
      "alphaTest",
      "transparent",
      "hueShift",
      "randomPlaybackOffset",
      "spritesheet",
      "ref",
      "children"
    ],
    "props"
  );
  const spriteBaseMaterial = new (baseMaterial())({
    transparent: transparent(),
    alphaTest: alphaTest(),
    // needs to be double side for shading
    side: DoubleSide
  });
  const { renderer } = useThrelte();
  const mesh = new Kt(spriteBaseMaterial, count(), renderer);
  ref(mesh);
  const animationMap = writable(/* @__PURE__ */ new Map());
  user_pre_effect(() => {
    if ($$props.spritesheet) {
      mesh.spritesheet = $$props.spritesheet.spritesheet;
      animationMap.set(mesh.animationMap);
      mesh.material.map = $$props.spritesheet.texture;
      mesh.material.needsUpdate = true;
    }
  });
  user_pre_effect(() => {
    mesh.material.alphaTest = alphaTest();
  });
  user_pre_effect(() => {
    mesh.material.transparent = transparent();
  });
  user_pre_effect(() => {
    mesh.fps = fps();
  });
  user_pre_effect(() => mesh.hueShift.setGlobal($$props.hueShift));
  user_pre_effect(() => {
    if (strict_equals($$props.billboarding, void 0)) {
      mesh.billboarding.unsetAll();
      return;
    } else {
      mesh.billboarding.setAll($$props.billboarding);
    }
  });
  user_pre_effect(() => {
    if (strict_equals(playmode(), void 0)) {
      mesh.playmode.setAll("PAUSE");
      return;
    } else {
      mesh.playmode.setAll(playmode());
    }
  });
  let previousRndOffset = state(false);
  user_pre_effect(() => {
    if (strict_equals(get(previousRndOffset), false) && randomPlaybackOffset()) {
      mesh.offset.randomizeAll(strict_equals(randomPlaybackOffset(), true) ? 100 : randomPlaybackOffset());
    }
    if (strict_equals(get(previousRndOffset), true) && !randomPlaybackOffset()) {
      for (let i = 0; i < count(); i++) {
        mesh.offset.setAt(i, 0);
      }
    }
    set(previousRndOffset, proxy(randomPlaybackOffset() ? true : false, null, previousRndOffset));
  });
  let instanceMatrixNeedsUpdate = false;
  const tempMatrix = new Matrix4();
  const updatePosition = (id, position2, scale = [1, 1]) => {
    tempMatrix.makeScale(scale[0], scale[1], 1);
    tempMatrix.setPosition(...position2);
    mesh.setMatrixAt(id, tempMatrix);
    instanceMatrixNeedsUpdate = true;
  };
  setContext("instanced-sprite-ctx", {
    sprite: mesh,
    count: count(),
    animationMap,
    updatePosition
  });
  useTask(() => {
    if (autoUpdate()) {
      mesh.update();
    }
    if (instanceMatrixNeedsUpdate) {
      mesh.instanceMatrix.needsUpdate = true;
      instanceMatrixNeedsUpdate = false;
    }
  });
  mesh.update();
  var fragment = comment();
  var node = first_child(fragment);
  T(node, spread_props({ is: mesh, frustumCulled: false }, () => props, {
    children: wrap_snippet(InstancedSprite, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop, () => ({ Instance: SpriteInstance_default }));
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstancedSprite = hmr(InstancedSprite, () => InstancedSprite[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstancedSprite[HMR].source;
    set(InstancedSprite[HMR].source, module.default[HMR].original);
  });
}
var InstancedSprite_default = InstancedSprite;
mark_module_end(InstancedSprite);

// node_modules/@threlte/extras/dist/components/InstancedSprite/instancedSpriteUtils.js
var useInstancedSprite = () => {
  return getContext("instanced-sprite-ctx");
};
var from = (meta) => {
  const builder = jt();
  const animationsList = [];
  for (const { url, type, width, height, animations } of meta) {
    for (const animation of animations) {
      animationsList.push(animation.name);
    }
    builder.add(url, {
      type,
      width,
      height
    }, animations);
  }
  const spritesheet = builder.build();
  const typedHook = useInstancedSprite;
  return { spritesheet, useInstancedSprite: typedHook };
};
var fromAseprite = (asepriteDataUrl, spriteImageUrl) => {
  const texture = new TextureLoader().load(spriteImageUrl, (t) => {
    t.matrixAutoUpdate = false;
    t.generateMipmaps = false;
    t.premultiplyAlpha = false;
    t.wrapS = texture.wrapT = RepeatWrapping;
    t.magFilter = texture.minFilter = NearestFilter;
    t.colorSpace = SRGBColorSpace;
    t.needsUpdate = true;
  });
  const parse = async () => {
    const res = await fetch(asepriteDataUrl);
    const json = await res.json();
    return { spritesheet: Bt(json), texture };
  };
  return parse();
};
var buildSpritesheet = { from, fromAseprite };
export {
  Align_default as Align,
  AnimatedSpriteMaterial_default as AnimatedSpriteMaterial,
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  BakeShadows_default as BakeShadows,
  Billboard_default as Billboard,
  CSM_default as CSM,
  ContactShadows_default as ContactShadows,
  CubeCamera_default as CubeCamera,
  Detailed_default as Detailed,
  Edges_default as Edges,
  Environment_default as Environment,
  FakeGlowMaterial_default as FakeGlowMaterial,
  Float_default as Float,
  GLTF_default as GLTF,
  Gizmo_default as Gizmo,
  Grid_default as Grid,
  HTML_default as HTML,
  HUD_default as HUD,
  ImageMaterial_default as ImageMaterial,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  InstancedMeshes_default as InstancedMeshes,
  InstancedSprite_default as InstancedSprite,
  LinearGradientTexture_default as LinearGradientTexture,
  Mask_default as Mask,
  MeshDiscardMaterial_default as MeshDiscardMaterial,
  MeshLineGeometry_default as MeshLineGeometry,
  MeshLineMaterial_default as MeshLineMaterial,
  MeshRefractionMaterial_default as MeshRefractionMaterial,
  OrbitControls_default as OrbitControls,
  Outlines_default as Outlines,
  PerfMonitor_default as PerfMonitor,
  Portal_default as Portal,
  PortalTarget_default as PortalTarget,
  PositionalAudio_default as PositionalAudio,
  RadialGradientTexture_default as RadialGradientTexture,
  Resize_default as Resize,
  RoundedBoxGeometry_default as RoundedBoxGeometry,
  Sky_default as Sky,
  SoftShadows_default as SoftShadows,
  Stars_default as Stars,
  Suspense_default as Suspense,
  Text_default as Text,
  Text3DGeometry_default as Text3DGeometry,
  TrackballControls_default as TrackballControls,
  TransformControls_default as TransformControls,
  buildSpritesheet,
  interactivity,
  layers,
  meshBounds,
  onReveal,
  onSuspend,
  useAudioListener,
  useCursor,
  useDraco,
  useFBO,
  useGamepad,
  useGltf,
  useGltfAnimations,
  useInstancedSprite,
  useInteractivity,
  useKtx2,
  useMask,
  useMeshopt,
  useProgress,
  useSuspense,
  useTexture,
  useThrelteAudio,
  useViewport
};
//# sourceMappingURL=@threlte_extras.js.map
